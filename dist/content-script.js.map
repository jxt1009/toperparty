{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://toperparty/./chrome-extension/src/managers/sync/lock.js","webpack://toperparty/./chrome-extension/src/managers/sync/eventListeners.js","webpack://toperparty/./chrome-extension/src/managers/sync/SyncManager.js","webpack://toperparty/./chrome-extension/src/services/webrtc/peerConnection.js","webpack://toperparty/./chrome-extension/src/content/main.js","webpack://toperparty/./chrome-extension/src/managers/state/StateManager.js","webpack://toperparty/./chrome-extension/src/ui/UIManager.js","webpack://toperparty/./chrome-extension/src/content/netflix/NetflixController.js","webpack://toperparty/./chrome-extension/src/managers/sync/remoteHandlers.js","webpack://toperparty/./chrome-extension/src/services/webrtc/WebRTCManager.js","webpack://toperparty/./chrome-extension/src/services/webrtc/ui.js","webpack://toperparty/./chrome-extension/src/services/webrtc/reconnect.js","webpack://toperparty/./chrome-extension/src/services/webrtc/signaling.js","webpack://toperparty/./chrome-extension/src/managers/url/URLSync.js"],"sourcesContent":["export class SyncLock {\n  constructor() {\n    this.suppressLocalUntil = 0;\n  }\n  set(durationMs) {\n    this.suppressLocalUntil = Date.now() + durationMs;\n  }\n  isActive() {\n    return Date.now() < this.suppressLocalUntil;\n  }\n}\n","export function attachPlaybackListeners({ video, state, isInitializedRef, lock, onPlay, onPause, onSeek }) {\n  const handlePlay = () => {\n    if (!state.isActive()) return;\n    if (!isInitializedRef.get()) return;\n    if (lock.isActive()) return;\n    console.log('[EventListeners] Play event detected');\n    onPlay(video);\n  };\n\n  const handlePause = () => {\n    if (!state.isActive()) return;\n    if (!isInitializedRef.get()) return;\n    if (lock.isActive()) return;\n    console.log('[EventListeners] Pause event detected');\n    onPause(video);\n  };\n\n  const handleSeeked = () => {\n    if (!state.isActive()) return;\n    if (!isInitializedRef.get()) return;\n    if (lock.isActive()) return;\n    console.log('[EventListeners] Seek event detected');\n    onSeek(video);\n  };\n\n  video.addEventListener('play', handlePlay);\n  video.addEventListener('pause', handlePause);\n  video.addEventListener('seeked', handleSeeked);\n\n  return { video, handlePlay, handlePause, handleSeeked };\n}\n","import { SyncLock } from './lock.js';\nimport { attachPlaybackListeners } from './eventListeners.js';\nimport { createRemoteHandlers } from './remoteHandlers.js';\n\nclass MutableRef {\n  constructor(value) { this.value = value; }\n  get() { return this.value; }\n  set(v) { this.value = v; }\n}\n\nexport class SyncManager {\n  constructor(stateManager, netflixController) {\n    this.state = stateManager;\n    this.netflix = netflixController;\n    this.lock = new SyncLock();\n    this.isInitializedRef = new MutableRef(false);\n    this.listeners = null;\n\n    this.remote = createRemoteHandlers({\n      state: this.state,\n      netflix: this.netflix,\n      lock: this.lock,\n      isInitializedRef: this.isInitializedRef,\n    });\n  }\n\n  async setup() {\n    try {\n      console.log('[SyncManager] Starting setup - waiting for video element...');\n      const video = await this.waitForVideo();\n      if (!video) { \n        console.warn('[SyncManager] Netflix video element not found'); \n        return; \n      }\n      \n      console.log('[SyncManager] Video element found, setting up event listeners');\n      \n      // Check for pending sync from URL navigation\n      const pendingSyncStr = sessionStorage.getItem('toperparty_pending_sync');\n      if (pendingSyncStr) {\n        try {\n          const pendingSync = JSON.parse(pendingSyncStr);\n          if (Date.now() - pendingSync.timestamp < 10000) {\n            console.log('[SyncManager] Applying pending sync from URL navigation');\n            sessionStorage.removeItem('toperparty_pending_sync');\n            this.isInitializedRef.set(true);\n            \n            // Apply the pending sync state\n            this.lock.set(1500);\n            await this.netflix.seek(pendingSync.currentTime * 1000);\n            const isPaused = await this.netflix.isPaused();\n            if (pendingSync.isPlaying && isPaused) {\n              await this.netflix.play();\n            } else if (!pendingSync.isPlaying && !isPaused) {\n              await this.netflix.pause();\n            }\n            \n            const listeners = attachPlaybackListeners({\n              video,\n              state: this.state,\n              isInitializedRef: this.isInitializedRef,\n              lock: this.lock,\n              onPlay: (vid) => this.broadcastPlay(vid),\n              onPause: (vid) => this.broadcastPause(vid),\n              onSeek: (vid) => this.broadcastSeek(vid)\n            });\n            this.listeners = listeners;\n            console.log('[SyncManager] Setup complete with pending sync applied');\n            return;\n          } else {\n            console.log('[SyncManager] Pending sync expired, ignoring');\n            sessionStorage.removeItem('toperparty_pending_sync');\n          }\n        } catch (e) {\n          console.error('[SyncManager] Error applying pending sync:', e);\n          sessionStorage.removeItem('toperparty_pending_sync');\n        }\n      }\n      \n      this.isInitializedRef.set(false);\n      \n      // Request initial sync from other clients\n      console.log('[SyncManager] Requesting initial sync from other clients');\n      this.state.safeSendMessage({ type: 'REQUEST_SYNC' });\n      \n      // If no response after 2 seconds, consider ourselves initialized\n      setTimeout(() => {\n        if (!this.isInitializedRef.get()) {\n          console.log('[SyncManager] No sync response received after 2s, marking as initialized');\n          this.isInitializedRef.set(true);\n        }\n      }, 2000);\n      \n      const listeners = attachPlaybackListeners({\n        video,\n        state: this.state,\n        isInitializedRef: this.isInitializedRef,\n        lock: this.lock,\n        onPlay: (vid) => this.broadcastPlay(vid),\n        onPause: (vid) => this.broadcastPause(vid),\n        onSeek: (vid) => this.broadcastSeek(vid)\n      });\n      this.listeners = listeners;\n      console.log('[SyncManager] Setup complete - ready to sync');\n    } catch (err) { \n      console.error('[SyncManager] Error setting up playback sync:', err); \n    }\n  }\n\n  teardown() {\n    console.log('[SyncManager] Tearing down sync manager');\n    if (this.listeners && this.listeners.video) {\n      const { video, handlePlay, handlePause, handleSeeked } = this.listeners;\n      try {\n        video.removeEventListener('play', handlePlay);\n        video.removeEventListener('pause', handlePause);\n        video.removeEventListener('seeked', handleSeeked);\n        console.log('[SyncManager] Event listeners removed');\n      } catch (e) { console.warn('[SyncManager] Error removing listeners:', e); }\n      this.listeners = null;\n    }\n    this.isInitializedRef.set(false);\n  }\n\n  waitForVideo() {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\n      const check = () => {\n        const video = this.netflix.getVideoElement();\n        if (video) { clearTimeout(timeout); resolve(video); }\n        else { setTimeout(check, 100); }\n      };\n      check();\n    });\n  }\n\n  isOnWatchPage() {\n    return window.location.pathname.startsWith('/watch');\n  }\n\n  broadcastPlay(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring PLAY event - not on /watch page');\n      return;\n    }\n    console.log('[SyncManager] Broadcasting PLAY event');\n    this.state.safeSendMessage({ \n      type: 'PLAY_PAUSE', \n      control: 'play', \n      currentTime: video.currentTime \n    });\n  }\n\n  broadcastPause(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring PAUSE event - not on /watch page');\n      return;\n    }\n    console.log('[SyncManager] Broadcasting PAUSE event');\n    this.state.safeSendMessage({ \n      type: 'PLAY_PAUSE', \n      control: 'pause', \n      currentTime: video.currentTime \n    });\n  }\n\n  broadcastSeek(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring SEEK event - not on /watch page');\n      return;\n    }\n    console.log('[SyncManager] Broadcasting SEEK event at', video.currentTime);\n    this.state.safeSendMessage({ \n      type: 'SEEK', \n      currentTime: video.currentTime, \n      isPlaying: !video.paused \n    });\n  }\n\n  // Remote event handlers\n  handleRequestSync(fromUserId) { return this.remote.handleRequestSync(fromUserId); }\n  handleSyncResponse(currentTime, isPlaying, fromUserId, url) { return this.remote.handleSyncResponse(currentTime, isPlaying, fromUserId, url); }\n  handlePlaybackControl(control, currentTime, fromUserId) { return this.remote.handlePlaybackControl(control, currentTime, fromUserId); }\n  handleSeek(currentTime, isPlaying, fromUserId) { return this.remote.handleSeek(currentTime, isPlaying, fromUserId); }\n}\n","export function createPeerConnectionFactory({ stateManager, sendSignal, remoteStreams, remoteVideos, addRemoteVideo, attemptReconnection, clearReconnection, removeRemoteVideo, peersThatLeft }) {\n  return function createPeerConnection(peerId) {\n    const state = stateManager.getState();\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: ['stun:stun.l.google.com:19302'] },\n        { urls: ['stun:stun1.l.google.com:19302'] }\n      ]\n    });\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('[PeerConnection] ICE candidate for peer:', peerId, event.candidate);\n        sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\n      }\n    };\n    pc.ontrack = (event) => {\n      console.log('[PeerConnection] ontrack fired for peer:', peerId, 'track:', event.track, 'streams:', event.streams);\n      let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\n      if (!stream) {\n        console.log('[PeerConnection] Creating new MediaStream for peer:', peerId);\n        stream = new MediaStream();\n        remoteStreams.set(peerId, stream);\n      }\n      if (event.track) {\n        console.log('[PeerConnection] Adding track to stream:', event.track.kind, event.track.id);\n        try { stream.addTrack(event.track); } catch (e) {\n          console.warn('[PeerConnection] Error adding track:', e);\n        }\n      }\n      if (!remoteVideos.has(peerId)) {\n        console.log('[PeerConnection] Adding remote video for peer:', peerId, 'stream tracks:', stream.getTracks().length);\n        addRemoteVideo(peerId, stream);\n      }\n    };\n    pc.onconnectionstatechange = () => {\n      console.log('[PeerConnection] Connection state changed for peer:', peerId, 'â†’', pc.connectionState);\n      if (pc.connectionState === 'connected') {\n        clearReconnection(peerId);\n      } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {\n        if (peersThatLeft.has(peerId)) {\n          removeRemoteVideo(peerId);\n          clearReconnection(peerId);\n        } else {\n          removeRemoteVideo(peerId);\n          attemptReconnection(peerId);\n        }\n      } else if (pc.connectionState === 'closed') {\n        removeRemoteVideo(peerId);\n        clearReconnection(peerId);\n      }\n    };\n    return pc;\n  };\n}\n\nexport function addOrReplaceTrack(pc, track, stream) {\n  const senders = pc.getSenders();\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\n  if (existingSender) {\n    existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\n  } else {\n    try { pc.addTrack(track, stream); } catch (e) {}\n  }\n}\n","import { StateManager } from '../managers/state/StateManager.js';\nimport { NetflixController } from './netflix/NetflixController.js';\nimport { SyncManager } from '../managers/sync/SyncManager.js';\nimport { WebRTCManager } from '../services/webrtc/WebRTCManager.js';\nimport { UIManager } from '../ui/UIManager.js';\nimport { URLSync } from '../managers/url/URLSync.js';\n\nconsole.log('[Content Script] Initializing managers...');\nconst stateManager = new StateManager();\nconst uiManager = new UIManager();\nconst netflixController = new NetflixController();\nconst syncManager = new SyncManager(stateManager, netflixController);\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\nconst urlSync = new URLSync(stateManager);\nconsole.log('[Content Script] Managers initialized');\n\nlet localStream = null;\nlet videoElementMonitor = null;\n\n// Monitor and restore video elements if they get removed during navigation\nfunction startVideoElementMonitoring() {\n  if (videoElementMonitor) return;\n  \n  videoElementMonitor = setInterval(() => {\n    const state = stateManager.getState();\n    if (!state.partyActive) return;\n    \n    // Check if local preview exists\n    if (localStream && !document.getElementById('toperparty-local-preview')) {\n      console.log('[Content Script] Local preview missing, re-attaching');\n      uiManager.attachLocalPreview(localStream);\n    }\n    \n    // Check if remote videos exist\n    const remoteVideos = uiManager.getRemoteVideos();\n    const remoteStreams = uiManager.getRemoteStreams();\n    remoteStreams.forEach((stream, peerId) => {\n      const videoId = 'toperparty-remote-' + peerId;\n      if (!document.getElementById(videoId)) {\n        console.log('[Content Script] Remote video missing for peer:', peerId, 're-adding');\n        const videoManager = webrtcManager.videoManager;\n        if (videoManager && videoManager.add) {\n          videoManager.add(peerId, stream);\n        }\n      }\n    });\n  }, 1000); // Check every second\n  \n  console.log('[Content Script] Started video element monitoring');\n}\n\nfunction stopVideoElementMonitoring() {\n  if (videoElementMonitor) {\n    clearInterval(videoElementMonitor);\n    videoElementMonitor = null;\n    console.log('[Content Script] Stopped video element monitoring');\n  }\n}\n\n(function checkRestorePartyState() {\n  const restorationState = urlSync.getRestorationState();\n  if (restorationState) {\n    console.log('[Content Script] Restoring party state for room:', restorationState.roomId);\n    urlSync.clearState();\n    stateManager.setRestoringFlag(true);\n    \n    setTimeout(function() {\n      console.log('[Content Script] Sending RESTORE_PARTY message');\n      chrome.runtime.sendMessage({ type: 'RESTORE_PARTY', roomId: restorationState.roomId }, (response) => {\n        if (response && response.success) {\n          console.log('[Content Script] Party restoration successful - media stream and sync will be re-initialized');\n        } else {\n          console.error('[Content Script] Party restoration failed:', response ? response.error : 'Unknown error');\n        }\n        setTimeout(function() {\n          stateManager.setRestoringFlag(false);\n        }, 2000);\n      });\n    }, 1000);\n  }\n})();\n\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log('[Content Script] Received message:', request.type);\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\n    console.log('[Content Script] Processing REQUEST_MEDIA_STREAM');\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n      .then(stream => {\n        console.log('[Content Script] Media stream obtained, tracks:', stream.getTracks().length);\n        localStream = stream;\n        console.log('[Content Script] Setting local stream on WebRTC manager');\n        webrtcManager.setLocalStream(stream);\n        webrtcManager.onLocalStreamAvailable(stream);\n        console.log('[Content Script] Attaching local preview to UI');\n        uiManager.attachLocalPreview(stream);\n        console.log('[Content Script] Local preview attached, sending success response');\n        sendResponse({ success: true });\n      })\n      .catch(err => {\n        console.error('[Content Script] Failed to get media stream:', err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true;\n  }\n\n  if (request.type === 'PARTY_STARTED') {\n    console.log('[Content Script] Party started:', request.userId, request.roomId);\n    stateManager.startParty(request.userId, request.roomId);\n    \n    // Teardown existing sync manager if already set up\n    syncManager.teardown();\n    \n    // Setup sync manager (will wait for video element)\n    syncManager.setup().catch(err => {\n      console.error('[Content Script] Failed to setup sync manager:', err);\n    });\n    \n    urlSync.start();\n    startVideoElementMonitoring();\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'PARTY_STOPPED') {\n    console.log('[Content Script] Stopping party');\n    stopVideoElementMonitoring();\n    stateManager.stopParty();\n    syncManager.teardown();\n    urlSync.stop();\n    urlSync.clearState();\n    webrtcManager.clearAll();\n    uiManager.removeLocalPreview();\n    if (localStream) {\n      localStream.getTracks().forEach(t => t.stop());\n      localStream = null;\n    }\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'SIGNAL') {\n    console.log('[Content Script] Handling SIGNAL:', request.message?.type);\n    webrtcManager.handleSignal(request.message);\n  }\n\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\n    console.log('[Content Script] Applying playback control:', request.control, 'at', request.currentTime, 'from', request.fromUserId);\n    syncManager.handlePlaybackControl(request.control, request.currentTime, request.fromUserId);\n  }\n\n  // Passive sync removed - using event-based sync only\n\n  if (request.type === 'APPLY_SEEK') {\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\n  }\n\n  if (request.type === 'APPLY_URL_CHANGE') {\n    console.log('[Content Script] Received URL change request:', request.url, 'from', request.fromUserId);\n    if (!stateManager.restoringPartyState) {\n      console.log('[Content Script] Navigating to:', request.url);\n      // Save state before navigating\n      urlSync.saveState();\n      window.location.href = request.url;\n    } else {\n      console.log('[Content Script] Ignoring URL change - currently restoring party state');\n    }\n  }\n\n  if (request.type === 'HANDLE_REQUEST_SYNC') {\n    syncManager.handleRequestSync(request.fromUserId);\n  }\n\n  if (request.type === 'APPLY_SYNC_RESPONSE') {\n    console.log('[Content Script] Applying sync response from', request.fromUserId, 'URL:', request.url);\n    syncManager.handleSyncResponse(request.currentTime, request.isPlaying, request.fromUserId, request.url);\n  }\n});\n\nwindow.addEventListener('beforeunload', () => {\n  if (stateManager.isActive()) {\n    urlSync.saveState();\n  }\n});\n","export class StateManager {\n  constructor() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n    this.restoringPartyState = false;\n  }\n  startParty(userId, roomId) {\n    this.partyActive = true;\n    this.userId = userId;\n    this.roomId = roomId;\n  }\n  stopParty() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n  }\n  isActive() { return this.partyActive; }\n  getUserId() { return this.userId; }\n  getRoomId() { return this.roomId; }\n  getState() {\n    return { partyActive: this.partyActive, userId: this.userId, roomId: this.roomId, restoringPartyState: this.restoringPartyState };\n  }\n  isInParty() { return !!(this.partyActive && this.userId && this.roomId); }\n  setRestoringFlag(value) { this.restoringPartyState = value; }\n  isExtensionContextValid() {\n    try { return chrome.runtime && chrome.runtime.id; } catch { return false; }\n  }\n  safeSendMessage(message, callback) {\n    if (!this.isExtensionContextValid()) {\n      console.warn('[StateManager] Extension context invalid, cannot send message');\n      return;\n    }\n    console.log('[StateManager] Sending message:', message.type, message);\n    try { \n      chrome.runtime.sendMessage(message, callback); \n    } catch (e) { \n      console.warn('[StateManager] Failed to send message:', e.message); \n    }\n  }\n}\n","export class UIManager {\n  constructor() {\n    this.localPreviewVideo = null;\n    this.remoteVideos = new Map();\n    this.remoteStreams = new Map();\n    this.streamMonitorInterval = null;\n  }\n  getRemoteVideos() { return this.remoteVideos; }\n  getRemoteStreams() { return this.remoteStreams; }\n  setLocalPreviewVideo(video) { this.localPreviewVideo = video; }\n  getLocalPreviewVideo() { return this.localPreviewVideo; }\n  setStreamMonitorInterval(interval) { this.streamMonitorInterval = interval; }\n  getStreamMonitorInterval() { return this.streamMonitorInterval; }\n  clearStreamMonitorInterval() {\n    if (this.streamMonitorInterval) {\n      clearInterval(this.streamMonitorInterval);\n      this.streamMonitorInterval = null;\n    }\n  }\n\n  attachLocalPreview(stream) {\n    console.log('[UIManager] Attaching local preview with stream:', stream);\n    this.removeLocalPreview();\n    \n    const v = document.createElement('video');\n    v.id = 'toperparty-local-preview';\n    v.autoplay = true;\n    v.muted = true; // Always mute local preview to avoid feedback\n    v.playsInline = true;\n    v.style.position = 'fixed';\n    v.style.bottom = '20px';\n    v.style.left = '20px';\n    v.style.width = '240px';\n    v.style.height = '160px';\n    v.style.zIndex = '10001';\n    v.style.border = '2px solid #e50914';\n    v.style.borderRadius = '4px';\n    v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\n\n    try {\n      v.srcObject = stream;\n      console.log('[UIManager] Set srcObject on local preview');\n    } catch (e) {\n      console.warn('[UIManager] srcObject failed, trying createObjectURL:', e);\n      v.src = URL.createObjectURL(stream);\n    }\n\n    document.body.appendChild(v);\n    this.localPreviewVideo = v;\n    console.log('[UIManager] Local preview video appended to body');\n\n    v.play().catch(err => {\n      console.warn('[UIManager] Local preview play() failed:', err);\n    });\n  }\n\n  removeLocalPreview() {\n    if (this.localPreviewVideo) {\n      console.log('[UIManager] Removing local preview video');\n      try {\n        if (this.localPreviewVideo.srcObject) {\n          this.localPreviewVideo.srcObject = null;\n        }\n      } catch (e) {\n        console.warn('[UIManager] Error clearing srcObject:', e);\n      }\n      this.localPreviewVideo.remove();\n      this.localPreviewVideo = null;\n    }\n  }\n\n  clearAll() {\n    this.removeLocalPreview();\n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    this.clearStreamMonitorInterval();\n  }\n}\n","export class NetflixController {\n  constructor() { this.injectAPIBridge(); }\n  injectAPIBridge() {\n    const script = document.createElement('script');\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\n    (document.head || document.documentElement).appendChild(script);\n    script.onload = function() { script.remove(); };\n  }\n  _sendCommand(command, args = []) {\n    return new Promise(function(resolve) {\n      const handler = function(e) {\n        if (e.detail.command === command) {\n          document.removeEventListener('__toperparty_response', handler);\n          resolve(e.detail.result);\n        }\n      };\n      document.addEventListener('__toperparty_response', handler);\n      setTimeout(function() { resolve(null); }, 1000);\n      document.dispatchEvent(new CustomEvent('__toperparty_command', { detail: { command, args } }));\n    });\n  }\n  play() { return this._sendCommand('play'); }\n  pause() { return this._sendCommand('pause'); }\n  seek(timeMs) { return this._sendCommand('seek', [timeMs]); }\n  getCurrentTime() { return this._sendCommand('getCurrentTime'); }\n  isPaused() { return this._sendCommand('isPaused'); }\n  getVideoElement() { return document.querySelector('video'); }\n}\n","export function createRemoteHandlers({ state, netflix, lock, isInitializedRef }) {\n  async function applyRemote(actionName, durationMs, actionFn) {\n    lock.set(durationMs);\n    try { await actionFn(); } catch (err) {\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\n    }\n  }\n\n  return {\n    async handleRequestSync(fromUserId) {\n      if (!isInitializedRef.get()) {\n        console.log('[SyncManager] Not yet initialized, ignoring sync request');\n        return;\n      }\n      \n      const currentUrl = window.location.href;\n      const isOnWatchPage = window.location.pathname.startsWith('/watch');\n      \n      // If we're on browse page, don't send sync response\n      if (!isOnWatchPage) {\n        console.log('[SyncManager] On browse page, not sending sync response');\n        return;\n      }\n      \n      try {\n        const currentTime = await netflix.getCurrentTime();\n        const isPaused = await netflix.isPaused();\n        \n        if (currentTime == null) {\n          console.log('[SyncManager] Invalid playback state, ignoring sync request');\n          return;\n        }\n        \n        const currentTimeSeconds = currentTime / 1000;\n        console.log('[SyncManager] Sending SYNC_RESPONSE to', fromUserId, 'at', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing', 'URL:', currentUrl);\n        \n        state.safeSendMessage({\n          type: 'SYNC_RESPONSE',\n          targetUserId: fromUserId,\n          currentTime: currentTimeSeconds,\n          isPlaying: !isPaused,\n          url: currentUrl\n        });\n      } catch (e) { console.error('[SyncManager] Error handling sync request:', e); }\n    },\n    async handleSyncResponse(currentTime, isPlaying, fromUserId, url) {\n      if (isInitializedRef.get()) {\n        console.log('[SyncManager] Already initialized, ignoring late SYNC_RESPONSE');\n        return;\n      }\n      \n      if (currentTime == null || typeof currentTime !== 'number' || currentTime < 0) {\n        console.warn('[SyncManager] Invalid SYNC_RESPONSE - bad currentTime:', currentTime);\n        return;\n      }\n      \n      console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'URL:', url);\n      \n      // Check if we need to navigate to a different URL\n      const currentUrl = window.location.href;\n      const isOnBrowse = window.location.pathname.startsWith('/browse');\n      const otherIsOnWatch = url && (new URL(url).pathname.startsWith('/watch'));\n      \n      // If we're on browse and they're on /watch, always navigate to their page\n      if (isOnBrowse && otherIsOnWatch) {\n        console.log('[SyncManager] On browse page, other user on /watch - navigating to their show');\n        sessionStorage.setItem('toperparty_pending_sync', JSON.stringify({\n          currentTime,\n          isPlaying,\n          timestamp: Date.now()\n        }));\n        window.location.href = url;\n        return;\n      }\n      \n      // Regular URL mismatch handling\n      if (url && url !== currentUrl) {\n        console.log('[SyncManager] URL mismatch - navigating from', currentUrl, 'to', url);\n        // Store the sync state to apply after navigation\n        sessionStorage.setItem('toperparty_pending_sync', JSON.stringify({\n          currentTime,\n          isPlaying,\n          timestamp: Date.now()\n        }));\n        // Navigate to the correct URL\n        window.location.href = url;\n        return;\n      }\n      \n      isInitializedRef.set(true);\n      \n      await applyRemote('initial-sync', 1500, async () => {\n        await netflix.seek(currentTime * 1000);\n        const localPaused = await netflix.isPaused();\n        if (isPlaying && localPaused) {\n          await netflix.play();\n        } else if (!isPlaying && !localPaused) {\n          await netflix.pause();\n        }\n      });\n    },\n    async handlePlaybackControl(control, currentTime, fromUserId) {\n      console.log('[SyncManager] Remote', control.toUpperCase(), 'at', currentTime, 'from', fromUserId);\n      \n      await applyRemote(control, 1000, async () => {\n        // Seek to the exact position first\n        if (currentTime != null) {\n          const currentTimeMs = currentTime * 1000;\n          await netflix.seek(currentTimeMs);\n          console.log('[SyncManager] Seeked to', currentTime.toFixed(2) + 's before', control);\n        }\n        \n        // Then apply play/pause\n        if (control === 'play') {\n          await netflix.play();\n        } else {\n          await netflix.pause();\n        }\n      });\n    },\n    async handleSeek(currentTime, isPlaying, fromUserId) {\n      console.log('[SyncManager] Remote SEEK to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'from', fromUserId);\n      \n      await applyRemote('seek', 1200, async () => {\n        await netflix.seek(currentTime * 1000);\n        const isPaused = await netflix.isPaused();\n        \n        if (isPlaying && isPaused) {\n          await netflix.play();\n        } else if (!isPlaying && !isPaused) {\n          await netflix.pause();\n        }\n      });\n    }\n  };\n}\n","import { createSignalingHandlers } from './signaling.js';\nimport { createPeerConnectionFactory, addOrReplaceTrack } from './peerConnection.js';\nimport { createReconnectionManager } from './reconnect.js';\nimport { createRemoteVideoManager } from './ui.js';\n\nexport class WebRTCManager {\n  constructor(stateManager, uiManager) {\n    this.stateManager = stateManager;\n    this.uiManager = uiManager;\n    this.peerConnections = new Map();\n    this.remoteStreams = this.uiManager.getRemoteStreams();\n    this.remoteVideos = this.uiManager.getRemoteVideos();\n    this.peersThatLeft = new Set();\n    this.localStream = null;\n\n    const videoManager = createRemoteVideoManager(this.remoteVideos);\n    \n    // Create a placeholder object for circular dependency resolution\n    const reconnectionManager = {};\n    \n    const createPeer = createPeerConnectionFactory({\n      stateManager: this.stateManager,\n      sendSignal: (msg) => this._sendSignal(msg),\n      remoteStreams: this.remoteStreams,\n      remoteVideos: this.remoteVideos,\n      addRemoteVideo: videoManager.add,\n      attemptReconnection: (peerId) => reconnectionManager.attempt(peerId),\n      clearReconnection: (peerId) => reconnectionManager.clear(peerId),\n      removeRemoteVideo: (peerId) => {\n        videoManager.remove(peerId);\n        this.remoteStreams.delete(peerId);\n      },\n      peersThatLeft: this.peersThatLeft\n    });\n\n    // Now create the actual reconnection manager with createPeer available\n    Object.assign(reconnectionManager, createReconnectionManager({\n      stateManager: this.stateManager,\n      peerConnections: this.peerConnections,\n      peersThatLeft: this.peersThatLeft,\n      localStream: () => this.localStream,\n      createPeer: createPeer,\n      sendSignal: (msg) => this._sendSignal(msg),\n      addOrReplaceTrack\n    }));\n\n    this.reconnectionManager = reconnectionManager;\n    this.createPeer = createPeer;\n    this.videoManager = videoManager;\n\n    this.signalingHandlers = createSignalingHandlers({\n      getState: () => this.stateManager.getState(),\n      peerConnections: this.peerConnections,\n      peersThatLeft: this.peersThatLeft,\n      getLocalStream: () => this.localStream,\n      createPeer,\n      sendSignal: (msg) => this._sendSignal(msg),\n      addOrReplaceTrack,\n      clearReconnection: reconnectionManager.clear,\n      removeRemoteVideo: (peerId) => {\n        videoManager.remove(peerId);\n        this.remoteStreams.delete(peerId);\n      }\n    });\n  }\n\n  setLocalStream(stream) { this.localStream = stream; }\n  getLocalStream() { return this.localStream; }\n  \n  onLocalStreamAvailable(stream) {\n    this.localStream = stream;\n    this.peerConnections.forEach((pc) => {\n      try {\n        stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\n      } catch (e) {}\n    });\n  }\n\n  async handleSignal(message) {\n    console.log('[WebRTCManager] handleSignal called with:', message);\n    if (!message || !message.type) {\n      console.warn('[WebRTCManager] Invalid message:', message);\n      return;\n    }\n    const type = message.type;\n    const from = message.userId || message.from;\n    const to = message.to;\n    const state = this.stateManager.getState();\n    console.log('[WebRTCManager] Processing signal type:', type, 'from:', from, 'to:', to, 'myId:', state.userId);\n    \n    if (to && to !== state.userId) {\n      console.log('[WebRTCManager] Ignoring message not meant for me');\n      return;\n    }\n\n    if (type === 'JOIN' && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleJoin');\n      await this.signalingHandlers.handleJoin(from);\n    } else if (type === 'OFFER' && message.offer && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleOffer');\n      await this.signalingHandlers.handleOffer(from, message.offer);\n    } else if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleAnswer');\n      await this.signalingHandlers.handleAnswer(from, message.answer);\n    } else if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleIceCandidate');\n      await this.signalingHandlers.handleIceCandidate(from, message.candidate);\n    } else if (type === 'LEAVE' && from) {\n      console.log('[WebRTCManager] Dispatching to handleLeave');\n      this.signalingHandlers.handleLeave(from);\n    } else {\n      console.log('[WebRTCManager] Signal not handled - type:', type, 'from:', from, 'conditions not met');\n    }\n  }\n\n  attemptReconnection(peerId) {\n    return this.reconnectionManager.attempt(peerId);\n  }\n\n  _sendSignal(message) {\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\n  }\n\n  clearAll() {\n    this.peerConnections.forEach((pc) => {\n      try { pc.close(); } catch (e) {}\n    });\n    this.peerConnections.clear();\n    this.peersThatLeft.clear();\n    this.remoteVideos.forEach((v) => {\n      try { if (v.srcObject) v.srcObject = null; } catch (e) {}\n      v.remove();\n    });\n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n  }\n}\n","export function createRemoteVideoManager(remoteVideos) {\n  function add(peerId, stream) {\n    console.log('[RemoteVideoManager] Adding remote video for peer:', peerId, 'stream:', stream, 'tracks:', stream.getTracks());\n    remove(peerId);\n    const v = document.createElement('video');\n    v.id = 'toperparty-remote-' + peerId;\n    v.autoplay = true;\n    v.playsInline = true;\n    v.muted = true;\n    v.style.position = 'fixed';\n    v.style.bottom = '20px';\n    v.style.right = (20 + (remoteVideos.size * 180)) + 'px';\n    v.style.width = '240px';\n    v.style.height = '160px';\n    v.style.zIndex = 10001;\n    v.style.border = '2px solid #00aaff';\n    v.style.borderRadius = '4px';\n    console.log('[RemoteVideoManager] Created video element:', v.id, 'at position:', v.style.right);\n    try { \n      v.srcObject = stream;\n      console.log('[RemoteVideoManager] Set srcObject successfully');\n    } catch (e) { \n      console.warn('[RemoteVideoManager] srcObject failed, trying createObjectURL:', e);\n      v.src = URL.createObjectURL(stream); \n    }\n    document.body.appendChild(v);\n    console.log('[RemoteVideoManager] Appended video to body');\n    remoteVideos.set(peerId, v);\n    try {\n      v.play().then(() => {\n        console.log('[RemoteVideoManager] Video playing, unmuting');\n        v.muted = false;\n        v.volume = 1.0;\n      }).catch((e) => { \n        console.warn('[RemoteVideoManager] Play failed:', e);\n        v.muted = false; \n      });\n    } catch (e) {\n      console.warn('[RemoteVideoManager] Error calling play:', e);\n    }\n  }\n  \n  function remove(peerId) {\n    console.log('[RemoteVideoManager] Removing remote video for peer:', peerId);\n    const v = remoteVideos.get(peerId);\n    if (v) {\n      try { if (v.srcObject) v.srcObject = null; } catch (e) {}\n      v.remove();\n      remoteVideos.delete(peerId);\n    }\n  }\n  \n  return { add, remove };\n}\n","export function createReconnectionManager({ stateManager, peerConnections, peersThatLeft, localStream, createPeer, sendSignal, addOrReplaceTrack }) {\n  const attempts = new Map();\n  const timeouts = new Map();\n  \n  function clear(peerId) {\n    attempts.delete(peerId);\n    const handle = timeouts.get(peerId);\n    if (handle) {\n      clearTimeout(handle);\n      timeouts.delete(peerId);\n    }\n  }\n  \n  async function attempt(peerId) {\n    if (!stateManager.isInParty()) return;\n    if (peersThatLeft.has(peerId)) {\n      clear(peerId);\n      return;\n    }\n    const count = attempts.get(peerId) || 0;\n    const maxAttempts = 5;\n    const backoffDelay = Math.min(1000 * Math.pow(2, count), 30000);\n    if (count >= maxAttempts) {\n      clear(peerId);\n      return;\n    }\n    attempts.set(peerId, count + 1);\n    const existing = timeouts.get(peerId);\n    if (existing) clearTimeout(existing);\n    const handle = setTimeout(async () => {\n      const oldPc = peerConnections.get(peerId);\n      if (oldPc) {\n        try { oldPc.close(); } catch (e) {}\n        peerConnections.delete(peerId);\n      }\n      try {\n        const pc = createPeer(peerId);\n        peerConnections.set(peerId, pc);\n        const stream = typeof localStream === 'function' ? localStream() : localStream;\n        if (stream) {\n          stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\n        }\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        const state = stateManager.getState();\n        sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\n      } catch (err) {\n        console.error('[WebRTCManager] Reconnection failed:', err);\n        attempt(peerId);\n      }\n    }, backoffDelay);\n    timeouts.set(peerId, handle);\n  }\n  \n  return { attempt, clear };\n}\n","export function createSignalingHandlers({ getState, peerConnections, peersThatLeft, getLocalStream, createPeer, sendSignal, addOrReplaceTrack, clearReconnection, removeRemoteVideo }) {\n  return {\n    async handleJoin(from) {\n      console.log('[Signaling] Handling JOIN from', from);\n      const state = getState();\n      if (from === state.userId) {\n        console.log('[Signaling] Ignoring JOIN from self');\n        return;\n      }\n      peersThatLeft.delete(from);\n      if (peerConnections.has(from)) {\n        console.log('[Signaling] Already have peer connection for', from);\n        return;\n      }\n      try {\n        console.log('[Signaling] Creating peer connection for', from);\n        const pc = createPeer(from);\n        peerConnections.set(from, pc);\n        const stream = getLocalStream();\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\n        if (stream) {\n          stream.getTracks().forEach(t => {\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\n            addOrReplaceTrack(pc, t, stream);\n          });\n        } else {\n          console.warn('[Signaling] No local stream available when handling JOIN');\n        }\n        console.log('[Signaling] Creating and sending OFFER to', from);\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\n      } catch (err) {\n        console.error('[Signaling] Error handling JOIN:', err);\n        peerConnections.delete(from);\n      }\n    },\n    async handleOffer(from, offer) {\n      console.log('[Signaling] Handling OFFER from', from);\n      const state = getState();\n      if (from === state.userId) {\n        console.log('[Signaling] Ignoring OFFER from self');\n        return;\n      }\n      let pc = peerConnections.get(from);\n      if (pc && pc.signalingState !== 'closed') {\n        console.log('[Signaling] Closing existing peer connection');\n        try { pc.close(); } catch (e) {}\n        peerConnections.delete(from);\n        pc = null;\n      }\n      if (!pc) {\n        console.log('[Signaling] Creating new peer connection for', from);\n        pc = createPeer(from);\n        peerConnections.set(from, pc);\n      }\n      try {\n        console.log('[Signaling] Setting remote description');\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\n        const stream = getLocalStream();\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\n        if (stream) {\n          stream.getTracks().forEach(t => {\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\n            addOrReplaceTrack(pc, t, stream);\n          });\n        } else {\n          console.warn('[Signaling] No local stream available when handling OFFER');\n        }\n        console.log('[Signaling] Creating and sending ANSWER to', from);\n        const answer = await pc.createAnswer();\n        await pc.setLocalDescription(answer);\n        sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\n      } catch (err) {\n        console.error('[Signaling] Error handling offer:', err);\n        peerConnections.delete(from);\n        try { pc.close(); } catch (e) {}\n      }\n    },\n    async handleAnswer(from, answer) {\n      console.log('[Signaling] Handling ANSWER from', from);\n      const pc = peerConnections.get(from);\n      if (pc && pc.signalingState === 'have-local-offer') {\n        console.log('[Signaling] Setting remote description from ANSWER');\n        try {\n          await pc.setRemoteDescription(new RTCSessionDescription(answer));\n          console.log('[Signaling] Remote description set successfully');\n        } catch (err) {\n          console.error('[Signaling] Error handling answer:', err);\n        }\n      } else {\n        console.warn('[Signaling] Cannot handle ANSWER - pc:', !!pc, 'signalingState:', pc?.signalingState);\n      }\n    },\n    async handleIceCandidate(from, candidate) {\n      console.log('[Signaling] Handling ICE_CANDIDATE from', from);\n      const pc = peerConnections.get(from);\n      if (pc) {\n        try {\n          await pc.addIceCandidate(new RTCIceCandidate(candidate));\n          console.log('[Signaling] ICE candidate added successfully');\n        } catch (err) {\n          console.warn('[Signaling] Error adding ICE candidate', err);\n        }\n      } else {\n        console.warn('[Signaling] No peer connection found for ICE candidate from', from);\n      }\n    },\n    handleLeave(from) {\n      console.log('[Signaling] Handling LEAVE from', from);\n      peersThatLeft.add(from);\n      const pc = peerConnections.get(from);\n      if (pc) {\n        try { pc.close(); } catch (e) {}\n        peerConnections.delete(from);\n      }\n      clearReconnection(from);\n      removeRemoteVideo(from);\n    }\n  };\n}\n","export class URLSync {\n  constructor(stateManager) {\n    this.stateManager = stateManager;\n    this.urlMonitorInterval = null;\n    this.lastUrl = null;\n  }\n  \n  start() { \n    this.lastUrl = window.location.href;\n    console.log('[URLSync] Starting URL monitoring, current URL:', this.lastUrl);\n    \n    // Clear any existing interval\n    if (this.urlMonitorInterval) {\n      clearInterval(this.urlMonitorInterval);\n    }\n    \n    // Monitor for URL changes every 500ms\n    this.urlMonitorInterval = setInterval(() => {\n      const currentUrl = window.location.href;\n      if (currentUrl !== this.lastUrl) {\n        console.log('[URLSync] URL changed from', this.lastUrl, 'to', currentUrl);\n        this.lastUrl = currentUrl;\n        \n        // Broadcast URL change to other clients\n        const state = this.stateManager.getState();\n        if (state.partyActive) {\n          console.log('[URLSync] Broadcasting URL change to party');\n          this.stateManager.safeSendMessage({ \n            type: 'URL_CHANGE', \n            url: currentUrl \n          });\n        }\n      }\n    }, 500);\n  }\n  \n  stop() {\n    console.log('[URLSync] Stopping URL monitoring');\n    if (this.urlMonitorInterval) { \n      clearInterval(this.urlMonitorInterval); \n      this.urlMonitorInterval = null; \n    }\n    this.lastUrl = null;\n  }\n  saveState() {\n    const state = this.stateManager.getState();\n    if (!state.partyActive) return;\n    const existing = this.getRestorationState() || {};\n    const payload = {\n      roomId: state.roomId,\n      currentTime: existing.currentTime || null,\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\n      timestamp: Date.now()\n    };\n    sessionStorage.setItem('toperparty_restore', JSON.stringify(payload));\n  }\n  clearState() { sessionStorage.removeItem('toperparty_restore'); }\n  getRestorationState() {\n    const stored = sessionStorage.getItem('toperparty_restore');\n    if (!stored) return null;\n    try {\n      const state = JSON.parse(stored);\n      if (Date.now() - state.timestamp < 30000) { return state; }\n    } catch (e) { console.error('[toperparty] Failed to parse restoration state:', e); }\n    return null;\n  }\n}\n"],"names":["SyncLock","constructor","this","suppressLocalUntil","set","durationMs","Date","now","isActive","attachPlaybackListeners","video","state","isInitializedRef","lock","onPlay","onPause","onSeek","handlePlay","get","console","log","handlePause","handleSeeked","addEventListener","MutableRef","value","v","addOrReplaceTrack","pc","track","stream","existingSender","getSenders","find","s","kind","replaceTrack","catch","e","warn","addTrack","stateManager","partyActive","userId","roomId","restoringPartyState","startParty","stopParty","getUserId","getRoomId","getState","isInParty","setRestoringFlag","isExtensionContextValid","chrome","runtime","id","safeSendMessage","message","callback","type","sendMessage","uiManager","localPreviewVideo","remoteVideos","Map","remoteStreams","streamMonitorInterval","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","clearInterval","attachLocalPreview","removeLocalPreview","document","createElement","autoplay","muted","playsInline","style","position","bottom","left","width","height","zIndex","border","borderRadius","transform","srcObject","src","URL","createObjectURL","body","appendChild","play","err","remove","clearAll","clear","netflixController","injectAPIBridge","script","getURL","head","documentElement","onload","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","setTimeout","dispatchEvent","CustomEvent","pause","seek","timeMs","getCurrentTime","isPaused","getVideoElement","querySelector","syncManager","netflix","listeners","remote","async","applyRemote","actionName","actionFn","error","handleRequestSync","fromUserId","currentUrl","window","location","href","pathname","startsWith","currentTime","currentTimeSeconds","toFixed","targetUserId","isPlaying","url","handleSyncResponse","isOnBrowse","otherIsOnWatch","sessionStorage","setItem","JSON","stringify","timestamp","localPaused","handlePlaybackControl","control","toUpperCase","currentTimeMs","handleSeek","createRemoteHandlers","setup","waitForVideo","pendingSyncStr","getItem","pendingSync","parse","removeItem","vid","broadcastPlay","broadcastPause","broadcastSeek","teardown","reject","timeout","Error","check","clearTimeout","isOnWatchPage","paused","webrtcManager","peerConnections","peersThatLeft","Set","localStream","videoManager","peerId","delete","add","getTracks","right","size","then","volume","createRemoteVideoManager","reconnectionManager","createPeer","sendSignal","addRemoteVideo","attemptReconnection","clearReconnection","removeRemoteVideo","RTCPeerConnection","iceServers","urls","onicecandidate","event","candidate","from","to","ontrack","streams","MediaStream","has","length","onconnectionstatechange","connectionState","createPeerConnectionFactory","msg","_sendSignal","attempt","Object","assign","attempts","timeouts","handle","count","backoffDelay","Math","min","pow","existing","oldPc","close","forEach","t","offer","createOffer","setLocalDescription","localDescription","createReconnectionManager","signalingHandlers","getLocalStream","handleJoin","handleOffer","signalingState","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleAnswer","handleIceCandidate","addIceCandidate","RTCIceCandidate","handleLeave","createSignalingHandlers","setLocalStream","onLocalStreamAvailable","handleSignal","stop","urlSync","urlMonitorInterval","lastUrl","start","setInterval","saveState","getRestorationState","payload","clearState","stored","videoElementMonitor","restorationState","response","success","onMessage","addListener","request","sender","sendResponse","navigator","mediaDevices","getUserMedia","audio","getElementById","videoId"],"ignoreList":[],"sourceRoot":""}