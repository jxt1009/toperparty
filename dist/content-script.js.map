{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://toperparty/./chrome-extension/src/managers/sync/lock.js","webpack://toperparty/./chrome-extension/src/managers/sync/SyncManager.js","webpack://toperparty/./chrome-extension/src/services/webrtc/peerConnection.js","webpack://toperparty/./chrome-extension/src/content/main.js","webpack://toperparty/./chrome-extension/src/managers/state/StateManager.js","webpack://toperparty/./chrome-extension/src/ui/UIManager.js","webpack://toperparty/./chrome-extension/src/content/netflix/NetflixController.js","webpack://toperparty/./chrome-extension/src/managers/sync/remoteHandlers.js","webpack://toperparty/./chrome-extension/src/managers/sync/eventListeners.js","webpack://toperparty/./chrome-extension/src/services/webrtc/WebRTCManager.js","webpack://toperparty/./chrome-extension/src/services/webrtc/ui.js","webpack://toperparty/./chrome-extension/src/services/webrtc/reconnect.js","webpack://toperparty/./chrome-extension/src/services/webrtc/signaling.js","webpack://toperparty/./chrome-extension/src/managers/url/URLSync.js"],"sourcesContent":["export class SyncLock {\n  constructor() {\n    this.suppressLocalUntil = 0;\n  }\n  set(durationMs) {\n    this.suppressLocalUntil = Date.now() + durationMs;\n  }\n  isActive() {\n    return Date.now() < this.suppressLocalUntil;\n  }\n}\n","import { SyncLock } from './lock.js';\nimport { attachPlaybackListeners } from './eventListeners.js';\nimport { createRemoteHandlers } from './remoteHandlers.js';\n\nclass MutableRef {\n  constructor(value) { this.value = value; }\n  get() { return this.value; }\n  set(v) { this.value = v; }\n}\n\nexport class SyncManager {\n  constructor(stateManager, netflixController) {\n    this.state = stateManager;\n    this.netflix = netflixController;\n    this.lock = new SyncLock();\n    this.isInitializedRef = new MutableRef(false);\n    this.listeners = null;\n\n    this.remote = createRemoteHandlers({\n      state: this.state,\n      netflix: this.netflix,\n      lock: this.lock,\n      isInitializedRef: this.isInitializedRef,\n    });\n  }\n\n  async setup() {\n    try {\n      const video = await this.waitForVideo();\n      if (!video) { console.warn('[SyncManager] Netflix video element not found'); return; }\n      \n      console.log('[SyncManager] Setting up event listeners');\n      this.isInitializedRef.set(false);\n      \n      // Request initial sync from other clients\n      this.state.safeSendMessage({ type: 'REQUEST_SYNC' });\n      \n      // If no response after 2 seconds, consider ourselves initialized\n      setTimeout(() => {\n        if (!this.isInitializedRef.get()) {\n          console.log('[SyncManager] No sync response received, marking as initialized');\n          this.isInitializedRef.set(true);\n        }\n      }, 2000);\n      \n      const listeners = attachPlaybackListeners({\n        video,\n        state: this.state,\n        isInitializedRef: this.isInitializedRef,\n        lock: this.lock,\n        onPlay: (vid) => this.broadcastPlay(vid),\n        onPause: (vid) => this.broadcastPause(vid),\n        onSeek: (vid) => this.broadcastSeek(vid)\n      });\n      this.listeners = listeners;\n    } catch (err) { console.error('[SyncManager] Error setting up playback sync:', err); }\n  }\n\n  teardown() {\n    if (this.listeners && this.listeners.video) {\n      const { video, handlePlay, handlePause, handleSeeked } = this.listeners;\n      try {\n        video.removeEventListener('play', handlePlay);\n        video.removeEventListener('pause', handlePause);\n        video.removeEventListener('seeked', handleSeeked);\n      } catch (e) { console.warn('[SyncManager] Error removing listeners:', e); }\n      this.listeners = null;\n    }\n  }\n\n  waitForVideo() {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\n      const check = () => {\n        const video = this.netflix.getVideoElement();\n        if (video) { clearTimeout(timeout); resolve(video); }\n        else { setTimeout(check, 100); }\n      };\n      check();\n    });\n  }\n\n  broadcastPlay(video) {\n    console.log('[SyncManager] Broadcasting PLAY event');\n    this.state.safeSendMessage({ \n      type: 'PLAY_PAUSE', \n      control: 'play', \n      currentTime: video.currentTime \n    });\n  }\n\n  broadcastPause(video) {\n    console.log('[SyncManager] Broadcasting PAUSE event');\n    this.state.safeSendMessage({ \n      type: 'PLAY_PAUSE', \n      control: 'pause', \n      currentTime: video.currentTime \n    });\n  }\n\n  broadcastSeek(video) {\n    console.log('[SyncManager] Broadcasting SEEK event at', video.currentTime);\n    this.state.safeSendMessage({ \n      type: 'SEEK', \n      currentTime: video.currentTime, \n      isPlaying: !video.paused \n    });\n  }\n\n  // Remote event handlers\n  handleRequestSync(fromUserId) { return this.remote.handleRequestSync(fromUserId); }\n  handleSyncResponse(currentTime, isPlaying, fromUserId) { return this.remote.handleSyncResponse(currentTime, isPlaying, fromUserId); }\n  handlePlaybackControl(control, currentTime, fromUserId) { return this.remote.handlePlaybackControl(control, currentTime, fromUserId); }\n  handleSeek(currentTime, isPlaying, fromUserId) { return this.remote.handleSeek(currentTime, isPlaying, fromUserId); }\n}\n","export function createPeerConnectionFactory({ stateManager, sendSignal, remoteStreams, remoteVideos, addRemoteVideo, attemptReconnection, clearReconnection, removeRemoteVideo, peersThatLeft }) {\n  return function createPeerConnection(peerId) {\n    const state = stateManager.getState();\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: ['stun:stun.l.google.com:19302'] },\n        { urls: ['stun:stun1.l.google.com:19302'] }\n      ]\n    });\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('[PeerConnection] ICE candidate for peer:', peerId, event.candidate);\n        sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\n      }\n    };\n    pc.ontrack = (event) => {\n      console.log('[PeerConnection] ontrack fired for peer:', peerId, 'track:', event.track, 'streams:', event.streams);\n      let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\n      if (!stream) {\n        console.log('[PeerConnection] Creating new MediaStream for peer:', peerId);\n        stream = new MediaStream();\n        remoteStreams.set(peerId, stream);\n      }\n      if (event.track) {\n        console.log('[PeerConnection] Adding track to stream:', event.track.kind, event.track.id);\n        try { stream.addTrack(event.track); } catch (e) {\n          console.warn('[PeerConnection] Error adding track:', e);\n        }\n      }\n      if (!remoteVideos.has(peerId)) {\n        console.log('[PeerConnection] Adding remote video for peer:', peerId, 'stream tracks:', stream.getTracks().length);\n        addRemoteVideo(peerId, stream);\n      }\n    };\n    pc.onconnectionstatechange = () => {\n      console.log('[PeerConnection] Connection state changed for peer:', peerId, 'â†’', pc.connectionState);\n      if (pc.connectionState === 'connected') {\n        clearReconnection(peerId);\n      } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {\n        if (peersThatLeft.has(peerId)) {\n          removeRemoteVideo(peerId);\n          clearReconnection(peerId);\n        } else {\n          removeRemoteVideo(peerId);\n          attemptReconnection(peerId);\n        }\n      } else if (pc.connectionState === 'closed') {\n        removeRemoteVideo(peerId);\n        clearReconnection(peerId);\n      }\n    };\n    return pc;\n  };\n}\n\nexport function addOrReplaceTrack(pc, track, stream) {\n  const senders = pc.getSenders();\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\n  if (existingSender) {\n    existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\n  } else {\n    try { pc.addTrack(track, stream); } catch (e) {}\n  }\n}\n","import { StateManager } from '../managers/state/StateManager.js';\nimport { NetflixController } from './netflix/NetflixController.js';\nimport { SyncManager } from '../managers/sync/SyncManager.js';\nimport { WebRTCManager } from '../services/webrtc/WebRTCManager.js';\nimport { UIManager } from '../ui/UIManager.js';\nimport { URLSync } from '../managers/url/URLSync.js';\n\nconsole.log('[Content Script] Initializing managers...');\nconst stateManager = new StateManager();\nconst uiManager = new UIManager();\nconst netflixController = new NetflixController();\nconst syncManager = new SyncManager(stateManager, netflixController);\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\nconst urlSync = new URLSync(stateManager);\nconsole.log('[Content Script] Managers initialized');\n\nlet localStream = null;\nlet videoElementMonitor = null;\n\n// Monitor and restore video elements if they get removed during navigation\nfunction startVideoElementMonitoring() {\n  if (videoElementMonitor) return;\n  \n  videoElementMonitor = setInterval(() => {\n    const state = stateManager.getState();\n    if (!state.partyActive) return;\n    \n    // Check if local preview exists\n    if (localStream && !document.getElementById('toperparty-local-preview')) {\n      console.log('[Content Script] Local preview missing, re-attaching');\n      uiManager.attachLocalPreview(localStream);\n    }\n    \n    // Check if remote videos exist\n    const remoteVideos = uiManager.getRemoteVideos();\n    const remoteStreams = uiManager.getRemoteStreams();\n    remoteStreams.forEach((stream, peerId) => {\n      const videoId = 'toperparty-remote-' + peerId;\n      if (!document.getElementById(videoId)) {\n        console.log('[Content Script] Remote video missing for peer:', peerId, 're-adding');\n        const videoManager = webrtcManager.videoManager;\n        if (videoManager && videoManager.add) {\n          videoManager.add(peerId, stream);\n        }\n      }\n    });\n  }, 1000); // Check every second\n  \n  console.log('[Content Script] Started video element monitoring');\n}\n\nfunction stopVideoElementMonitoring() {\n  if (videoElementMonitor) {\n    clearInterval(videoElementMonitor);\n    videoElementMonitor = null;\n    console.log('[Content Script] Stopped video element monitoring');\n  }\n}\n\n(function checkRestorePartyState() {\n  const restorationState = urlSync.getRestorationState();\n  if (restorationState) {\n    urlSync.clearState();\n    stateManager.setRestoringFlag(true);\n    setTimeout(function() {\n      chrome.runtime.sendMessage({ type: 'RESTORE_PARTY', roomId: restorationState.roomId });\n      setTimeout(function() {\n        stateManager.setRestoringFlag(false);\n      }, 2000);\n    }, 1000);\n  }\n})();\n\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log('[Content Script] Received message:', request.type);\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\n    console.log('[Content Script] Processing REQUEST_MEDIA_STREAM');\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n      .then(stream => {\n        console.log('[Content Script] Media stream obtained, tracks:', stream.getTracks().length);\n        localStream = stream;\n        console.log('[Content Script] Setting local stream on WebRTC manager');\n        webrtcManager.setLocalStream(stream);\n        webrtcManager.onLocalStreamAvailable(stream);\n        console.log('[Content Script] Attaching local preview to UI');\n        uiManager.attachLocalPreview(stream);\n        console.log('[Content Script] Local preview attached, sending success response');\n        sendResponse({ success: true });\n      })\n      .catch(err => {\n        console.error('[Content Script] Failed to get media stream:', err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true;\n  }\n\n  if (request.type === 'PARTY_STARTED') {\n    console.log('[Content Script] Party started:', request.userId, request.roomId);\n    stateManager.startParty(request.userId, request.roomId);\n    syncManager.setup();\n    urlSync.start();\n    startVideoElementMonitoring();\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'PARTY_STOPPED') {\n    console.log('[Content Script] Stopping party');\n    stopVideoElementMonitoring();\n    stateManager.stopParty();\n    syncManager.teardown();\n    urlSync.stop();\n    urlSync.clearState();\n    webrtcManager.clearAll();\n    uiManager.removeLocalPreview();\n    if (localStream) {\n      localStream.getTracks().forEach(t => t.stop());\n      localStream = null;\n    }\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'SIGNAL') {\n    console.log('[Content Script] Handling SIGNAL:', request.message?.type);\n    webrtcManager.handleSignal(request.message);\n  }\n\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\n    console.log('[Content Script] Applying playback control:', request.control, 'at', request.currentTime, 'from', request.fromUserId);\n    syncManager.handlePlaybackControl(request.control, request.currentTime, request.fromUserId);\n  }\n\n  // Passive sync removed - using event-based sync only\n\n  if (request.type === 'APPLY_SEEK') {\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\n  }\n\n  if (request.type === 'APPLY_URL_CHANGE') {\n    if (!stateManager.restoringPartyState) {\n      window.location.href = request.url;\n    }\n  }\n\n  if (request.type === 'HANDLE_REQUEST_SYNC') {\n    syncManager.handleRequestSync(request.fromUserId);\n  }\n\n  if (request.type === 'APPLY_SYNC_RESPONSE') {\n    syncManager.handleSyncResponse(request.currentTime, request.isPlaying, request.fromUserId);\n  }\n});\n\nwindow.addEventListener('beforeunload', () => {\n  if (stateManager.isActive()) {\n    urlSync.saveState();\n  }\n});\n","export class StateManager {\n  constructor() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n    this.restoringPartyState = false;\n  }\n  startParty(userId, roomId) {\n    this.partyActive = true;\n    this.userId = userId;\n    this.roomId = roomId;\n  }\n  stopParty() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n  }\n  isActive() { return this.partyActive; }\n  getUserId() { return this.userId; }\n  getRoomId() { return this.roomId; }\n  getState() {\n    return { partyActive: this.partyActive, userId: this.userId, roomId: this.roomId, restoringPartyState: this.restoringPartyState };\n  }\n  isInParty() { return !!(this.partyActive && this.userId && this.roomId); }\n  setRestoringFlag(value) { this.restoringPartyState = value; }\n  isExtensionContextValid() {\n    try { return chrome.runtime && chrome.runtime.id; } catch { return false; }\n  }\n  safeSendMessage(message, callback) {\n    if (!this.isExtensionContextValid()) {\n      console.warn('[StateManager] Extension context invalid, cannot send message');\n      return;\n    }\n    console.log('[StateManager] Sending message:', message.type, message);\n    try { \n      chrome.runtime.sendMessage(message, callback); \n    } catch (e) { \n      console.warn('[StateManager] Failed to send message:', e.message); \n    }\n  }\n}\n","export class UIManager {\n  constructor() {\n    this.localPreviewVideo = null;\n    this.remoteVideos = new Map();\n    this.remoteStreams = new Map();\n    this.streamMonitorInterval = null;\n  }\n  getRemoteVideos() { return this.remoteVideos; }\n  getRemoteStreams() { return this.remoteStreams; }\n  setLocalPreviewVideo(video) { this.localPreviewVideo = video; }\n  getLocalPreviewVideo() { return this.localPreviewVideo; }\n  setStreamMonitorInterval(interval) { this.streamMonitorInterval = interval; }\n  getStreamMonitorInterval() { return this.streamMonitorInterval; }\n  clearStreamMonitorInterval() {\n    if (this.streamMonitorInterval) {\n      clearInterval(this.streamMonitorInterval);\n      this.streamMonitorInterval = null;\n    }\n  }\n\n  attachLocalPreview(stream) {\n    console.log('[UIManager] Attaching local preview with stream:', stream);\n    this.removeLocalPreview();\n    \n    const v = document.createElement('video');\n    v.id = 'toperparty-local-preview';\n    v.autoplay = true;\n    v.muted = true; // Always mute local preview to avoid feedback\n    v.playsInline = true;\n    v.style.position = 'fixed';\n    v.style.bottom = '20px';\n    v.style.left = '20px';\n    v.style.width = '240px';\n    v.style.height = '160px';\n    v.style.zIndex = '10001';\n    v.style.border = '2px solid #e50914';\n    v.style.borderRadius = '4px';\n    v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\n\n    try {\n      v.srcObject = stream;\n      console.log('[UIManager] Set srcObject on local preview');\n    } catch (e) {\n      console.warn('[UIManager] srcObject failed, trying createObjectURL:', e);\n      v.src = URL.createObjectURL(stream);\n    }\n\n    document.body.appendChild(v);\n    this.localPreviewVideo = v;\n    console.log('[UIManager] Local preview video appended to body');\n\n    v.play().catch(err => {\n      console.warn('[UIManager] Local preview play() failed:', err);\n    });\n  }\n\n  removeLocalPreview() {\n    if (this.localPreviewVideo) {\n      console.log('[UIManager] Removing local preview video');\n      try {\n        if (this.localPreviewVideo.srcObject) {\n          this.localPreviewVideo.srcObject = null;\n        }\n      } catch (e) {\n        console.warn('[UIManager] Error clearing srcObject:', e);\n      }\n      this.localPreviewVideo.remove();\n      this.localPreviewVideo = null;\n    }\n  }\n\n  clearAll() {\n    this.removeLocalPreview();\n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    this.clearStreamMonitorInterval();\n  }\n}\n","export class NetflixController {\n  constructor() { this.injectAPIBridge(); }\n  injectAPIBridge() {\n    const script = document.createElement('script');\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\n    (document.head || document.documentElement).appendChild(script);\n    script.onload = function() { script.remove(); };\n  }\n  _sendCommand(command, args = []) {\n    return new Promise(function(resolve) {\n      const handler = function(e) {\n        if (e.detail.command === command) {\n          document.removeEventListener('__toperparty_response', handler);\n          resolve(e.detail.result);\n        }\n      };\n      document.addEventListener('__toperparty_response', handler);\n      setTimeout(function() { resolve(null); }, 1000);\n      document.dispatchEvent(new CustomEvent('__toperparty_command', { detail: { command, args } }));\n    });\n  }\n  play() { return this._sendCommand('play'); }\n  pause() { return this._sendCommand('pause'); }\n  seek(timeMs) { return this._sendCommand('seek', [timeMs]); }\n  getCurrentTime() { return this._sendCommand('getCurrentTime'); }\n  isPaused() { return this._sendCommand('isPaused'); }\n  getVideoElement() { return document.querySelector('video'); }\n}\n","export function createRemoteHandlers({ state, netflix, lock, isInitializedRef }) {\n  async function applyRemote(actionName, durationMs, actionFn) {\n    lock.set(durationMs);\n    try { await actionFn(); } catch (err) {\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\n    }\n  }\n\n  return {\n    async handleRequestSync(fromUserId) {\n      if (!isInitializedRef.get()) {\n        console.log('[SyncManager] Not yet initialized, ignoring sync request');\n        return;\n      }\n      \n      try {\n        const currentTime = await netflix.getCurrentTime();\n        const isPaused = await netflix.isPaused();\n        \n        if (currentTime == null) {\n          console.log('[SyncManager] Invalid playback state, ignoring sync request');\n          return;\n        }\n        \n        const currentTimeSeconds = currentTime / 1000;\n        console.log('[SyncManager] Sending SYNC_RESPONSE to', fromUserId, 'at', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing');\n        \n        state.safeSendMessage({\n          type: 'SYNC_RESPONSE',\n          targetUserId: fromUserId,\n          currentTime: currentTimeSeconds,\n          isPlaying: !isPaused\n        });\n      } catch (e) { console.error('[SyncManager] Error handling sync request:', e); }\n    },\n    async handleSyncResponse(currentTime, isPlaying, fromUserId) {\n      if (isInitializedRef.get()) {\n        console.log('[SyncManager] Already initialized, ignoring late SYNC_RESPONSE');\n        return;\n      }\n      \n      if (currentTime == null || typeof currentTime !== 'number' || currentTime < 0) {\n        console.warn('[SyncManager] Invalid SYNC_RESPONSE - bad currentTime:', currentTime);\n        return;\n      }\n      \n      console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused');\n      isInitializedRef.set(true);\n      \n      await applyRemote('initial-sync', 1500, async () => {\n        await netflix.seek(currentTime * 1000);\n        const localPaused = await netflix.isPaused();\n        if (isPlaying && localPaused) {\n          await netflix.play();\n        } else if (!isPlaying && !localPaused) {\n          await netflix.pause();\n        }\n      });\n    },\n    async handlePlaybackControl(control, currentTime, fromUserId) {\n      console.log('[SyncManager] Remote', control.toUpperCase(), 'at', currentTime, 'from', fromUserId);\n      \n      await applyRemote(control, 1000, async () => {\n        // Seek to the exact position first\n        if (currentTime != null) {\n          const currentTimeMs = currentTime * 1000;\n          await netflix.seek(currentTimeMs);\n          console.log('[SyncManager] Seeked to', currentTime.toFixed(2) + 's before', control);\n        }\n        \n        // Then apply play/pause\n        if (control === 'play') {\n          await netflix.play();\n        } else {\n          await netflix.pause();\n        }\n      });\n    },\n    async handleSeek(currentTime, isPlaying, fromUserId) {\n      console.log('[SyncManager] Remote SEEK to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'from', fromUserId);\n      \n      await applyRemote('seek', 1200, async () => {\n        await netflix.seek(currentTime * 1000);\n        const isPaused = await netflix.isPaused();\n        \n        if (isPlaying && isPaused) {\n          await netflix.play();\n        } else if (!isPlaying && !isPaused) {\n          await netflix.pause();\n        }\n      });\n    }\n  };\n}\n","export function attachPlaybackListeners({ video, state, isInitializedRef, lock, onPlay, onPause, onSeek }) {\n  const handlePlay = () => {\n    if (!state.isActive()) return;\n    if (!isInitializedRef.get()) return;\n    if (lock.isActive()) return;\n    console.log('[EventListeners] Play event detected');\n    onPlay(video);\n  };\n\n  const handlePause = () => {\n    if (!state.isActive()) return;\n    if (!isInitializedRef.get()) return;\n    if (lock.isActive()) return;\n    console.log('[EventListeners] Pause event detected');\n    onPause(video);\n  };\n\n  const handleSeeked = () => {\n    if (!state.isActive()) return;\n    if (!isInitializedRef.get()) return;\n    if (lock.isActive()) return;\n    console.log('[EventListeners] Seek event detected');\n    onSeek(video);\n  };\n\n  video.addEventListener('play', handlePlay);\n  video.addEventListener('pause', handlePause);\n  video.addEventListener('seeked', handleSeeked);\n\n  return { video, handlePlay, handlePause, handleSeeked };\n}\n","import { createSignalingHandlers } from './signaling.js';\nimport { createPeerConnectionFactory, addOrReplaceTrack } from './peerConnection.js';\nimport { createReconnectionManager } from './reconnect.js';\nimport { createRemoteVideoManager } from './ui.js';\n\nexport class WebRTCManager {\n  constructor(stateManager, uiManager) {\n    this.stateManager = stateManager;\n    this.uiManager = uiManager;\n    this.peerConnections = new Map();\n    this.remoteStreams = this.uiManager.getRemoteStreams();\n    this.remoteVideos = this.uiManager.getRemoteVideos();\n    this.peersThatLeft = new Set();\n    this.localStream = null;\n\n    const videoManager = createRemoteVideoManager(this.remoteVideos);\n    \n    // Create a placeholder object for circular dependency resolution\n    const reconnectionManager = {};\n    \n    const createPeer = createPeerConnectionFactory({\n      stateManager: this.stateManager,\n      sendSignal: (msg) => this._sendSignal(msg),\n      remoteStreams: this.remoteStreams,\n      remoteVideos: this.remoteVideos,\n      addRemoteVideo: videoManager.add,\n      attemptReconnection: (peerId) => reconnectionManager.attempt(peerId),\n      clearReconnection: (peerId) => reconnectionManager.clear(peerId),\n      removeRemoteVideo: (peerId) => {\n        videoManager.remove(peerId);\n        this.remoteStreams.delete(peerId);\n      },\n      peersThatLeft: this.peersThatLeft\n    });\n\n    // Now create the actual reconnection manager with createPeer available\n    Object.assign(reconnectionManager, createReconnectionManager({\n      stateManager: this.stateManager,\n      peerConnections: this.peerConnections,\n      peersThatLeft: this.peersThatLeft,\n      localStream: () => this.localStream,\n      createPeer: createPeer,\n      sendSignal: (msg) => this._sendSignal(msg),\n      addOrReplaceTrack\n    }));\n\n    this.reconnectionManager = reconnectionManager;\n    this.createPeer = createPeer;\n    this.videoManager = videoManager;\n\n    this.signalingHandlers = createSignalingHandlers({\n      getState: () => this.stateManager.getState(),\n      peerConnections: this.peerConnections,\n      peersThatLeft: this.peersThatLeft,\n      getLocalStream: () => this.localStream,\n      createPeer,\n      sendSignal: (msg) => this._sendSignal(msg),\n      addOrReplaceTrack,\n      clearReconnection: reconnectionManager.clear,\n      removeRemoteVideo: (peerId) => {\n        videoManager.remove(peerId);\n        this.remoteStreams.delete(peerId);\n      }\n    });\n  }\n\n  setLocalStream(stream) { this.localStream = stream; }\n  getLocalStream() { return this.localStream; }\n  \n  onLocalStreamAvailable(stream) {\n    this.localStream = stream;\n    this.peerConnections.forEach((pc) => {\n      try {\n        stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\n      } catch (e) {}\n    });\n  }\n\n  async handleSignal(message) {\n    console.log('[WebRTCManager] handleSignal called with:', message);\n    if (!message || !message.type) {\n      console.warn('[WebRTCManager] Invalid message:', message);\n      return;\n    }\n    const type = message.type;\n    const from = message.userId || message.from;\n    const to = message.to;\n    const state = this.stateManager.getState();\n    console.log('[WebRTCManager] Processing signal type:', type, 'from:', from, 'to:', to, 'myId:', state.userId);\n    \n    if (to && to !== state.userId) {\n      console.log('[WebRTCManager] Ignoring message not meant for me');\n      return;\n    }\n\n    if (type === 'JOIN' && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleJoin');\n      await this.signalingHandlers.handleJoin(from);\n    } else if (type === 'OFFER' && message.offer && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleOffer');\n      await this.signalingHandlers.handleOffer(from, message.offer);\n    } else if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleAnswer');\n      await this.signalingHandlers.handleAnswer(from, message.answer);\n    } else if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleIceCandidate');\n      await this.signalingHandlers.handleIceCandidate(from, message.candidate);\n    } else if (type === 'LEAVE' && from) {\n      console.log('[WebRTCManager] Dispatching to handleLeave');\n      this.signalingHandlers.handleLeave(from);\n    } else {\n      console.log('[WebRTCManager] Signal not handled - type:', type, 'from:', from, 'conditions not met');\n    }\n  }\n\n  attemptReconnection(peerId) {\n    return this.reconnectionManager.attempt(peerId);\n  }\n\n  _sendSignal(message) {\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\n  }\n\n  clearAll() {\n    this.peerConnections.forEach((pc) => {\n      try { pc.close(); } catch (e) {}\n    });\n    this.peerConnections.clear();\n    this.peersThatLeft.clear();\n    this.remoteVideos.forEach((v) => {\n      try { if (v.srcObject) v.srcObject = null; } catch (e) {}\n      v.remove();\n    });\n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n  }\n}\n","export function createRemoteVideoManager(remoteVideos) {\n  function add(peerId, stream) {\n    console.log('[RemoteVideoManager] Adding remote video for peer:', peerId, 'stream:', stream, 'tracks:', stream.getTracks());\n    remove(peerId);\n    const v = document.createElement('video');\n    v.id = 'toperparty-remote-' + peerId;\n    v.autoplay = true;\n    v.playsInline = true;\n    v.muted = true;\n    v.style.position = 'fixed';\n    v.style.bottom = '20px';\n    v.style.right = (20 + (remoteVideos.size * 180)) + 'px';\n    v.style.width = '240px';\n    v.style.height = '160px';\n    v.style.zIndex = 10001;\n    v.style.border = '2px solid #00aaff';\n    v.style.borderRadius = '4px';\n    console.log('[RemoteVideoManager] Created video element:', v.id, 'at position:', v.style.right);\n    try { \n      v.srcObject = stream;\n      console.log('[RemoteVideoManager] Set srcObject successfully');\n    } catch (e) { \n      console.warn('[RemoteVideoManager] srcObject failed, trying createObjectURL:', e);\n      v.src = URL.createObjectURL(stream); \n    }\n    document.body.appendChild(v);\n    console.log('[RemoteVideoManager] Appended video to body');\n    remoteVideos.set(peerId, v);\n    try {\n      v.play().then(() => {\n        console.log('[RemoteVideoManager] Video playing, unmuting');\n        v.muted = false;\n        v.volume = 1.0;\n      }).catch((e) => { \n        console.warn('[RemoteVideoManager] Play failed:', e);\n        v.muted = false; \n      });\n    } catch (e) {\n      console.warn('[RemoteVideoManager] Error calling play:', e);\n    }\n  }\n  \n  function remove(peerId) {\n    console.log('[RemoteVideoManager] Removing remote video for peer:', peerId);\n    const v = remoteVideos.get(peerId);\n    if (v) {\n      try { if (v.srcObject) v.srcObject = null; } catch (e) {}\n      v.remove();\n      remoteVideos.delete(peerId);\n    }\n  }\n  \n  return { add, remove };\n}\n","export function createReconnectionManager({ stateManager, peerConnections, peersThatLeft, localStream, createPeer, sendSignal, addOrReplaceTrack }) {\n  const attempts = new Map();\n  const timeouts = new Map();\n  \n  function clear(peerId) {\n    attempts.delete(peerId);\n    const handle = timeouts.get(peerId);\n    if (handle) {\n      clearTimeout(handle);\n      timeouts.delete(peerId);\n    }\n  }\n  \n  async function attempt(peerId) {\n    if (!stateManager.isInParty()) return;\n    if (peersThatLeft.has(peerId)) {\n      clear(peerId);\n      return;\n    }\n    const count = attempts.get(peerId) || 0;\n    const maxAttempts = 5;\n    const backoffDelay = Math.min(1000 * Math.pow(2, count), 30000);\n    if (count >= maxAttempts) {\n      clear(peerId);\n      return;\n    }\n    attempts.set(peerId, count + 1);\n    const existing = timeouts.get(peerId);\n    if (existing) clearTimeout(existing);\n    const handle = setTimeout(async () => {\n      const oldPc = peerConnections.get(peerId);\n      if (oldPc) {\n        try { oldPc.close(); } catch (e) {}\n        peerConnections.delete(peerId);\n      }\n      try {\n        const pc = createPeer(peerId);\n        peerConnections.set(peerId, pc);\n        const stream = typeof localStream === 'function' ? localStream() : localStream;\n        if (stream) {\n          stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\n        }\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        const state = stateManager.getState();\n        sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\n      } catch (err) {\n        console.error('[WebRTCManager] Reconnection failed:', err);\n        attempt(peerId);\n      }\n    }, backoffDelay);\n    timeouts.set(peerId, handle);\n  }\n  \n  return { attempt, clear };\n}\n","export function createSignalingHandlers({ getState, peerConnections, peersThatLeft, getLocalStream, createPeer, sendSignal, addOrReplaceTrack, clearReconnection, removeRemoteVideo }) {\n  return {\n    async handleJoin(from) {\n      console.log('[Signaling] Handling JOIN from', from);\n      const state = getState();\n      if (from === state.userId) {\n        console.log('[Signaling] Ignoring JOIN from self');\n        return;\n      }\n      peersThatLeft.delete(from);\n      if (peerConnections.has(from)) {\n        console.log('[Signaling] Already have peer connection for', from);\n        return;\n      }\n      try {\n        console.log('[Signaling] Creating peer connection for', from);\n        const pc = createPeer(from);\n        peerConnections.set(from, pc);\n        const stream = getLocalStream();\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\n        if (stream) {\n          stream.getTracks().forEach(t => {\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\n            addOrReplaceTrack(pc, t, stream);\n          });\n        } else {\n          console.warn('[Signaling] No local stream available when handling JOIN');\n        }\n        console.log('[Signaling] Creating and sending OFFER to', from);\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\n      } catch (err) {\n        console.error('[Signaling] Error handling JOIN:', err);\n        peerConnections.delete(from);\n      }\n    },\n    async handleOffer(from, offer) {\n      console.log('[Signaling] Handling OFFER from', from);\n      const state = getState();\n      if (from === state.userId) {\n        console.log('[Signaling] Ignoring OFFER from self');\n        return;\n      }\n      let pc = peerConnections.get(from);\n      if (pc && pc.signalingState !== 'closed') {\n        console.log('[Signaling] Closing existing peer connection');\n        try { pc.close(); } catch (e) {}\n        peerConnections.delete(from);\n        pc = null;\n      }\n      if (!pc) {\n        console.log('[Signaling] Creating new peer connection for', from);\n        pc = createPeer(from);\n        peerConnections.set(from, pc);\n      }\n      try {\n        console.log('[Signaling] Setting remote description');\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\n        const stream = getLocalStream();\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\n        if (stream) {\n          stream.getTracks().forEach(t => {\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\n            addOrReplaceTrack(pc, t, stream);\n          });\n        } else {\n          console.warn('[Signaling] No local stream available when handling OFFER');\n        }\n        console.log('[Signaling] Creating and sending ANSWER to', from);\n        const answer = await pc.createAnswer();\n        await pc.setLocalDescription(answer);\n        sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\n      } catch (err) {\n        console.error('[Signaling] Error handling offer:', err);\n        peerConnections.delete(from);\n        try { pc.close(); } catch (e) {}\n      }\n    },\n    async handleAnswer(from, answer) {\n      console.log('[Signaling] Handling ANSWER from', from);\n      const pc = peerConnections.get(from);\n      if (pc && pc.signalingState === 'have-local-offer') {\n        console.log('[Signaling] Setting remote description from ANSWER');\n        try {\n          await pc.setRemoteDescription(new RTCSessionDescription(answer));\n          console.log('[Signaling] Remote description set successfully');\n        } catch (err) {\n          console.error('[Signaling] Error handling answer:', err);\n        }\n      } else {\n        console.warn('[Signaling] Cannot handle ANSWER - pc:', !!pc, 'signalingState:', pc?.signalingState);\n      }\n    },\n    async handleIceCandidate(from, candidate) {\n      console.log('[Signaling] Handling ICE_CANDIDATE from', from);\n      const pc = peerConnections.get(from);\n      if (pc) {\n        try {\n          await pc.addIceCandidate(new RTCIceCandidate(candidate));\n          console.log('[Signaling] ICE candidate added successfully');\n        } catch (err) {\n          console.warn('[Signaling] Error adding ICE candidate', err);\n        }\n      } else {\n        console.warn('[Signaling] No peer connection found for ICE candidate from', from);\n      }\n    },\n    handleLeave(from) {\n      console.log('[Signaling] Handling LEAVE from', from);\n      peersThatLeft.add(from);\n      const pc = peerConnections.get(from);\n      if (pc) {\n        try { pc.close(); } catch (e) {}\n        peerConnections.delete(from);\n      }\n      clearReconnection(from);\n      removeRemoteVideo(from);\n    }\n  };\n}\n","export class URLSync {\n  constructor(stateManager) {\n    this.stateManager = stateManager;\n    this.urlMonitorInterval = null;\n    this.lastUrl = null;\n  }\n  start() { this.lastUrl = window.location.href; }\n  stop() {\n    if (this.urlMonitorInterval) { clearInterval(this.urlMonitorInterval); this.urlMonitorInterval = null; }\n  }\n  saveState() {\n    const state = this.stateManager.getState();\n    if (!state.partyActive) return;\n    const existing = this.getRestorationState() || {};\n    const payload = {\n      roomId: state.roomId,\n      currentTime: existing.currentTime || null,\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\n      timestamp: Date.now()\n    };\n    sessionStorage.setItem('toperparty_restore', JSON.stringify(payload));\n  }\n  clearState() { sessionStorage.removeItem('toperparty_restore'); }\n  getRestorationState() {\n    const stored = sessionStorage.getItem('toperparty_restore');\n    if (!stored) return null;\n    try {\n      const state = JSON.parse(stored);\n      if (Date.now() - state.timestamp < 30000) { return state; }\n    } catch (e) { console.error('[toperparty] Failed to parse restoration state:', e); }\n    return null;\n  }\n}\n"],"names":["SyncLock","constructor","this","suppressLocalUntil","set","durationMs","Date","now","isActive","MutableRef","value","get","v","addOrReplaceTrack","pc","track","stream","existingSender","getSenders","find","s","kind","replaceTrack","catch","e","console","warn","addTrack","log","stateManager","partyActive","userId","roomId","restoringPartyState","startParty","stopParty","getUserId","getRoomId","getState","isInParty","setRestoringFlag","isExtensionContextValid","chrome","runtime","id","safeSendMessage","message","callback","type","sendMessage","uiManager","localPreviewVideo","remoteVideos","Map","remoteStreams","streamMonitorInterval","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","video","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","clearInterval","attachLocalPreview","removeLocalPreview","document","createElement","autoplay","muted","playsInline","style","position","bottom","left","width","height","zIndex","border","borderRadius","transform","srcObject","src","URL","createObjectURL","body","appendChild","play","err","remove","clearAll","clear","netflixController","injectAPIBridge","script","getURL","head","documentElement","onload","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","addEventListener","setTimeout","dispatchEvent","CustomEvent","pause","seek","timeMs","getCurrentTime","isPaused","getVideoElement","querySelector","syncManager","state","netflix","lock","isInitializedRef","listeners","remote","async","applyRemote","actionName","actionFn","error","handleRequestSync","fromUserId","currentTime","currentTimeSeconds","toFixed","targetUserId","isPlaying","handleSyncResponse","localPaused","handlePlaybackControl","control","toUpperCase","currentTimeMs","handleSeek","createRemoteHandlers","setup","waitForVideo","onPlay","onPause","onSeek","handlePlay","handlePause","handleSeeked","attachPlaybackListeners","vid","broadcastPlay","broadcastPause","broadcastSeek","teardown","reject","timeout","Error","check","clearTimeout","paused","webrtcManager","peerConnections","peersThatLeft","Set","localStream","videoManager","peerId","delete","add","getTracks","right","size","then","volume","createRemoteVideoManager","reconnectionManager","createPeer","sendSignal","addRemoteVideo","attemptReconnection","clearReconnection","removeRemoteVideo","RTCPeerConnection","iceServers","urls","onicecandidate","event","candidate","from","to","ontrack","streams","MediaStream","has","length","onconnectionstatechange","connectionState","createPeerConnectionFactory","msg","_sendSignal","attempt","Object","assign","attempts","timeouts","handle","count","backoffDelay","Math","min","pow","existing","oldPc","close","forEach","t","offer","createOffer","setLocalDescription","localDescription","createReconnectionManager","signalingHandlers","getLocalStream","handleJoin","handleOffer","signalingState","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleAnswer","handleIceCandidate","addIceCandidate","RTCIceCandidate","handleLeave","createSignalingHandlers","setLocalStream","onLocalStreamAvailable","handleSignal","stop","urlSync","urlMonitorInterval","lastUrl","start","window","location","href","saveState","getRestorationState","payload","timestamp","sessionStorage","setItem","JSON","stringify","clearState","removeItem","stored","getItem","parse","videoElementMonitor","restorationState","onMessage","addListener","request","sender","sendResponse","navigator","mediaDevices","getUserMedia","audio","success","setInterval","getElementById","videoId","url"],"ignoreList":[],"sourceRoot":""}