{"version":3,"file":"content-script.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB,SAAS;AACvD,uEAAuE,UAAU,iBAAiB;AAClG,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzDA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,GAAG,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0CAA0C,WAAW;AACrD;AACA;AACA;AACA,8BAA8B;AAC9B,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,qCAAqC;AACrC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAiD;AAC/D;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3TA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCtDA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;ACNA;AACA;AAC0D;AACU;AACZ;AACI;AACR;AACJ;AAChD;AACA;AACA,yBAAyB,mEAAY;AACrC,8BAA8B,6EAAiB;AAC/C,wBAAwB,iEAAW;AACnC,0BAA0B,qEAAa;AACvC,sBAAsB,6DAAS;AAC/B,oBAAoB,yDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,SAAS;AACd;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,GAAG,QAAQ;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS,YAAY,YAAY,cAAc;AAC9D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAAqE,YAAY;AACjG,SAAS;AACT,uBAAuB,iDAAiD;AACxE,OAAO;AACP;AACA;AACA,uBAAuB,oCAAoC;AAC3D,OAAO;AACP;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG,SAAS;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yEAAyE;AAC9F,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2EAA2E;AAC9F,MAAM;AACN;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,WAAW,aAAa,GAAG,YAAY,OAAO,aAAa;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2EAA2E;AAC9F;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,wCAAwC;AAChD,QAAQ;AACR;AACA,GAAG;AACH;AACA;AACA;AACA,mBAAmB,mFAAmF;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA","sources":["webpack://toperparty/./chrome-extension/modules/netflix-controller.js","webpack://toperparty/./chrome-extension/modules/state-manager.js","webpack://toperparty/./chrome-extension/modules/sync-manager.js","webpack://toperparty/./chrome-extension/modules/ui-manager.js","webpack://toperparty/./chrome-extension/modules/url-sync.js","webpack://toperparty/./chrome-extension/modules/webrtc-manager.js","webpack://toperparty/webpack/bootstrap","webpack://toperparty/webpack/runtime/define property getters","webpack://toperparty/webpack/runtime/hasOwnProperty shorthand","webpack://toperparty/webpack/runtime/make namespace object","webpack://toperparty/./chrome-extension/content-script.js"],"sourcesContent":["// netflix-controller.js - Netflix player API wrapper\r\n\r\nexport class NetflixController {\r\n  constructor() {\r\n    this.injectAPIBridge();\r\n  }\r\n  \r\n  // Inject Netflix API access script into page context\r\n  injectAPIBridge() {\r\n    const script = document.createElement('script');\r\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\r\n    (document.head || document.documentElement).appendChild(script);\r\n    script.onload = function() {\r\n      console.log('Netflix API bridge loaded');\r\n      script.remove();\r\n    };\r\n  }\r\n  \r\n  // Send command to Netflix API via custom events\r\n  _sendCommand(command, args = []) {\r\n    return new Promise(function(resolve) {\r\n      const handler = function(e) {\r\n        if (e.detail.command === command) {\r\n          document.removeEventListener('__toperparty_response', handler);\r\n          resolve(e.detail.result);\r\n        }\r\n      };\r\n      document.addEventListener('__toperparty_response', handler);\r\n      setTimeout(function() { resolve(null); }, 1000); // timeout fallback\r\n      document.dispatchEvent(new CustomEvent('__toperparty_command', { detail: { command, args } }));\r\n    });\r\n  }\r\n  \r\n  play() {\r\n    return this._sendCommand('play');\r\n  }\r\n  \r\n  pause() {\r\n    return this._sendCommand('pause');\r\n  }\r\n  \r\n  seek(timeMs) {\r\n    return this._sendCommand('seek', [timeMs]);\r\n  }\r\n  \r\n  getCurrentTime() {\r\n    return this._sendCommand('getCurrentTime');\r\n  }\r\n  \r\n  isPaused() {\r\n    return this._sendCommand('isPaused');\r\n  }\r\n  \r\n  // Find Netflix video element (fallback)\r\n  getVideoElement() {\r\n    return document.querySelector('video');\r\n  }\r\n}\r\n","// state-manager.js - Manages party state and action tracking\r\n\r\nexport class StateManager {\r\n  constructor() {\r\n    // Party state\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    this.restoringPartyState = false;\r\n    \r\n    // Action tracking for echo prevention\r\n    this.lastLocalAction = { type: null, time: 0 };\r\n    this.lastRemoteAction = { type: null, time: 0 };\r\n  }\r\n  \r\n  // Party state management\r\n  startParty(userId, roomId) {\r\n    this.partyActive = true;\r\n    this.userId = userId;\r\n    this.roomId = roomId;\r\n    console.log('Party started! Room:', roomId, 'User:', userId);\r\n  }\r\n  \r\n  stopParty() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    this.lastLocalAction = { type: null, time: 0 };\r\n    this.lastRemoteAction = { type: null, time: 0 };\r\n    console.log('Party stopped');\r\n  }\r\n  \r\n  isActive() {\r\n    return this.partyActive;\r\n  }\r\n  \r\n  getUserId() {\r\n    return this.userId;\r\n  }\r\n  \r\n  getRoomId() {\r\n    return this.roomId;\r\n  }\r\n  \r\n  getState() {\r\n    return {\r\n      partyActive: this.partyActive,\r\n      userId: this.userId,\r\n      roomId: this.roomId,\r\n      restoringPartyState: this.restoringPartyState\r\n    };\r\n  }\r\n  \r\n  setRestoringFlag(value) {\r\n    this.restoringPartyState = value;\r\n  }\r\n  \r\n  // Echo prevention helpers\r\n  isEcho(actionType) {\r\n    const now = Date.now();\r\n    const timeSinceLocal = now - this.lastLocalAction.time;\r\n    \r\n    // If we just performed this action within 500ms, it's likely an echo\r\n    if (this.lastLocalAction.type === actionType && timeSinceLocal < 500) {\r\n      console.log(`Ignoring echo of ${actionType} (${timeSinceLocal}ms ago)`);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  recordLocalAction(actionType) {\r\n    this.lastLocalAction = { type: actionType, time: Date.now() };\r\n    console.log(`Recorded local action: ${actionType}`);\r\n  }\r\n  \r\n  recordRemoteAction(actionType) {\r\n    this.lastRemoteAction = { type: actionType, time: Date.now() };\r\n    console.log(`Recorded remote action: ${actionType}`);\r\n  }\r\n  \r\n  getTimeSinceLocalAction() {\r\n    return Date.now() - this.lastLocalAction.time;\r\n  }\r\n  \r\n  getTimeSinceRemoteAction() {\r\n    return Date.now() - this.lastRemoteAction.time;\r\n  }\r\n  \r\n  // Extension context validation\r\n  isExtensionContextValid() {\r\n    try {\r\n      return chrome.runtime && chrome.runtime.id;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Safe message sending\r\n  safeSendMessage(message, callback) {\r\n    if (!this.isExtensionContextValid()) {\r\n      console.warn('Extension context invalidated - please reload the page');\r\n      return;\r\n    }\r\n    try {\r\n      chrome.runtime.sendMessage(message, callback);\r\n    } catch (e) {\r\n      console.warn('Failed to send message, extension may have been reloaded:', e.message);\r\n    }\r\n  }\r\n}\r\n","// sync-manager.js - Handles playback synchronization\r\n// Rebuilt with simple, reliable logic to prevent feedback loops\r\n\r\nexport class SyncManager {\r\n  constructor(stateManager, netflixController) {\r\n    this.state = stateManager;\r\n    this.netflix = netflixController;\r\n    this.listeners = null;\r\n    this.syncInterval = null;\r\n    this.suppressBroadcast = false; // Flag to suppress broadcasting when we control video programmatically\r\n    this.expectedEvents = new Set(); // Track which events we're expecting from programmatic control\r\n    this.lastProgrammaticSeekAt = 0; // Track when we last did a programmatic seek\r\n  }\r\n  \r\n  // Setup playback synchronization\r\n  async setup() {\r\n    try {\r\n      const video = await this.waitForVideo();\r\n      if (!video) {\r\n        console.warn('Netflix video element not found after wait');\r\n        return;\r\n      }\r\n      \r\n      this.attachEventListeners(video);\r\n      this.startPeriodicSync(video);\r\n      \r\n      console.log('Playback sync setup complete');\r\n    } catch (err) {\r\n      console.error('Error setting up playback sync:', err);\r\n    }\r\n  }\r\n  \r\n  // Wait for Netflix video element to appear\r\n  waitForVideo() {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\r\n      \r\n      const check = () => {\r\n        const video = this.netflix.getVideoElement();\r\n        if (video) {\r\n          clearTimeout(timeout);\r\n          resolve(video);\r\n        } else {\r\n          setTimeout(check, 100);\r\n        }\r\n      };\r\n      check();\r\n    });\r\n  }\r\n  \r\n  // Attach event listeners to video element\r\n  attachEventListeners(video) {\r\n    // Play event - broadcast to peers ONLY if it's a user action\r\n    const onPlay = () => {\r\n      console.log('[Play event] Fired - expectedEvents:', Array.from(this.expectedEvents), 'partyActive:', this.state.isActive());\r\n      \r\n      if (!this.state.isActive()) return;\r\n      \r\n      // If this is an expected programmatic event, consume it and don't broadcast\r\n      if (this.expectedEvents.has('play')) {\r\n        this.expectedEvents.delete('play');\r\n        console.log('[Play event] ✓ Suppressed - programmatic control (expected event consumed)');\r\n        return;\r\n      }\r\n      \r\n      console.log('[Play event] ✓ User action - broadcasting to peers');\r\n      this.state.safeSendMessage({ \r\n        type: 'PLAY_PAUSE', \r\n        control: 'play', \r\n        timestamp: video.currentTime \r\n      });\r\n    };\r\n    \r\n    // Pause event - broadcast to peers ONLY if it's a user action\r\n    const onPause = () => {\r\n      console.log('[Pause event] Fired - expectedEvents:', Array.from(this.expectedEvents), 'partyActive:', this.state.isActive());\r\n      \r\n      if (!this.state.isActive()) return;\r\n      \r\n      // If this is an expected programmatic event, consume it and don't broadcast\r\n      if (this.expectedEvents.has('pause')) {\r\n        this.expectedEvents.delete('pause');\r\n        console.log('[Pause event] ✓ Suppressed - programmatic control (expected event consumed)');\r\n        return;\r\n      }\r\n      \r\n      console.log('[Pause event] ✓ User action - broadcasting to peers');\r\n      this.state.safeSendMessage({ \r\n        type: 'PLAY_PAUSE', \r\n        control: 'pause', \r\n        timestamp: video.currentTime \r\n      });\r\n    };\r\n    \r\n    // Seek event - broadcast to peers ONLY if it's a user action\r\n    const onSeeked = () => {\r\n      const currentTime = video.currentTime;\r\n      const now = Date.now();\r\n      const timeSinceLastProgrammaticSeek = now - this.lastProgrammaticSeekAt;\r\n      \r\n      console.log('[Seeked event] Fired - expectedEvents:', Array.from(this.expectedEvents), 'timeSinceProgSeek:', timeSinceLastProgrammaticSeek, 'ms, time:', currentTime);\r\n      \r\n      if (!this.state.isActive()) return;\r\n      \r\n      // Suppress ALL seeks within 1 second of a programmatic seek (catches multiple events)\r\n      if (timeSinceLastProgrammaticSeek < 1000) {\r\n        console.log('[Seeked event] ✓ Suppressed - within 1s of programmatic seek');\r\n        this.expectedEvents.delete('seeked'); // Clean up if present\r\n        return;\r\n      }\r\n      \r\n      // Also check expected events (for explicit commands)\r\n      if (this.expectedEvents.has('seeked')) {\r\n        this.expectedEvents.delete('seeked');\r\n        console.log('[Seeked event] ✓ Suppressed - programmatic control (expected event consumed)');\r\n        return;\r\n      }\r\n      \r\n      console.log('[Seeked event] ✓ User action - broadcasting to peers');\r\n      this.state.safeSendMessage({ \r\n        type: 'SEEK', \r\n        currentTime: video.currentTime, \r\n        isPlaying: !video.paused \r\n      });\r\n    };\r\n    \r\n    // Passive sync via timeupdate - send position periodically for drift correction\r\n    let lastSentAt = 0;\r\n    let lastUserSeekAt = 0; // Track when user last seeked\r\n    \r\n    // Track user seeks so passive sync can avoid interfering\r\n    const originalOnSeeked = onSeeked;\r\n    const onSeekedWithTracking = () => {\r\n      // If this was a user action (not suppressed), remember the time\r\n      if (!this.expectedEvents.has('seeked')) {\r\n        lastUserSeekAt = Date.now();\r\n        console.log('[Passive sync] User seek detected - will pause passive sync for 5s');\r\n      }\r\n      originalOnSeeked();\r\n    };\r\n    \r\n    const onTimeUpdate = () => {\r\n      if (!this.state.isActive()) return;\r\n      \r\n      const now = Date.now();\r\n      \r\n      // Only send every 5 seconds (be conservative)\r\n      if (now - lastSentAt < 5000) return;\r\n      \r\n      // Don't send if user seeked recently (within 5 seconds)\r\n      if (now - lastUserSeekAt < 5000) {\r\n        console.log('[Passive sync] Skipping send - user seeked recently');\r\n        return;\r\n      }\r\n      \r\n      lastSentAt = now;\r\n      \r\n      // Send our current position for others to sync to\r\n      console.log('[Passive sync] Broadcasting position:', video.currentTime.toFixed(2), 's');\r\n      this.state.safeSendMessage({ \r\n        type: 'SYNC_TIME', \r\n        currentTime: video.currentTime, \r\n        isPlaying: !video.paused,\r\n        timestamp: now\r\n      });\r\n    };\r\n    \r\n    video.addEventListener('play', onPlay);\r\n    video.addEventListener('pause', onPause);\r\n    video.addEventListener('seeked', onSeekedWithTracking);\r\n    video.addEventListener('timeupdate', onTimeUpdate);\r\n    \r\n    // Save references for teardown\r\n    this.listeners = { onPlay, onPause, onSeeked: onSeekedWithTracking, onTimeUpdate, video };\r\n  }\r\n  \r\n  // No longer needed - we use timeupdate events for passive sync\r\n  startPeriodicSync(video) {\r\n    // Removed - timeupdate does this for us now\r\n  }\r\n  \r\n  // Teardown playback synchronization\r\n  teardown() {\r\n    if (this.syncInterval) {\r\n      clearInterval(this.syncInterval);\r\n      this.syncInterval = null;\r\n    }\r\n    \r\n    if (this.listeners && this.listeners.video) {\r\n      const { video, onPlay, onPause, onSeeked, onTimeUpdate } = this.listeners;\r\n      try {\r\n        video.removeEventListener('play', onPlay);\r\n        video.removeEventListener('pause', onPause);\r\n        video.removeEventListener('seeked', onSeeked);\r\n        video.removeEventListener('timeupdate', onTimeUpdate);\r\n      } catch (e) {\r\n        console.warn('Error removing video event listeners:', e);\r\n      }\r\n      this.listeners = null;\r\n    }\r\n  }\r\n  \r\n  // Handle remote playback control commands (explicit play/pause)\r\n  async handlePlaybackControl(control, fromUserId) {\r\n    console.log('[Remote command] Received', control, 'from', fromUserId);\r\n    \r\n    // Mark that we expect this event\r\n    this.expectedEvents.add(control); // 'play' or 'pause'\r\n    console.log('[Remote command] Added expected event:', control);\r\n    \r\n    try {\r\n      if (control === 'play') {\r\n        console.log('[Remote command] Executing play()...');\r\n        await this.netflix.play();\r\n        console.log('[Remote command] Play completed');\r\n      } else if (control === 'pause') {\r\n        console.log('[Remote command] Executing pause()...');\r\n        await this.netflix.pause();\r\n        console.log('[Remote command] Pause completed');\r\n      }\r\n    } catch (err) {\r\n      console.error('[Remote command] Error executing', control, err);\r\n      // Clean up expected event on error\r\n      this.expectedEvents.delete(control);\r\n    }\r\n  }\r\n  \r\n  // Handle remote seek commands (explicit seek)\r\n  async handleSeek(currentTime, isPlaying, fromUserId) {\r\n    console.log('[Remote command] Received SEEK to', currentTime, 's from', fromUserId, 'isPlaying:', isPlaying);\r\n    \r\n    const requestedTime = currentTime * 1000; // Convert to ms\r\n    \r\n    try {\r\n      // Mark that we expect a seeked event AND record the timestamp\r\n      this.expectedEvents.add('seeked');\r\n      this.lastProgrammaticSeekAt = Date.now();\r\n      console.log('[Remote command] Added expected event: seeked + timestamp');\r\n      \r\n      console.log('[Remote command] Executing seek(' + requestedTime + 'ms)...');\r\n      await this.netflix.seek(requestedTime);\r\n      console.log('[Remote command] Seek completed');\r\n      \r\n      // Also sync play/pause state\r\n      const isPaused = await this.netflix.isPaused();\r\n      console.log('[Remote command] Current state - isPaused:', isPaused);\r\n      \r\n      if (isPlaying && isPaused) {\r\n        this.expectedEvents.add('play');\r\n        console.log('[Remote command] Need to resume - executing play()...');\r\n        await this.netflix.play();\r\n        console.log('[Remote command] Resumed after seek');\r\n      } else if (!isPlaying && !isPaused) {\r\n        this.expectedEvents.add('pause');\r\n        console.log('[Remote command] Need to pause - executing pause()...');\r\n        await this.netflix.pause();\r\n        console.log('[Remote command] Paused after seek');\r\n      }\r\n    } catch (err) {\r\n      console.error('[Remote command] Error during seek:', err);\r\n      // Clean up expected events on error\r\n      this.expectedEvents.clear();\r\n    }\r\n  }\r\n  \r\n  // Handle passive sync (drift correction only)\r\n  async handlePassiveSync(currentTime, isPlaying, fromUserId, messageTimestamp) {\r\n    // Ignore stale messages (older than 3 seconds)\r\n    if (messageTimestamp) {\r\n      const messageAge = Date.now() - messageTimestamp;\r\n      if (messageAge > 3000) {\r\n        console.log('[Passive sync] Ignoring stale message - age:', (messageAge / 1000).toFixed(1), 's');\r\n        return;\r\n      }\r\n    }\r\n    \r\n    try {\r\n      const localTime = await this.netflix.getCurrentTime();\r\n      const localPaused = await this.netflix.isPaused();\r\n      const requestedTime = currentTime * 1000; // Convert to ms\r\n      const timeDiff = Math.abs(localTime - requestedTime);\r\n      \r\n      console.log('[Passive sync] Received position:', currentTime.toFixed(2), 's from', fromUserId);\r\n      console.log('[Passive sync] Local:', (localTime/1000).toFixed(2), 's | Drift:', (timeDiff/1000).toFixed(2), 's');\r\n      \r\n      // Only correct drift > 3 seconds (conservative threshold)\r\n      if (timeDiff > 3000) {\r\n        console.log('[Passive sync] ⚠️  Drift detected:', (timeDiff / 1000).toFixed(1), 's - correcting');\r\n        \r\n        // Add expected events AND record timestamp\r\n        this.expectedEvents.add('seeked');\r\n        this.lastProgrammaticSeekAt = Date.now();\r\n        if (isPlaying && localPaused) {\r\n          this.expectedEvents.add('play');\r\n        } else if (!isPlaying && !localPaused) {\r\n          this.expectedEvents.add('pause');\r\n        }\r\n        \r\n        await this.netflix.seek(requestedTime);\r\n        \r\n        // Sync play/pause state too\r\n        if (isPlaying && localPaused) {\r\n          await this.netflix.play();\r\n        } else if (!isPlaying && !localPaused) {\r\n          await this.netflix.pause();\r\n        }\r\n      } else {\r\n        console.log('[Passive sync] ✓ In sync - drift within threshold');\r\n      }\r\n    } catch (err) {\r\n      console.error('[Passive sync] Error:', err);\r\n      // Clean up expected events on error\r\n      this.expectedEvents.clear();\r\n    }\r\n  }\r\n}\r\n","// ui-manager.js - Manages UI components (preview videos)\r\n// Note: Keeping this simple for now, full extraction in future refactor\r\n\r\nexport class UIManager {\r\n  constructor() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos = new Map();\r\n    this.remoteStreams = new Map();\r\n    this.streamMonitorInterval = null;\r\n  }\r\n  \r\n  getRemoteVideos() {\r\n    return this.remoteVideos;\r\n  }\r\n  \r\n  getRemoteStreams() {\r\n    return this.remoteStreams;\r\n  }\r\n  \r\n  setLocalPreviewVideo(video) {\r\n    this.localPreviewVideo = video;\r\n  }\r\n  \r\n  getLocalPreviewVideo() {\r\n    return this.localPreviewVideo;\r\n  }\r\n  \r\n  setStreamMonitorInterval(interval) {\r\n    this.streamMonitorInterval = interval;\r\n  }\r\n  \r\n  getStreamMonitorInterval() {\r\n    return this.streamMonitorInterval;\r\n  }\r\n  \r\n  clearStreamMonitorInterval() {\r\n    if (this.streamMonitorInterval) {\r\n      clearInterval(this.streamMonitorInterval);\r\n      this.streamMonitorInterval = null;\r\n    }\r\n  }\r\n  \r\n  clearAll() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    this.clearStreamMonitorInterval();\r\n  }\r\n}\r\n","// url-sync.js - Manages URL monitoring and party state persistence\r\n// Note: Keeping this simple for now, full extraction in future refactor\r\n\r\nexport class URLSync {\r\n  constructor(stateManager) {\r\n    this.stateManager = stateManager;\r\n    this.urlMonitorInterval = null;\r\n    this.lastUrl = null;\r\n  }\r\n  \r\n  start() {\r\n    this.lastUrl = window.location.href;\r\n    // URL monitoring logic will be moved here in full extraction\r\n  }\r\n  \r\n  stop() {\r\n    if (this.urlMonitorInterval) {\r\n      clearInterval(this.urlMonitorInterval);\r\n      this.urlMonitorInterval = null;\r\n    }\r\n  }\r\n  \r\n  saveState() {\r\n    // Party state persistence logic will be moved here\r\n    const state = this.stateManager.getState();\r\n    if (state.partyActive) {\r\n      sessionStorage.setItem('toperparty_restore', JSON.stringify({\r\n        userId: state.userId,\r\n        roomId: state.roomId,\r\n        timestamp: Date.now()\r\n      }));\r\n    }\r\n  }\r\n  \r\n  clearState() {\r\n    sessionStorage.removeItem('toperparty_restore');\r\n  }\r\n  \r\n  getRestorationState() {\r\n    const stored = sessionStorage.getItem('toperparty_restore');\r\n    if (!stored) return null;\r\n    \r\n    try {\r\n      const state = JSON.parse(stored);\r\n      // Check if restoration state is recent (within 30 seconds)\r\n      if (Date.now() - state.timestamp < 30000) {\r\n        return state;\r\n      }\r\n    } catch (e) {\r\n      console.error('[toperparty] Failed to parse restoration state:', e);\r\n    }\r\n    \r\n    return null;\r\n  }\r\n}\r\n","// webrtc-manager.js - Manages WebRTC peer connections\r\n// Note: This is a large module that handles peer connections, signaling, and reconnection logic\r\n// For now, keeping the core WebRTC functionality in the main file to avoid breaking changes\r\n// TODO: Extract this properly in a future refactor\r\n\r\nexport class WebRTCManager {\r\n  constructor(stateManager) {\r\n    this.state = stateManager;\r\n    this.peerConnections = new Map();\r\n    this.reconnectionAttempts = new Map();\r\n    this.reconnectionTimeouts = new Map();\r\n    this.localStream = null;\r\n  }\r\n  \r\n  setLocalStream(stream) {\r\n    this.localStream = stream;\r\n  }\r\n  \r\n  getLocalStream() {\r\n    return this.localStream;\r\n  }\r\n  \r\n  getPeerConnections() {\r\n    return this.peerConnections;\r\n  }\r\n  \r\n  getReconnectionAttempts() {\r\n    return this.reconnectionAttempts;\r\n  }\r\n  \r\n  getReconnectionTimeouts() {\r\n    return this.reconnectionTimeouts;\r\n  }\r\n  \r\n  clearAll() {\r\n    // Close all peer connections\r\n    this.peerConnections.forEach((pc) => {\r\n      try { pc.close(); } catch (e) {}\r\n    });\r\n    this.peerConnections.clear();\r\n    \r\n    // Clear reconnection state\r\n    this.reconnectionTimeouts.forEach((timeoutHandle) => {\r\n      clearTimeout(timeoutHandle);\r\n    });\r\n    this.reconnectionTimeouts.clear();\r\n    this.reconnectionAttempts.clear();\r\n    \r\n    // Stop local stream\r\n    if (this.localStream) {\r\n      this.localStream.getTracks().forEach(track => track.stop());\r\n      this.localStream = null;\r\n    }\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// content-script.js - Modular version with ES6 imports\r\n\r\nimport { StateManager } from './modules/state-manager.js';\r\nimport { NetflixController } from './modules/netflix-controller.js';\r\nimport { SyncManager } from './modules/sync-manager.js';\r\nimport { WebRTCManager } from './modules/webrtc-manager.js';\r\nimport { UIManager } from './modules/ui-manager.js';\r\nimport { URLSync } from './modules/url-sync.js';\r\n\r\n// Initialize managers\r\nconst stateManager = new StateManager();\r\nconst netflixController = new NetflixController();\r\nconst syncManager = new SyncManager(stateManager, netflixController);\r\nconst webrtcManager = new WebRTCManager();\r\nconst uiManager = new UIManager();\r\nconst urlSync = new URLSync(stateManager);\r\n\r\n// WebRTC variables (keeping these in main file for now)\r\nlet localStream = null;\r\nconst peerConnections = webrtcManager.peerConnections;\r\nconst remoteVideos = uiManager.getRemoteVideos();\r\nconst remoteStreams = uiManager.getRemoteStreams();\r\nconst reconnectionAttempts = webrtcManager.reconnectionAttempts;\r\nconst reconnectionTimeouts = webrtcManager.reconnectionTimeouts;\r\n\r\n// Check if we need to restore party state after navigation\r\n(function checkRestorePartyState() {\r\n  const restorationState = urlSync.getRestorationState();\r\n  if (restorationState) {\r\n    console.log('Detected party state after navigation, will restore:', restorationState);\r\n    \r\n    // Clear the stored state\r\n    urlSync.clearState();\r\n    \r\n    // Set flag to prevent URL broadcast during restoration\r\n    stateManager.setRestoringFlag(true);\r\n    \r\n    // Notify background that we need to rejoin\r\n    setTimeout(function() {\r\n      chrome.runtime.sendMessage({\r\n        type: 'RESTORE_PARTY',\r\n        roomId: restorationState.roomId,\r\n        userId: restorationState.userId\r\n      });\r\n      \r\n      // Clear restoration flag after party is restored\r\n      setTimeout(function() {\r\n        stateManager.setRestoringFlag(false);\r\n        console.log('Party restoration complete, URL monitoring active');\r\n      }, 2000);\r\n    }, 1000); // Wait 1s for page to stabilize\r\n  }\r\n})();\r\n\r\n// Inject Netflix API access script into page context\r\nnetflixController.injectAPIBridge();\r\n\r\n// Find Netflix video player (fallback for monitoring)\r\nfunction getVideoElement() {\r\n  return document.querySelector('video');\r\n}\r\n\r\n// URL monitoring - check for navigation changes\r\nlet lastKnownUrl = window.location.href;\r\n\r\nfunction startUrlMonitoring() {\r\n  const state = stateManager.getState();\r\n  \r\n  // Save party state whenever URL is about to change (for hard navigations)\r\n  window.addEventListener('beforeunload', function savePartyStateBeforeUnload() {\r\n    if (state.partyActive && state.userId && state.roomId) {\r\n      urlSync.saveState();\r\n    }\r\n  });\r\n  \r\n  // Also monitor for soft navigations (client-side routing)\r\n  setInterval(function checkUrlChange() {\r\n    const currentUrl = window.location.href;\r\n    const state = stateManager.getState();\r\n    \r\n    // Check if URL changed and party is active (but not during restoration)\r\n    if (currentUrl !== lastKnownUrl && state.partyActive && !state.restoringPartyState) {\r\n      console.log('URL changed from', lastKnownUrl, 'to', currentUrl);\r\n      lastKnownUrl = currentUrl;\r\n      \r\n      // Broadcast URL change to other clients\r\n      stateManager.safeSendMessage({\r\n        type: 'URL_CHANGE',\r\n        url: currentUrl\r\n      });\r\n    } else if (!state.restoringPartyState) {\r\n      // Silently update lastKnownUrl if we're not in restoration mode\r\n      lastKnownUrl = currentUrl;\r\n    }\r\n  }, 500); // Check every 500ms\r\n}\r\n\r\nfunction stopUrlMonitoring() {\r\n  lastKnownUrl = window.location.href;\r\n  urlSync.stop();\r\n}\r\n\r\n// Listen for messages from background script\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  // Signaling messages forwarded from background\r\n  if (request.type === 'SIGNAL' && request.message) {\r\n    handleSignalingMessage(request.message).catch(err => console.error('Signal handling error:', err));\r\n    return; // no sendResponse needed\r\n  }\r\n  \r\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\r\n    // Get media stream for webcam/mic\r\n    navigator.mediaDevices.getUserMedia({\r\n      video: { width: { ideal: 640 }, height: { ideal: 480 } },\r\n      audio: true\r\n    })\r\n      .then((stream) => {\r\n        localStream = stream;\r\n        webrtcManager.setLocalStream(stream);\r\n        console.log('Media stream obtained in content script');\r\n        \r\n        // Monitor stream tracks for unexpected ending\r\n        stream.getTracks().forEach(function(track) {\r\n          console.log('Local stream track obtained:', track.kind, 'id=', track.id, 'readyState=', track.readyState);\r\n          track.onended = function() {\r\n            console.error('LOCAL STREAM TRACK ENDED UNEXPECTEDLY:', track.kind, 'id=', track.id);\r\n          };\r\n          track.onmute = function() {\r\n            console.warn('Local stream track muted:', track.kind);\r\n          };\r\n          track.onunmute = function() {\r\n            console.log('Local stream track unmuted:', track.kind);\r\n          };\r\n        });\r\n        \r\n        // Create or update local preview\r\n        attachLocalPreview(stream);\r\n        \r\n        // Start monitoring local stream health\r\n        startLocalStreamMonitor(stream);\r\n        \r\n        // add or replace tracks to any existing peer connections\r\n        peerConnections.forEach((pc) => {\r\n          try { stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream)); } catch (e) { console.warn('Error adding tracks to pc', e); }\r\n        });\r\n        sendResponse({ success: true, message: 'Media stream obtained' });\r\n      })\r\n      .catch((err) => {\r\n        console.error('Failed to get media stream:', err);\r\n        sendResponse({ success: false, error: err.message });\r\n      });\r\n    \r\n    return true; // Keep channel open for async response\r\n  }\r\n\r\n  if (request.type === 'PARTY_STARTED') {\r\n    stateManager.startParty(request.userId, request.roomId);\r\n    console.log('Party started! Room:', request.roomId, 'User:', request.userId);\r\n    \r\n    // Start monitoring URL changes\r\n    startUrlMonitoring();\r\n    \r\n    // Setup playback sync\r\n    syncManager.setup();\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'PARTY_STOPPED') {\r\n    stateManager.stopParty();\r\n    \r\n    // Stop URL monitoring\r\n    stopUrlMonitoring();\r\n    \r\n    // Teardown sync\r\n    syncManager.teardown();\r\n    \r\n    // Stop stream monitor\r\n    stopLocalStreamMonitor();\r\n    \r\n    // Stop media stream\r\n    if (localStream) {\r\n      localStream.getTracks().forEach(track => track.stop());\r\n      localStream = null;\r\n      webrtcManager.setLocalStream(null);\r\n    }\r\n    \r\n    // Remove local preview UI\r\n    removeLocalPreview();\r\n    \r\n    // Remove injected controls\r\n    removeInjectedControls();\r\n    \r\n    // Clear all reconnection attempts and timeouts\r\n    reconnectionTimeouts.forEach((timeoutHandle) => {\r\n      clearTimeout(timeoutHandle);\r\n    });\r\n    reconnectionTimeouts.clear();\r\n    reconnectionAttempts.clear();\r\n    \r\n    // Close and clear peer connections\r\n    try {\r\n      peerConnections.forEach((pc) => {\r\n        try { pc.close(); } catch (e) {}\r\n      });\r\n      peerConnections.clear();\r\n    } catch (e) {}\r\n    \r\n    // Remove remote video elements\r\n    try {\r\n      remoteVideos.forEach((v, id) => removeRemoteVideo(id));\r\n    } catch (e) {}\r\n    \r\n    console.log('Party stopped');\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\r\n    syncManager.handlePlaybackControl(request.control, request.fromUserId);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_SYNC_PLAYBACK') {\r\n    syncManager.handlePassiveSync(request.currentTime, request.isPlaying, request.fromUserId, request.timestamp);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_SEEK') {\r\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_URL_CHANGE') {\r\n    console.log('Applying URL change from remote user:', request.url, 'from user:', request.fromUserId);\r\n    \r\n    // Save party state before navigation so we can restore after reload\r\n    const state = stateManager.getState();\r\n    if (state.partyActive && state.userId && state.roomId) {\r\n      urlSync.saveState();\r\n      console.log('Saved party state before navigation');\r\n    }\r\n    \r\n    // Always use hard navigation to ensure Netflix properly loads the new video\r\n    // This will cause a page reload, but state will be restored automatically\r\n    window.location.href = request.url;\r\n    \r\n    sendResponse({ success: true });\r\n  }\r\n});\r\n\r\n// --- UI Functions (kept in main file for now) ---\r\n\r\nfunction removeInjectedControls() {\r\n  const controls = document.getElementById('netflix-party-controls');\r\n  if (controls) {\r\n    controls.remove();\r\n  }\r\n}\r\n\r\nfunction attachLocalPreview(stream) {\r\n  let localPreviewVideo = uiManager.getLocalPreviewVideo();\r\n  \r\n  // Remove existing preview if any\r\n  if (localPreviewVideo) {\r\n    try {\r\n      if (localPreviewVideo.srcObject) {\r\n        localPreviewVideo.srcObject = null;\r\n      }\r\n    } catch (e) {}\r\n    localPreviewVideo.remove();\r\n    localPreviewVideo = null;\r\n  }\r\n\r\n  // Create new video element for local preview\r\n  const v = document.createElement('video');\r\n  v.id = 'toperparty-local-preview';\r\n  v.autoplay = true;\r\n  v.muted = true; // Always mute local preview to avoid feedback\r\n  v.playsInline = true;\r\n  v.style.position = 'fixed';\r\n  v.style.bottom = '20px';\r\n  v.style.left = '20px';\r\n  v.style.width = '240px';\r\n  v.style.height = '160px';\r\n  v.style.zIndex = 10001;\r\n  v.style.border = '2px solid #e50914';\r\n  v.style.borderRadius = '4px';\r\n  v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\r\n\r\n  try {\r\n    v.srcObject = stream;\r\n  } catch (e) {\r\n    v.src = URL.createObjectURL(stream);\r\n  }\r\n\r\n  document.body.appendChild(v);\r\n  uiManager.setLocalPreviewVideo(v);\r\n\r\n  v.play().catch(function(err) {\r\n    console.warn('Local preview play() failed (this is usually fine):', err);\r\n  });\r\n}\r\n\r\nfunction removeLocalPreview() {\r\n  const localPreviewVideo = uiManager.getLocalPreviewVideo();\r\n  if (localPreviewVideo) {\r\n    try {\r\n      // Stop the tracks managed by this video's srcObject (only if we own them)\r\n      if (localPreviewVideo.srcObject) {\r\n        localPreviewVideo.srcObject.getTracks().forEach(function(track) {\r\n          track.stop();\r\n        });\r\n        localPreviewVideo.srcObject = null;\r\n      }\r\n    } catch (e) {\r\n      console.warn('Error stopping local preview tracks:', e);\r\n    }\r\n    localPreviewVideo.remove();\r\n    uiManager.setLocalPreviewVideo(null);\r\n  }\r\n}\r\n\r\nfunction startLocalStreamMonitor(stream) {\r\n  uiManager.clearStreamMonitorInterval();\r\n  \r\n  const interval = setInterval(function monitorLocalStream() {\r\n    if (!stream) {\r\n      console.warn('Local stream is null, stopping monitor');\r\n      uiManager.clearStreamMonitorInterval();\r\n      return;\r\n    }\r\n\r\n    const tracks = stream.getTracks();\r\n    if (tracks.length === 0) {\r\n      console.warn('Local stream has no tracks');\r\n      uiManager.clearStreamMonitorInterval();\r\n      return;\r\n    }\r\n\r\n    let allActive = true;\r\n    tracks.forEach(function(track) {\r\n      if (track.readyState !== 'live') {\r\n        console.error('Local stream track not live:', track.kind, 'readyState=', track.readyState);\r\n        allActive = false;\r\n      }\r\n    });\r\n\r\n    if (!allActive) {\r\n      console.warn('Some local stream tracks are not active - may need to restart stream');\r\n    }\r\n  }, 5000); // Check every 5 seconds\r\n  \r\n  uiManager.setStreamMonitorInterval(interval);\r\n}\r\n\r\nfunction stopLocalStreamMonitor() {\r\n  uiManager.clearStreamMonitorInterval();\r\n}\r\n\r\nfunction addOrReplaceTrack(pc, track, stream) {\r\n  const senders = pc.getSenders();\r\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\r\n  if (existingSender) {\r\n    existingSender.replaceTrack(track).catch(e => console.warn('Error replacing track', e));\r\n  } else {\r\n    try {\r\n      pc.addTrack(track, stream);\r\n    } catch (e) {\r\n      console.warn('Error adding track', e);\r\n    }\r\n  }\r\n}\r\n\r\n// --- WebRTC signaling helpers ---\r\n\r\nfunction sendSignal(message) {\r\n  stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function(resp) {\r\n    // optionally handle response\r\n  });\r\n}\r\n\r\nasync function handleSignalingMessage(message) {\r\n  if (!message || !message.type) return;\r\n  const type = message.type;\r\n  const from = message.userId || message.from;\r\n  const to = message.to;\r\n  const state = stateManager.getState();\r\n\r\n  // Ignore messages not for us (if addressed)\r\n  if (to && to !== state.userId) return;\r\n\r\n  if (type === 'JOIN' && from && from !== state.userId) {\r\n    // Another user joined the room — initiate P2P if we have local media\r\n    if (!peerConnections.has(from)) {\r\n      try {\r\n        const pc = createPeerConnection(from);\r\n        peerConnections.set(from, pc);\r\n        if (localStream) {\r\n          localStream.getTracks().forEach(t => addOrReplaceTrack(pc, t, localStream));\r\n        }\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n        sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('Error handling JOIN and creating offer:', err);\r\n        peerConnections.delete(from);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (type === 'OFFER' && message.offer && from && from !== state.userId) {\r\n    // Received an offer from a peer\r\n    let pc = peerConnections.get(from);\r\n    \r\n    // If connection exists, check if we need to recreate it\r\n    if (pc) {\r\n      const pcState = pc.signalingState;\r\n      // Close and recreate if in any non-stable, non-closed state\r\n      // OR if stable (renegotiation scenario - safer to recreate)\r\n      if (pcState !== 'closed') {\r\n        console.log('[WebRTC] Received new offer while in state:', pcState, '- recreating connection for', from);\r\n        try {\r\n          pc.close();\r\n        } catch (e) {}\r\n        peerConnections.delete(from);\r\n        pc = null;\r\n      }\r\n    }\r\n\r\n    if (!pc) {\r\n      pc = createPeerConnection(from);\r\n      peerConnections.set(from, pc);\r\n    }\r\n\r\n    try {\r\n      await pc.setRemoteDescription(new RTCSessionDescription(message.offer));\r\n      if (localStream) {\r\n        localStream.getTracks().forEach(t => addOrReplaceTrack(pc, t, localStream));\r\n      }\r\n      const answer = await pc.createAnswer();\r\n      await pc.setLocalDescription(answer);\r\n      sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\r\n    } catch (err) {\r\n      console.error('Error handling offer:', err);\r\n      // Clean up failed connection\r\n      peerConnections.delete(from);\r\n      try { pc.close(); } catch (e) {}\r\n    }\r\n    return;\r\n  }  if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\r\n    const pc = peerConnections.get(from);\r\n    if (pc) {\r\n      try {\r\n        // Check if we're expecting an answer\r\n        if (pc.signalingState === 'have-local-offer') {\r\n          await pc.setRemoteDescription(new RTCSessionDescription(message.answer));\r\n        } else {\r\n          console.warn('Received answer in unexpected state:', pc.signalingState);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error handling answer:', err);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\r\n    const pc = peerConnections.get(from);\r\n    if (pc) {\r\n      try {\r\n        await pc.addIceCandidate(new RTCIceCandidate(message.candidate));\r\n      } catch (err) {\r\n        console.warn('Error adding received ICE candidate', err);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (type === 'LEAVE' && from) {\r\n    // Peer left\r\n    const pc = peerConnections.get(from);\r\n    if (pc) {\r\n      pc.close();\r\n      peerConnections.delete(from);\r\n    }\r\n    removeRemoteVideo(from);\r\n    return;\r\n  }\r\n}\r\n\r\n// Attempt to reconnect to a peer\r\nasync function attemptReconnection(peerId) {\r\n  const state = stateManager.getState();\r\n  if (!state.partyActive || !state.userId || !state.roomId) {\r\n    console.log('Cannot reconnect - party not active');\r\n    return;\r\n  }\r\n\r\n  const attempts = reconnectionAttempts.get(peerId) || 0;\r\n  const maxAttempts = 5;\r\n  const backoffDelay = Math.min(1000 * Math.pow(2, attempts), 30000); // Exponential backoff, max 30s\r\n\r\n  if (attempts >= maxAttempts) {\r\n    console.log('Max reconnection attempts reached for', peerId);\r\n    reconnectionAttempts.delete(peerId);\r\n    reconnectionTimeouts.delete(peerId);\r\n    return;\r\n  }\r\n\r\n  console.log(`Attempting reconnection to ${peerId} (attempt ${attempts + 1}/${maxAttempts}) in ${backoffDelay}ms`);\r\n  reconnectionAttempts.set(peerId, attempts + 1);\r\n\r\n  // Clear any existing timeout for this peer\r\n  const existingTimeout = reconnectionTimeouts.get(peerId);\r\n  if (existingTimeout) {\r\n    clearTimeout(existingTimeout);\r\n  }\r\n\r\n  // Schedule reconnection attempt\r\n  const timeoutHandle = setTimeout(async function() {\r\n    console.log('Reconnecting to', peerId);\r\n    \r\n    // Remove old connection\r\n    const oldPc = peerConnections.get(peerId);\r\n    if (oldPc) {\r\n      try {\r\n        oldPc.close();\r\n      } catch (e) {\r\n        console.warn('Error closing old peer connection:', e);\r\n      }\r\n      peerConnections.delete(peerId);\r\n    }\r\n    \r\n    // Create new connection and send offer\r\n    try {\r\n      const pc = createPeerConnection(peerId);\r\n      peerConnections.set(peerId, pc);\r\n      \r\n      if (localStream) {\r\n        localStream.getTracks().forEach(t => addOrReplaceTrack(pc, t, localStream));\r\n      }\r\n      \r\n      const offer = await pc.createOffer();\r\n      await pc.setLocalDescription(offer);\r\n      sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\r\n      \r\n      console.log('Reconnection offer sent to', peerId);\r\n    } catch (err) {\r\n      console.error('Failed to create reconnection offer:', err);\r\n      // Retry with next attempt\r\n      attemptReconnection(peerId);\r\n    }\r\n  }, backoffDelay);\r\n\r\n  reconnectionTimeouts.set(peerId, timeoutHandle);\r\n}\r\n\r\n// Clear reconnection state for a peer (called on successful connection)\r\nfunction clearReconnectionState(peerId) {\r\n  reconnectionAttempts.delete(peerId);\r\n  const timeoutHandle = reconnectionTimeouts.get(peerId);\r\n  if (timeoutHandle) {\r\n    clearTimeout(timeoutHandle);\r\n    reconnectionTimeouts.delete(peerId);\r\n  }\r\n}\r\n\r\nfunction createPeerConnection(peerId) {\r\n  const state = stateManager.getState();\r\n  const pc = new RTCPeerConnection({\r\n    iceServers: [\r\n      { urls: ['stun:stun.l.google.com:19302'] },\r\n      { urls: ['stun:stun1.l.google.com:19302'] }\r\n    ]\r\n  });\r\n\r\n  pc.onicecandidate = (event) => {\r\n    if (event.candidate) {\r\n      sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\r\n    }\r\n  };\r\n\r\n  pc.ontrack = (event) => {\r\n    console.log('Received remote track from', peerId, 'track=', event.track && event.track.kind);\r\n    // Some browsers populate event.streams[0], others deliver individual tracks.\r\n    let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\r\n    if (!stream) {\r\n      stream = new MediaStream();\r\n      remoteStreams.set(peerId, stream);\r\n    }\r\n    if (event.track) {\r\n      try { \r\n        stream.addTrack(event.track);\r\n        // Monitor track state\r\n        event.track.onended = function() {\r\n          console.warn('Remote track ended from', peerId, 'kind=', event.track.kind);\r\n        };\r\n        console.log('Added remote track to stream, kind=', event.track.kind, 'readyState=', event.track.readyState);\r\n      } catch (e) { \r\n        console.warn('Failed to add remote track to stream', e); \r\n      }\r\n    }\r\n    // Only create the video element once, not on every track\r\n    if (!remoteVideos.has(peerId)) {\r\n      addRemoteVideo(peerId, stream);\r\n    }\r\n  };\r\n\r\n  pc.onconnectionstatechange = () => {\r\n    console.log('PC state', pc.connectionState, 'for', peerId);\r\n    \r\n    if (pc.connectionState === 'connected') {\r\n      // Connection successful - clear any reconnection attempts\r\n      console.log('Connection established successfully with', peerId);\r\n      clearReconnectionState(peerId);\r\n    } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {\r\n      // Connection lost - attempt reconnection\r\n      console.warn('Connection', pc.connectionState, 'with', peerId, '- attempting reconnection');\r\n      peerConnections.delete(peerId);\r\n      removeRemoteVideo(peerId);\r\n      \r\n      // Attempt to reconnect\r\n      attemptReconnection(peerId);\r\n    } else if (pc.connectionState === 'closed') {\r\n      // Connection intentionally closed - clean up without reconnecting\r\n      console.log('Connection closed with', peerId);\r\n      peerConnections.delete(peerId);\r\n      removeRemoteVideo(peerId);\r\n      clearReconnectionState(peerId);\r\n    }\r\n  };\r\n\r\n  return pc;\r\n}\r\n\r\nfunction addRemoteVideo(peerId, stream) {\r\n  removeRemoteVideo(peerId);\r\n  const v = document.createElement('video');\r\n  v.id = 'toperparty-remote-' + peerId;\r\n  v.autoplay = true;\r\n  v.playsInline = true;\r\n  // Start muted to allow autoplay, then unmute after playing\r\n  v.muted = true;\r\n  v.style.position = 'fixed';\r\n  v.style.bottom = '20px';\r\n  v.style.right = (20 + (remoteVideos.size * 180)) + 'px';\r\n  v.style.width = '240px';\r\n  v.style.height = '160px';\r\n  v.style.zIndex = 10001;\r\n  v.style.border = '2px solid #00aaff';\r\n  v.style.borderRadius = '4px';\r\n  \r\n  // Log audio tracks for debugging\r\n  const audioTracks = stream.getAudioTracks();\r\n  console.log('Remote stream audio tracks:', audioTracks.length);\r\n  audioTracks.forEach(function(track) {\r\n    console.log('Audio track:', track.id, 'enabled=', track.enabled, 'readyState=', track.readyState);\r\n  });\r\n  \r\n  try {\r\n    v.srcObject = stream;\r\n  } catch (e) {\r\n    v.src = URL.createObjectURL(stream);\r\n  }\r\n  document.body.appendChild(v);\r\n  remoteVideos.set(peerId, v);\r\n  \r\n  try {\r\n    v.play().then(function() {\r\n      // Unmute after successful play to enable audio\r\n      console.log('Remote video playing, unmuting audio for', peerId);\r\n      v.muted = false;\r\n      v.volume = 1.0;\r\n    }).catch(function(err) {\r\n      console.warn('Remote video play() failed:', err);\r\n      // Try unmuting anyway\r\n      v.muted = false;\r\n    });\r\n  } catch (e) {\r\n    console.error('Exception calling play():', e);\r\n  }\r\n}\r\n\r\nfunction removeRemoteVideo(peerId) {\r\n  const v = remoteVideos.get(peerId);\r\n  if (v) {\r\n    try {\r\n      // Do NOT stop remote tracks - they are managed by the sender\r\n      // Just clear the srcObject to release the reference\r\n      if (v.srcObject) {\r\n        v.srcObject = null;\r\n      }\r\n    } catch (e) {}\r\n    v.remove();\r\n    remoteVideos.delete(peerId);\r\n  }\r\n  // Also clean up the stream reference\r\n  remoteStreams.delete(peerId);\r\n}\r\n"],"names":[],"ignoreList":[],"sourceRoot":""}