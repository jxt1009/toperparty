{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://toperparty/./chrome-extension/content-script.js","webpack://toperparty/./chrome-extension/modules/state-manager.js","webpack://toperparty/./chrome-extension/modules/netflix-controller.js","webpack://toperparty/./chrome-extension/modules/sync-manager.js","webpack://toperparty/./chrome-extension/modules/webrtc-manager.js","webpack://toperparty/./chrome-extension/modules/ui-manager.js","webpack://toperparty/./chrome-extension/modules/url-sync.js"],"sourcesContent":["// content-script.js - Modular version with ES6 imports\r\n\r\nimport { StateManager } from './modules/state-manager.js';\r\nimport { NetflixController } from './modules/netflix-controller.js';\r\nimport { SyncManager } from './modules/sync-manager.js';\r\nimport { WebRTCManager } from './modules/webrtc-manager.js';\r\nimport { UIManager } from './modules/ui-manager.js';\r\nimport { URLSync } from './modules/url-sync.js';\r\n\r\n// Initialize managers\r\nconst stateManager = new StateManager();\r\nconst netflixController = new NetflixController();\r\nconst syncManager = new SyncManager(stateManager, netflixController);\r\nconst webrtcManager = new WebRTCManager();\r\nconst uiManager = new UIManager();\r\nconst urlSync = new URLSync(stateManager);\r\n\r\n// WebRTC variables (keeping these in main file for now)\r\nlet localStream = null;\r\nconst peerConnections = webrtcManager.peerConnections;\r\nconst remoteVideos = uiManager.getRemoteVideos();\r\nconst remoteStreams = uiManager.getRemoteStreams();\r\nconst reconnectionAttempts = webrtcManager.reconnectionAttempts;\r\nconst reconnectionTimeouts = webrtcManager.reconnectionTimeouts;\r\n\r\n// Check if we need to restore party state after navigation\r\n(function checkRestorePartyState() {\r\n  const restorationState = urlSync.getRestorationState();\r\n  if (restorationState) {\r\n    console.log('Detected party state after navigation, will restore:', restorationState);\r\n    \r\n    // Clear the stored state\r\n    urlSync.clearState();\r\n    \r\n    // Set flag to prevent URL broadcast during restoration\r\n    stateManager.setRestoringFlag(true);\r\n    \r\n    // Notify background that we need to rejoin\r\n    setTimeout(function() {\r\n      chrome.runtime.sendMessage({\r\n        type: 'RESTORE_PARTY',\r\n        roomId: restorationState.roomId,\r\n        userId: restorationState.userId\r\n      });\r\n      \r\n      // Clear restoration flag after party is restored\r\n      setTimeout(function() {\r\n        stateManager.setRestoringFlag(false);\r\n        console.log('Party restoration complete, URL monitoring active');\r\n      }, 2000);\r\n    }, 1000); // Wait 1s for page to stabilize\r\n  }\r\n})();\r\n\r\n// Inject Netflix API access script into page context\r\nnetflixController.injectAPIBridge();\r\n\r\n// Find Netflix video player (fallback for monitoring)\r\nfunction getVideoElement() {\r\n  return document.querySelector('video');\r\n}\r\n\r\n// URL monitoring - check for navigation changes\r\nlet lastKnownUrl = window.location.href;\r\n\r\nfunction startUrlMonitoring() {\r\n  const state = stateManager.getState();\r\n  \r\n  // Save party state whenever URL is about to change (for hard navigations)\r\n  window.addEventListener('beforeunload', function savePartyStateBeforeUnload() {\r\n    if (state.partyActive && state.userId && state.roomId) {\r\n      urlSync.saveState();\r\n    }\r\n  });\r\n  \r\n  // Also monitor for soft navigations (client-side routing)\r\n  setInterval(function checkUrlChange() {\r\n    const currentUrl = window.location.href;\r\n    const state = stateManager.getState();\r\n    \r\n    // Check if URL changed and party is active (but not during restoration)\r\n    if (currentUrl !== lastKnownUrl && state.partyActive && !state.restoringPartyState) {\r\n      console.log('URL changed from', lastKnownUrl, 'to', currentUrl);\r\n      lastKnownUrl = currentUrl;\r\n      \r\n      // Broadcast URL change to other clients\r\n      stateManager.safeSendMessage({\r\n        type: 'URL_CHANGE',\r\n        url: currentUrl\r\n      });\r\n    } else if (!state.restoringPartyState) {\r\n      // Silently update lastKnownUrl if we're not in restoration mode\r\n      lastKnownUrl = currentUrl;\r\n    }\r\n  }, 500); // Check every 500ms\r\n}\r\n\r\nfunction stopUrlMonitoring() {\r\n  lastKnownUrl = window.location.href;\r\n  urlSync.stop();\r\n}\r\n\r\n// Listen for messages from background script\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  // Signaling messages forwarded from background\r\n  if (request.type === 'SIGNAL' && request.message) {\r\n    handleSignalingMessage(request.message).catch(err => console.error('Signal handling error:', err));\r\n    return; // no sendResponse needed\r\n  }\r\n  \r\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\r\n    // Get media stream for webcam/mic\r\n    navigator.mediaDevices.getUserMedia({\r\n      video: { width: { ideal: 640 }, height: { ideal: 480 } },\r\n      audio: true\r\n    })\r\n      .then((stream) => {\r\n        localStream = stream;\r\n        webrtcManager.setLocalStream(stream);\r\n        console.log('Media stream obtained in content script');\r\n        \r\n        // Monitor stream tracks for unexpected ending\r\n        stream.getTracks().forEach(function(track) {\r\n          console.log('Local stream track obtained:', track.kind, 'id=', track.id, 'readyState=', track.readyState);\r\n          track.onended = function() {\r\n            console.error('LOCAL STREAM TRACK ENDED UNEXPECTEDLY:', track.kind, 'id=', track.id);\r\n          };\r\n          track.onmute = function() {\r\n            console.warn('Local stream track muted:', track.kind);\r\n          };\r\n          track.onunmute = function() {\r\n            console.log('Local stream track unmuted:', track.kind);\r\n          };\r\n        });\r\n        \r\n        // Create or update local preview\r\n        attachLocalPreview(stream);\r\n        \r\n        // Start monitoring local stream health\r\n        startLocalStreamMonitor(stream);\r\n        \r\n        // add or replace tracks to any existing peer connections\r\n        peerConnections.forEach((pc) => {\r\n          try { stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream)); } catch (e) { console.warn('Error adding tracks to pc', e); }\r\n        });\r\n        sendResponse({ success: true, message: 'Media stream obtained' });\r\n      })\r\n      .catch((err) => {\r\n        console.error('Failed to get media stream:', err);\r\n        sendResponse({ success: false, error: err.message });\r\n      });\r\n    \r\n    return true; // Keep channel open for async response\r\n  }\r\n\r\n  if (request.type === 'PARTY_STARTED') {\r\n    stateManager.startParty(request.userId, request.roomId);\r\n    console.log('Party started! Room:', request.roomId, 'User:', request.userId);\r\n    \r\n    // Start monitoring URL changes\r\n    startUrlMonitoring();\r\n    \r\n    // Setup playback sync\r\n    syncManager.setup();\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'PARTY_STOPPED') {\r\n    stateManager.stopParty();\r\n    \r\n    // Stop URL monitoring\r\n    stopUrlMonitoring();\r\n    \r\n    // Teardown sync\r\n    syncManager.teardown();\r\n    \r\n    // Stop stream monitor\r\n    stopLocalStreamMonitor();\r\n    \r\n    // Stop media stream\r\n    if (localStream) {\r\n      localStream.getTracks().forEach(track => track.stop());\r\n      localStream = null;\r\n      webrtcManager.setLocalStream(null);\r\n    }\r\n    \r\n    // Remove local preview UI\r\n    removeLocalPreview();\r\n    \r\n    // Remove injected controls\r\n    removeInjectedControls();\r\n    \r\n    // Clear all reconnection attempts and timeouts\r\n    reconnectionTimeouts.forEach((timeoutHandle) => {\r\n      clearTimeout(timeoutHandle);\r\n    });\r\n    reconnectionTimeouts.clear();\r\n    reconnectionAttempts.clear();\r\n    \r\n    // Close and clear peer connections\r\n    try {\r\n      peerConnections.forEach((pc) => {\r\n        try { pc.close(); } catch (e) {}\r\n      });\r\n      peerConnections.clear();\r\n    } catch (e) {}\r\n    \r\n    // Remove remote video elements\r\n    try {\r\n      remoteVideos.forEach((v, id) => removeRemoteVideo(id));\r\n    } catch (e) {}\r\n    \r\n    console.log('Party stopped');\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\r\n    syncManager.handlePlaybackControl(request);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_SYNC_PLAYBACK') {\r\n    syncManager.handlePassiveSync(request);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_SEEK') {\r\n    syncManager.handleSeek(request);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_URL_CHANGE') {\r\n    console.log('Applying URL change from remote user:', request.url, 'from user:', request.fromUserId);\r\n    \r\n    // Save party state before navigation so we can restore after reload\r\n    const state = stateManager.getState();\r\n    if (state.partyActive && state.userId && state.roomId) {\r\n      urlSync.saveState();\r\n      console.log('Saved party state before navigation');\r\n    }\r\n    \r\n    // Always use hard navigation to ensure Netflix properly loads the new video\r\n    // This will cause a page reload, but state will be restored automatically\r\n    window.location.href = request.url;\r\n    \r\n    sendResponse({ success: true });\r\n  }\r\n});\r\n\r\n// --- UI Functions (kept in main file for now) ---\r\n\r\nfunction removeInjectedControls() {\r\n  const controls = document.getElementById('netflix-party-controls');\r\n  if (controls) {\r\n    controls.remove();\r\n  }\r\n}\r\n\r\nfunction attachLocalPreview(stream) {\r\n  let localPreviewVideo = uiManager.getLocalPreviewVideo();\r\n  \r\n  // Remove existing preview if any\r\n  if (localPreviewVideo) {\r\n    try {\r\n      if (localPreviewVideo.srcObject) {\r\n        localPreviewVideo.srcObject = null;\r\n      }\r\n    } catch (e) {}\r\n    localPreviewVideo.remove();\r\n    localPreviewVideo = null;\r\n  }\r\n\r\n  // Create new video element for local preview\r\n  const v = document.createElement('video');\r\n  v.id = 'toperparty-local-preview';\r\n  v.autoplay = true;\r\n  v.muted = true; // Always mute local preview to avoid feedback\r\n  v.playsInline = true;\r\n  v.style.position = 'fixed';\r\n  v.style.bottom = '20px';\r\n  v.style.left = '20px';\r\n  v.style.width = '240px';\r\n  v.style.height = '160px';\r\n  v.style.zIndex = 10001;\r\n  v.style.border = '2px solid #e50914';\r\n  v.style.borderRadius = '4px';\r\n  v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\r\n\r\n  try {\r\n    v.srcObject = stream;\r\n  } catch (e) {\r\n    v.src = URL.createObjectURL(stream);\r\n  }\r\n\r\n  document.body.appendChild(v);\r\n  uiManager.setLocalPreviewVideo(v);\r\n\r\n  v.play().catch(function(err) {\r\n    console.warn('Local preview play() failed (this is usually fine):', err);\r\n  });\r\n}\r\n\r\nfunction removeLocalPreview() {\r\n  const localPreviewVideo = uiManager.getLocalPreviewVideo();\r\n  if (localPreviewVideo) {\r\n    try {\r\n      // Stop the tracks managed by this video's srcObject (only if we own them)\r\n      if (localPreviewVideo.srcObject) {\r\n        localPreviewVideo.srcObject.getTracks().forEach(function(track) {\r\n          track.stop();\r\n        });\r\n        localPreviewVideo.srcObject = null;\r\n      }\r\n    } catch (e) {\r\n      console.warn('Error stopping local preview tracks:', e);\r\n    }\r\n    localPreviewVideo.remove();\r\n    uiManager.setLocalPreviewVideo(null);\r\n  }\r\n}\r\n\r\nfunction startLocalStreamMonitor(stream) {\r\n  uiManager.clearStreamMonitorInterval();\r\n  \r\n  const interval = setInterval(function monitorLocalStream() {\r\n    if (!stream) {\r\n      console.warn('Local stream is null, stopping monitor');\r\n      uiManager.clearStreamMonitorInterval();\r\n      return;\r\n    }\r\n\r\n    const tracks = stream.getTracks();\r\n    if (tracks.length === 0) {\r\n      console.warn('Local stream has no tracks');\r\n      uiManager.clearStreamMonitorInterval();\r\n      return;\r\n    }\r\n\r\n    let allActive = true;\r\n    tracks.forEach(function(track) {\r\n      if (track.readyState !== 'live') {\r\n        console.error('Local stream track not live:', track.kind, 'readyState=', track.readyState);\r\n        allActive = false;\r\n      }\r\n    });\r\n\r\n    if (!allActive) {\r\n      console.warn('Some local stream tracks are not active - may need to restart stream');\r\n    }\r\n  }, 5000); // Check every 5 seconds\r\n  \r\n  uiManager.setStreamMonitorInterval(interval);\r\n}\r\n\r\nfunction stopLocalStreamMonitor() {\r\n  uiManager.clearStreamMonitorInterval();\r\n}\r\n\r\nfunction addOrReplaceTrack(pc, track, stream) {\r\n  const senders = pc.getSenders();\r\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\r\n  if (existingSender) {\r\n    existingSender.replaceTrack(track).catch(e => console.warn('Error replacing track', e));\r\n  } else {\r\n    try {\r\n      pc.addTrack(track, stream);\r\n    } catch (e) {\r\n      console.warn('Error adding track', e);\r\n    }\r\n  }\r\n}\r\n\r\n// --- WebRTC signaling helpers ---\r\n\r\nfunction sendSignal(message) {\r\n  stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function(resp) {\r\n    // optionally handle response\r\n  });\r\n}\r\n\r\nasync function handleSignalingMessage(message) {\r\n  if (!message || !message.type) return;\r\n  const type = message.type;\r\n  const from = message.userId || message.from;\r\n  const to = message.to;\r\n  const state = stateManager.getState();\r\n\r\n  // Ignore messages not for us (if addressed)\r\n  if (to && to !== state.userId) return;\r\n\r\n  if (type === 'JOIN' && from && from !== state.userId) {\r\n    // Another user joined the room â€” initiate P2P if we have local media\r\n    if (!peerConnections.has(from)) {\r\n      try {\r\n        const pc = createPeerConnection(from);\r\n        peerConnections.set(from, pc);\r\n        if (localStream) {\r\n          localStream.getTracks().forEach(t => addOrReplaceTrack(pc, t, localStream));\r\n        }\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n        sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('Error handling JOIN and creating offer:', err);\r\n        peerConnections.delete(from);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (type === 'OFFER' && message.offer && from && from !== state.userId) {\r\n    // Received an offer from a peer\r\n    let pc = peerConnections.get(from);\r\n    \r\n    // If connection exists and is not in a good state for receiving an offer, close and recreate\r\n    if (pc) {\r\n      const pcState = pc.signalingState;\r\n      if (pcState !== 'stable' && pcState !== 'closed') {\r\n        console.warn('Received offer while in signaling state:', pcState, '- recreating connection');\r\n        try {\r\n          pc.close();\r\n        } catch (e) {}\r\n        peerConnections.delete(from);\r\n        pc = null;\r\n      }\r\n    }\r\n    \r\n    if (!pc) {\r\n      pc = createPeerConnection(from);\r\n      peerConnections.set(from, pc);\r\n    }\r\n\r\n    try {\r\n      await pc.setRemoteDescription(new RTCSessionDescription(message.offer));\r\n      if (localStream) {\r\n        localStream.getTracks().forEach(t => addOrReplaceTrack(pc, t, localStream));\r\n      }\r\n      const answer = await pc.createAnswer();\r\n      await pc.setLocalDescription(answer);\r\n      sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\r\n    } catch (err) {\r\n      console.error('Error handling offer:', err);\r\n      // Clean up failed connection\r\n      peerConnections.delete(from);\r\n      try { pc.close(); } catch (e) {}\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\r\n    const pc = peerConnections.get(from);\r\n    if (pc) {\r\n      try {\r\n        // Check if we're expecting an answer\r\n        if (pc.signalingState === 'have-local-offer') {\r\n          await pc.setRemoteDescription(new RTCSessionDescription(message.answer));\r\n        } else {\r\n          console.warn('Received answer in unexpected state:', pc.signalingState);\r\n        }\r\n      } catch (err) {\r\n        console.error('Error handling answer:', err);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\r\n    const pc = peerConnections.get(from);\r\n    if (pc) {\r\n      try {\r\n        await pc.addIceCandidate(new RTCIceCandidate(message.candidate));\r\n      } catch (err) {\r\n        console.warn('Error adding received ICE candidate', err);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (type === 'LEAVE' && from) {\r\n    // Peer left\r\n    const pc = peerConnections.get(from);\r\n    if (pc) {\r\n      pc.close();\r\n      peerConnections.delete(from);\r\n    }\r\n    removeRemoteVideo(from);\r\n    return;\r\n  }\r\n}\r\n\r\n// Attempt to reconnect to a peer\r\nasync function attemptReconnection(peerId) {\r\n  const state = stateManager.getState();\r\n  if (!state.partyActive || !state.userId || !state.roomId) {\r\n    console.log('Cannot reconnect - party not active');\r\n    return;\r\n  }\r\n\r\n  const attempts = reconnectionAttempts.get(peerId) || 0;\r\n  const maxAttempts = 5;\r\n  const backoffDelay = Math.min(1000 * Math.pow(2, attempts), 30000); // Exponential backoff, max 30s\r\n\r\n  if (attempts >= maxAttempts) {\r\n    console.log('Max reconnection attempts reached for', peerId);\r\n    reconnectionAttempts.delete(peerId);\r\n    reconnectionTimeouts.delete(peerId);\r\n    return;\r\n  }\r\n\r\n  console.log(`Attempting reconnection to ${peerId} (attempt ${attempts + 1}/${maxAttempts}) in ${backoffDelay}ms`);\r\n  reconnectionAttempts.set(peerId, attempts + 1);\r\n\r\n  // Clear any existing timeout for this peer\r\n  const existingTimeout = reconnectionTimeouts.get(peerId);\r\n  if (existingTimeout) {\r\n    clearTimeout(existingTimeout);\r\n  }\r\n\r\n  // Schedule reconnection attempt\r\n  const timeoutHandle = setTimeout(async function() {\r\n    console.log('Reconnecting to', peerId);\r\n    \r\n    // Remove old connection\r\n    const oldPc = peerConnections.get(peerId);\r\n    if (oldPc) {\r\n      try {\r\n        oldPc.close();\r\n      } catch (e) {\r\n        console.warn('Error closing old peer connection:', e);\r\n      }\r\n      peerConnections.delete(peerId);\r\n    }\r\n    \r\n    // Create new connection and send offer\r\n    try {\r\n      const pc = createPeerConnection(peerId);\r\n      peerConnections.set(peerId, pc);\r\n      \r\n      if (localStream) {\r\n        localStream.getTracks().forEach(t => addOrReplaceTrack(pc, t, localStream));\r\n      }\r\n      \r\n      const offer = await pc.createOffer();\r\n      await pc.setLocalDescription(offer);\r\n      sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\r\n      \r\n      console.log('Reconnection offer sent to', peerId);\r\n    } catch (err) {\r\n      console.error('Failed to create reconnection offer:', err);\r\n      // Retry with next attempt\r\n      attemptReconnection(peerId);\r\n    }\r\n  }, backoffDelay);\r\n\r\n  reconnectionTimeouts.set(peerId, timeoutHandle);\r\n}\r\n\r\n// Clear reconnection state for a peer (called on successful connection)\r\nfunction clearReconnectionState(peerId) {\r\n  reconnectionAttempts.delete(peerId);\r\n  const timeoutHandle = reconnectionTimeouts.get(peerId);\r\n  if (timeoutHandle) {\r\n    clearTimeout(timeoutHandle);\r\n    reconnectionTimeouts.delete(peerId);\r\n  }\r\n}\r\n\r\nfunction createPeerConnection(peerId) {\r\n  const state = stateManager.getState();\r\n  const pc = new RTCPeerConnection({\r\n    iceServers: [\r\n      { urls: ['stun:stun.l.google.com:19302'] },\r\n      { urls: ['stun:stun1.l.google.com:19302'] }\r\n    ]\r\n  });\r\n\r\n  pc.onicecandidate = (event) => {\r\n    if (event.candidate) {\r\n      sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\r\n    }\r\n  };\r\n\r\n  pc.ontrack = (event) => {\r\n    console.log('Received remote track from', peerId, 'track=', event.track && event.track.kind);\r\n    // Some browsers populate event.streams[0], others deliver individual tracks.\r\n    let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\r\n    if (!stream) {\r\n      stream = new MediaStream();\r\n      remoteStreams.set(peerId, stream);\r\n    }\r\n    if (event.track) {\r\n      try { \r\n        stream.addTrack(event.track);\r\n        // Monitor track state\r\n        event.track.onended = function() {\r\n          console.warn('Remote track ended from', peerId, 'kind=', event.track.kind);\r\n        };\r\n        console.log('Added remote track to stream, kind=', event.track.kind, 'readyState=', event.track.readyState);\r\n      } catch (e) { \r\n        console.warn('Failed to add remote track to stream', e); \r\n      }\r\n    }\r\n    // Only create the video element once, not on every track\r\n    if (!remoteVideos.has(peerId)) {\r\n      addRemoteVideo(peerId, stream);\r\n    }\r\n  };\r\n\r\n  pc.onconnectionstatechange = () => {\r\n    console.log('PC state', pc.connectionState, 'for', peerId);\r\n    \r\n    if (pc.connectionState === 'connected') {\r\n      // Connection successful - clear any reconnection attempts\r\n      console.log('Connection established successfully with', peerId);\r\n      clearReconnectionState(peerId);\r\n    } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {\r\n      // Connection lost - attempt reconnection\r\n      console.warn('Connection', pc.connectionState, 'with', peerId, '- attempting reconnection');\r\n      peerConnections.delete(peerId);\r\n      removeRemoteVideo(peerId);\r\n      \r\n      // Attempt to reconnect\r\n      attemptReconnection(peerId);\r\n    } else if (pc.connectionState === 'closed') {\r\n      // Connection intentionally closed - clean up without reconnecting\r\n      console.log('Connection closed with', peerId);\r\n      peerConnections.delete(peerId);\r\n      removeRemoteVideo(peerId);\r\n      clearReconnectionState(peerId);\r\n    }\r\n  };\r\n\r\n  return pc;\r\n}\r\n\r\nfunction addRemoteVideo(peerId, stream) {\r\n  removeRemoteVideo(peerId);\r\n  const v = document.createElement('video');\r\n  v.id = 'toperparty-remote-' + peerId;\r\n  v.autoplay = true;\r\n  v.playsInline = true;\r\n  // Start muted to allow autoplay, then unmute after playing\r\n  v.muted = true;\r\n  v.style.position = 'fixed';\r\n  v.style.bottom = '20px';\r\n  v.style.right = (20 + (remoteVideos.size * 180)) + 'px';\r\n  v.style.width = '240px';\r\n  v.style.height = '160px';\r\n  v.style.zIndex = 10001;\r\n  v.style.border = '2px solid #00aaff';\r\n  v.style.borderRadius = '4px';\r\n  \r\n  // Log audio tracks for debugging\r\n  const audioTracks = stream.getAudioTracks();\r\n  console.log('Remote stream audio tracks:', audioTracks.length);\r\n  audioTracks.forEach(function(track) {\r\n    console.log('Audio track:', track.id, 'enabled=', track.enabled, 'readyState=', track.readyState);\r\n  });\r\n  \r\n  try {\r\n    v.srcObject = stream;\r\n  } catch (e) {\r\n    v.src = URL.createObjectURL(stream);\r\n  }\r\n  document.body.appendChild(v);\r\n  remoteVideos.set(peerId, v);\r\n  \r\n  try {\r\n    v.play().then(function() {\r\n      // Unmute after successful play to enable audio\r\n      console.log('Remote video playing, unmuting audio for', peerId);\r\n      v.muted = false;\r\n      v.volume = 1.0;\r\n    }).catch(function(err) {\r\n      console.warn('Remote video play() failed:', err);\r\n      // Try unmuting anyway\r\n      v.muted = false;\r\n    });\r\n  } catch (e) {\r\n    console.error('Exception calling play():', e);\r\n  }\r\n}\r\n\r\nfunction removeRemoteVideo(peerId) {\r\n  const v = remoteVideos.get(peerId);\r\n  if (v) {\r\n    try {\r\n      // Do NOT stop remote tracks - they are managed by the sender\r\n      // Just clear the srcObject to release the reference\r\n      if (v.srcObject) {\r\n        v.srcObject = null;\r\n      }\r\n    } catch (e) {}\r\n    v.remove();\r\n    remoteVideos.delete(peerId);\r\n  }\r\n  // Also clean up the stream reference\r\n  remoteStreams.delete(peerId);\r\n}\r\n","// state-manager.js - Manages party state and action tracking\r\n\r\nexport class StateManager {\r\n  constructor() {\r\n    // Party state\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    this.restoringPartyState = false;\r\n    \r\n    // Action tracking for echo prevention\r\n    this.lastLocalAction = { type: null, time: 0 };\r\n    this.lastRemoteAction = { type: null, time: 0 };\r\n  }\r\n  \r\n  // Party state management\r\n  startParty(userId, roomId) {\r\n    this.partyActive = true;\r\n    this.userId = userId;\r\n    this.roomId = roomId;\r\n    console.log('Party started! Room:', roomId, 'User:', userId);\r\n  }\r\n  \r\n  stopParty() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    this.lastLocalAction = { type: null, time: 0 };\r\n    this.lastRemoteAction = { type: null, time: 0 };\r\n    console.log('Party stopped');\r\n  }\r\n  \r\n  isActive() {\r\n    return this.partyActive;\r\n  }\r\n  \r\n  getUserId() {\r\n    return this.userId;\r\n  }\r\n  \r\n  getRoomId() {\r\n    return this.roomId;\r\n  }\r\n  \r\n  getState() {\r\n    return {\r\n      partyActive: this.partyActive,\r\n      userId: this.userId,\r\n      roomId: this.roomId,\r\n      restoringPartyState: this.restoringPartyState\r\n    };\r\n  }\r\n  \r\n  setRestoringFlag(value) {\r\n    this.restoringPartyState = value;\r\n  }\r\n  \r\n  // Echo prevention helpers\r\n  isEcho(actionType) {\r\n    const now = Date.now();\r\n    const timeSinceLocal = now - this.lastLocalAction.time;\r\n    \r\n    // If we just performed this action within 500ms, it's likely an echo\r\n    if (this.lastLocalAction.type === actionType && timeSinceLocal < 500) {\r\n      console.log(`Ignoring echo of ${actionType} (${timeSinceLocal}ms ago)`);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  \r\n  recordLocalAction(actionType) {\r\n    this.lastLocalAction = { type: actionType, time: Date.now() };\r\n    console.log(`Recorded local action: ${actionType}`);\r\n  }\r\n  \r\n  recordRemoteAction(actionType) {\r\n    this.lastRemoteAction = { type: actionType, time: Date.now() };\r\n    console.log(`Recorded remote action: ${actionType}`);\r\n  }\r\n  \r\n  getTimeSinceLocalAction() {\r\n    return Date.now() - this.lastLocalAction.time;\r\n  }\r\n  \r\n  getTimeSinceRemoteAction() {\r\n    return Date.now() - this.lastRemoteAction.time;\r\n  }\r\n  \r\n  // Extension context validation\r\n  isExtensionContextValid() {\r\n    try {\r\n      return chrome.runtime && chrome.runtime.id;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Safe message sending\r\n  safeSendMessage(message, callback) {\r\n    if (!this.isExtensionContextValid()) {\r\n      console.warn('Extension context invalidated - please reload the page');\r\n      return;\r\n    }\r\n    try {\r\n      chrome.runtime.sendMessage(message, callback);\r\n    } catch (e) {\r\n      console.warn('Failed to send message, extension may have been reloaded:', e.message);\r\n    }\r\n  }\r\n}\r\n","// netflix-controller.js - Netflix player API wrapper\r\n\r\nexport class NetflixController {\r\n  constructor() {\r\n    this.injectAPIBridge();\r\n  }\r\n  \r\n  // Inject Netflix API access script into page context\r\n  injectAPIBridge() {\r\n    const script = document.createElement('script');\r\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\r\n    (document.head || document.documentElement).appendChild(script);\r\n    script.onload = function() {\r\n      console.log('Netflix API bridge loaded');\r\n      script.remove();\r\n    };\r\n  }\r\n  \r\n  // Send command to Netflix API via custom events\r\n  _sendCommand(command, args = []) {\r\n    return new Promise(function(resolve) {\r\n      const handler = function(e) {\r\n        if (e.detail.command === command) {\r\n          document.removeEventListener('__toperparty_response', handler);\r\n          resolve(e.detail.result);\r\n        }\r\n      };\r\n      document.addEventListener('__toperparty_response', handler);\r\n      setTimeout(function() { resolve(null); }, 1000); // timeout fallback\r\n      document.dispatchEvent(new CustomEvent('__toperparty_command', { detail: { command, args } }));\r\n    });\r\n  }\r\n  \r\n  play() {\r\n    return this._sendCommand('play');\r\n  }\r\n  \r\n  pause() {\r\n    return this._sendCommand('pause');\r\n  }\r\n  \r\n  seek(timeMs) {\r\n    return this._sendCommand('seek', [timeMs]);\r\n  }\r\n  \r\n  getCurrentTime() {\r\n    return this._sendCommand('getCurrentTime');\r\n  }\r\n  \r\n  isPaused() {\r\n    return this._sendCommand('isPaused');\r\n  }\r\n  \r\n  // Find Netflix video element (fallback)\r\n  getVideoElement() {\r\n    return document.querySelector('video');\r\n  }\r\n}\r\n","// sync-manager.js - Handles playback synchronization\r\n\r\nexport class SyncManager {\r\n  constructor(stateManager, netflixController) {\r\n    this.state = stateManager;\r\n    this.netflix = netflixController;\r\n    this.listeners = null;\r\n    this.syncInterval = null;\r\n  }\r\n  \r\n  // Setup playback synchronization\r\n  async setup() {\r\n    try {\r\n      const video = await this.waitForVideo();\r\n      if (!video) {\r\n        console.warn('Netflix video element not found after wait');\r\n        return;\r\n      }\r\n      \r\n      this.attachEventListeners(video);\r\n      this.startPeriodicSync(video);\r\n      this.sendInitialSync(video);\r\n      \r\n      console.log('Playback sync setup complete');\r\n    } catch (err) {\r\n      console.error('Error setting up playback sync:', err);\r\n    }\r\n  }\r\n  \r\n  // Wait for Netflix video element to appear\r\n  waitForVideo() {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\r\n      \r\n      const check = () => {\r\n        const video = this.netflix.getVideoElement();\r\n        if (video) {\r\n          clearTimeout(timeout);\r\n          resolve(video);\r\n        } else {\r\n          setTimeout(check, 100);\r\n        }\r\n      };\r\n      check();\r\n    });\r\n  }\r\n  \r\n  // Attach event listeners to video element\r\n  attachEventListeners(video) {\r\n    // Play event - always broadcast unless it's an echo\r\n    const onPlay = () => {\r\n      if (!this.state.isActive()) return;\r\n      if (this.state.isEcho('play')) return;\r\n      \r\n      console.log('Local play - broadcasting to peers');\r\n      this.state.recordLocalAction('play');\r\n      this.state.safeSendMessage({ type: 'PLAY_PAUSE', control: 'play', timestamp: video.currentTime });\r\n    };\r\n    \r\n    // Pause event - always broadcast unless it's an echo\r\n    const onPause = () => {\r\n      if (!this.state.isActive()) return;\r\n      if (this.state.isEcho('pause')) return;\r\n      \r\n      console.log('Local pause - broadcasting to peers');\r\n      this.state.recordLocalAction('pause');\r\n      this.state.safeSendMessage({ type: 'PLAY_PAUSE', control: 'pause', timestamp: video.currentTime });\r\n    };\r\n    \r\n    // Seek event - always broadcast unless it's an echo\r\n    const onSeeked = () => {\r\n      if (!this.state.isActive()) return;\r\n      if (this.state.isEcho('seek')) return;\r\n      \r\n      console.log('Local seek to', video.currentTime, '- broadcasting to peers');\r\n      this.state.recordLocalAction('seek');\r\n      this.state.safeSendMessage({ type: 'SEEK', currentTime: video.currentTime, isPlaying: !video.paused });\r\n    };\r\n    \r\n    // Throttled timeupdate sender (passive drift correction)\r\n    let lastSentAt = 0;\r\n    const onTimeUpdate = () => {\r\n      if (!this.state.isActive()) return;\r\n      \r\n      const now = Date.now();\r\n      if (now - lastSentAt < 1000) return; // throttle to ~1s\r\n      lastSentAt = now;\r\n      this.state.safeSendMessage({ type: 'SYNC_TIME', currentTime: video.currentTime, isPlaying: !video.paused });\r\n    };\r\n    \r\n    video.addEventListener('play', onPlay);\r\n    video.addEventListener('pause', onPause);\r\n    video.addEventListener('seeked', onSeeked);\r\n    video.addEventListener('timeupdate', onTimeUpdate);\r\n    \r\n    // Save references for teardown\r\n    this.listeners = { onPlay, onPause, onSeeked, onTimeUpdate, video };\r\n  }\r\n  \r\n  // Periodic fallback sync (every 5 seconds)\r\n  startPeriodicSync(video) {\r\n    this.syncInterval = setInterval(() => {\r\n      if (this.state.isActive() && video) {\r\n        this.state.safeSendMessage({ type: 'SYNC_TIME', currentTime: video.currentTime, isPlaying: !video.paused });\r\n      }\r\n    }, 5000);\r\n  }\r\n  \r\n  // Send initial sync after setup\r\n  sendInitialSync(video) {\r\n    setTimeout(() => {\r\n      if (this.state.isActive() && video) {\r\n        console.log('Sending initial sync after video setup');\r\n        this.state.safeSendMessage({ type: 'SYNC_TIME', currentTime: video.currentTime, isPlaying: !video.paused });\r\n      }\r\n    }, 2000);\r\n  }\r\n  \r\n  // Teardown playback synchronization\r\n  teardown() {\r\n    if (this.syncInterval) {\r\n      clearInterval(this.syncInterval);\r\n      this.syncInterval = null;\r\n    }\r\n    \r\n    if (this.listeners && this.listeners.video) {\r\n      const { video, onPlay, onPause, onSeeked, onTimeUpdate } = this.listeners;\r\n      try {\r\n        video.removeEventListener('play', onPlay);\r\n        video.removeEventListener('pause', onPause);\r\n        video.removeEventListener('seeked', onSeeked);\r\n        video.removeEventListener('timeupdate', onTimeUpdate);\r\n      } catch (e) {\r\n        console.warn('Error removing video event listeners:', e);\r\n      }\r\n      this.listeners = null;\r\n    }\r\n  }\r\n  \r\n  // Handle remote playback control commands\r\n  async handlePlaybackControl(control, fromUserId) {\r\n    console.log('Applying remote', control, 'command from', fromUserId);\r\n    this.state.recordRemoteAction(control);\r\n    \r\n    try {\r\n      if (control === 'play') {\r\n        await this.netflix.play();\r\n        console.log('Remote play completed');\r\n        this.state.recordLocalAction('play'); // Prevent echo\r\n      } else if (control === 'pause') {\r\n        await this.netflix.pause();\r\n        console.log('Remote pause completed');\r\n        this.state.recordLocalAction('pause'); // Prevent echo\r\n      }\r\n    } catch (err) {\r\n      console.error('Failed to apply remote', control, ':', err);\r\n    }\r\n  }\r\n  \r\n  // Handle remote seek commands\r\n  async handleSeek(currentTime, isPlaying, fromUserId) {\r\n    console.log('Applying remote SEEK to', currentTime, 's from', fromUserId);\r\n    this.state.recordRemoteAction('seek');\r\n    \r\n    const requestedTime = currentTime * 1000; // Convert to ms\r\n    \r\n    try {\r\n      await this.netflix.seek(requestedTime);\r\n      console.log('Remote seek completed');\r\n      this.state.recordLocalAction('seek'); // Prevent echo\r\n      \r\n      // Also sync play/pause state\r\n      const isPaused = await this.netflix.isPaused();\r\n      if (isPlaying && isPaused) {\r\n        await this.netflix.play();\r\n        this.state.recordLocalAction('play');\r\n      } else if (!isPlaying && !isPaused) {\r\n        await this.netflix.pause();\r\n        this.state.recordLocalAction('pause');\r\n      }\r\n    } catch (err) {\r\n      console.error('Failed to apply remote seek:', err);\r\n    }\r\n  }\r\n  \r\n  // Handle passive sync (drift correction)\r\n  async handlePassiveSync(currentTime, isPlaying, fromUserId) {\r\n    try {\r\n      const localTime = await this.netflix.getCurrentTime();\r\n      const requestedTime = currentTime * 1000; // Convert to ms\r\n      const timeDiff = Math.abs(localTime - requestedTime);\r\n      \r\n      // Check if we just did a local action - don't override it\r\n      const timeSinceLocalAction = this.state.getTimeSinceLocalAction();\r\n      if (timeSinceLocalAction < 1000) {\r\n        console.log('Ignoring passive sync - recent local action:', this.state.lastLocalAction.type, timeSinceLocalAction, 'ms ago');\r\n        return;\r\n      }\r\n      \r\n      // Only sync if times differ significantly\r\n      if (timeDiff > 2000) {\r\n        console.log('Passive sync: diff was', (timeDiff / 1000).toFixed(1), 's - correcting');\r\n        await this.netflix.seek(requestedTime);\r\n        this.state.recordLocalAction('seek');\r\n      }\r\n      \r\n      // Handle play/pause state sync\r\n      const isPaused = await this.netflix.isPaused();\r\n      if (isPlaying && isPaused && timeSinceLocalAction > 1000) {\r\n        console.log('Passive sync: resuming playback');\r\n        await this.netflix.play();\r\n        this.state.recordLocalAction('play');\r\n      } else if (!isPlaying && !isPaused && timeSinceLocalAction > 1000) {\r\n        console.log('Passive sync: pausing playback');\r\n        await this.netflix.pause();\r\n        this.state.recordLocalAction('pause');\r\n      }\r\n    } catch (err) {\r\n      console.error('Error handling passive sync:', err);\r\n    }\r\n  }\r\n}\r\n","// webrtc-manager.js - Manages WebRTC peer connections\r\n// Note: This is a large module that handles peer connections, signaling, and reconnection logic\r\n// For now, keeping the core WebRTC functionality in the main file to avoid breaking changes\r\n// TODO: Extract this properly in a future refactor\r\n\r\nexport class WebRTCManager {\r\n  constructor(stateManager) {\r\n    this.state = stateManager;\r\n    this.peerConnections = new Map();\r\n    this.reconnectionAttempts = new Map();\r\n    this.reconnectionTimeouts = new Map();\r\n    this.localStream = null;\r\n  }\r\n  \r\n  setLocalStream(stream) {\r\n    this.localStream = stream;\r\n  }\r\n  \r\n  getLocalStream() {\r\n    return this.localStream;\r\n  }\r\n  \r\n  getPeerConnections() {\r\n    return this.peerConnections;\r\n  }\r\n  \r\n  getReconnectionAttempts() {\r\n    return this.reconnectionAttempts;\r\n  }\r\n  \r\n  getReconnectionTimeouts() {\r\n    return this.reconnectionTimeouts;\r\n  }\r\n  \r\n  clearAll() {\r\n    // Close all peer connections\r\n    this.peerConnections.forEach((pc) => {\r\n      try { pc.close(); } catch (e) {}\r\n    });\r\n    this.peerConnections.clear();\r\n    \r\n    // Clear reconnection state\r\n    this.reconnectionTimeouts.forEach((timeoutHandle) => {\r\n      clearTimeout(timeoutHandle);\r\n    });\r\n    this.reconnectionTimeouts.clear();\r\n    this.reconnectionAttempts.clear();\r\n    \r\n    // Stop local stream\r\n    if (this.localStream) {\r\n      this.localStream.getTracks().forEach(track => track.stop());\r\n      this.localStream = null;\r\n    }\r\n  }\r\n}\r\n","// ui-manager.js - Manages UI components (preview videos)\r\n// Note: Keeping this simple for now, full extraction in future refactor\r\n\r\nexport class UIManager {\r\n  constructor() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos = new Map();\r\n    this.remoteStreams = new Map();\r\n    this.streamMonitorInterval = null;\r\n  }\r\n  \r\n  getRemoteVideos() {\r\n    return this.remoteVideos;\r\n  }\r\n  \r\n  getRemoteStreams() {\r\n    return this.remoteStreams;\r\n  }\r\n  \r\n  setLocalPreviewVideo(video) {\r\n    this.localPreviewVideo = video;\r\n  }\r\n  \r\n  getLocalPreviewVideo() {\r\n    return this.localPreviewVideo;\r\n  }\r\n  \r\n  setStreamMonitorInterval(interval) {\r\n    this.streamMonitorInterval = interval;\r\n  }\r\n  \r\n  getStreamMonitorInterval() {\r\n    return this.streamMonitorInterval;\r\n  }\r\n  \r\n  clearStreamMonitorInterval() {\r\n    if (this.streamMonitorInterval) {\r\n      clearInterval(this.streamMonitorInterval);\r\n      this.streamMonitorInterval = null;\r\n    }\r\n  }\r\n  \r\n  clearAll() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    this.clearStreamMonitorInterval();\r\n  }\r\n}\r\n","// url-sync.js - Manages URL monitoring and party state persistence\r\n// Note: Keeping this simple for now, full extraction in future refactor\r\n\r\nexport class URLSync {\r\n  constructor(stateManager) {\r\n    this.stateManager = stateManager;\r\n    this.urlMonitorInterval = null;\r\n    this.lastUrl = null;\r\n  }\r\n  \r\n  start() {\r\n    this.lastUrl = window.location.href;\r\n    // URL monitoring logic will be moved here in full extraction\r\n  }\r\n  \r\n  stop() {\r\n    if (this.urlMonitorInterval) {\r\n      clearInterval(this.urlMonitorInterval);\r\n      this.urlMonitorInterval = null;\r\n    }\r\n  }\r\n  \r\n  saveState() {\r\n    // Party state persistence logic will be moved here\r\n    const state = this.stateManager.getState();\r\n    if (state.partyActive) {\r\n      sessionStorage.setItem('toperparty_restore', JSON.stringify({\r\n        userId: state.userId,\r\n        roomId: state.roomId,\r\n        timestamp: Date.now()\r\n      }));\r\n    }\r\n  }\r\n  \r\n  clearState() {\r\n    sessionStorage.removeItem('toperparty_restore');\r\n  }\r\n  \r\n  getRestorationState() {\r\n    const stored = sessionStorage.getItem('toperparty_restore');\r\n    if (!stored) return null;\r\n    \r\n    try {\r\n      const state = JSON.parse(stored);\r\n      // Check if restoration state is recent (within 30 seconds)\r\n      if (Date.now() - state.timestamp < 30000) {\r\n        return state;\r\n      }\r\n    } catch (e) {\r\n      console.error('[toperparty] Failed to parse restoration state:', e);\r\n    }\r\n    \r\n    return null;\r\n  }\r\n}\r\n"],"names":["stateManager","constructor","this","partyActive","userId","roomId","restoringPartyState","lastLocalAction","type","time","lastRemoteAction","startParty","console","log","stopParty","isActive","getUserId","getRoomId","getState","setRestoringFlag","value","isEcho","actionType","timeSinceLocal","Date","now","recordLocalAction","recordRemoteAction","getTimeSinceLocalAction","getTimeSinceRemoteAction","isExtensionContextValid","chrome","runtime","id","e","safeSendMessage","message","callback","sendMessage","warn","netflixController","injectAPIBridge","script","document","createElement","src","getURL","head","documentElement","appendChild","onload","remove","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","addEventListener","setTimeout","dispatchEvent","CustomEvent","play","pause","seek","timeMs","getCurrentTime","isPaused","getVideoElement","querySelector","syncManager","state","netflix","listeners","syncInterval","setup","video","waitForVideo","attachEventListeners","startPeriodicSync","sendInitialSync","err","error","reject","timeout","Error","check","clearTimeout","onPlay","control","timestamp","currentTime","onPause","onSeeked","isPlaying","paused","lastSentAt","onTimeUpdate","setInterval","teardown","clearInterval","handlePlaybackControl","fromUserId","handleSeek","requestedTime","handlePassiveSync","localTime","timeDiff","Math","abs","timeSinceLocalAction","toFixed","webrtcManager","peerConnections","Map","reconnectionAttempts","reconnectionTimeouts","localStream","setLocalStream","stream","getLocalStream","getPeerConnections","getReconnectionAttempts","getReconnectionTimeouts","clearAll","forEach","pc","close","clear","timeoutHandle","getTracks","track","stop","uiManager","localPreviewVideo","remoteVideos","remoteStreams","streamMonitorInterval","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","urlSync","urlMonitorInterval","lastUrl","start","window","location","href","saveState","sessionStorage","setItem","JSON","stringify","clearState","removeItem","getRestorationState","stored","getItem","parse","restorationState","lastKnownUrl","addOrReplaceTrack","existingSender","getSenders","find","s","kind","replaceTrack","catch","addTrack","sendSignal","resp","async","attemptReconnection","peerId","attempts","get","backoffDelay","min","pow","delete","set","existingTimeout","oldPc","createPeerConnection","t","offer","createOffer","setLocalDescription","from","to","localDescription","clearReconnectionState","RTCPeerConnection","iceServers","urls","onicecandidate","event","candidate","ontrack","streams","MediaStream","onended","readyState","has","removeRemoteVideo","v","autoplay","playsInline","muted","style","position","bottom","right","size","width","height","zIndex","border","borderRadius","audioTracks","getAudioTracks","length","enabled","srcObject","URL","createObjectURL","body","then","volume","addRemoteVideo","onconnectionstatechange","connectionState","onMessage","addListener","request","sender","sendResponse","pcState","signalingState","setRemoteDescription","RTCSessionDescription","answer","createAnswer","addIceCandidate","RTCIceCandidate","handleSignalingMessage","navigator","mediaDevices","getUserMedia","ideal","audio","onmute","onunmute","left","transform","attachLocalPreview","tracks","allActive","startLocalStreamMonitor","success","currentUrl","url","startUrlMonitoring","removeLocalPreview","controls","getElementById","removeInjectedControls"],"ignoreList":[],"sourceRoot":""}