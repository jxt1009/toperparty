{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://toperparty/./chrome-extension/src/managers/sync/lock.js","webpack://toperparty/./chrome-extension/src/managers/sync/eventListeners.js","webpack://toperparty/./chrome-extension/src/managers/sync/SyncManager.js","webpack://toperparty/./chrome-extension/src/services/webrtc/peerConnection.js","webpack://toperparty/./chrome-extension/src/content/main.js","webpack://toperparty/./chrome-extension/src/managers/state/StateManager.js","webpack://toperparty/./chrome-extension/src/ui/UIManager.js","webpack://toperparty/./chrome-extension/src/content/netflix/NetflixController.js","webpack://toperparty/./chrome-extension/src/managers/sync/remoteHandlers.js","webpack://toperparty/./chrome-extension/src/services/webrtc/WebRTCManager.js","webpack://toperparty/./chrome-extension/src/services/webrtc/ui.js","webpack://toperparty/./chrome-extension/src/services/webrtc/reconnect.js","webpack://toperparty/./chrome-extension/src/services/webrtc/signaling.js","webpack://toperparty/./chrome-extension/src/managers/url/URLSync.js"],"sourcesContent":["export class SyncLock {\r\n  constructor() {\r\n    this.suppressLocalUntil = 0;\r\n  }\r\n  set(durationMs) {\r\n    this.suppressLocalUntil = Date.now() + durationMs;\r\n  }\r\n  isActive() {\r\n    return Date.now() < this.suppressLocalUntil;\r\n  }\r\n}\r\n","export function attachPlaybackListeners({ video, state, isInitializedRef, lock, onPlay, onPause, onSeek }) {\r\n  const handlePlay = () => {\r\n    console.log('[EventListeners] Play event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring play - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring play - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring play - lock active'); return; }\r\n    console.log('[EventListeners] Play event detected - broadcasting');\r\n    onPlay(video);\r\n  };\r\n\r\n  const handlePause = () => {\r\n    console.log('[EventListeners] Pause event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring pause - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring pause - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring pause - lock active'); return; }\r\n    console.log('[EventListeners] Pause event detected - broadcasting');\r\n    onPause(video);\r\n  };\r\n\r\n  const handleSeeked = () => {\r\n    console.log('[EventListeners] Seek event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring seek - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring seek - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring seek - lock active'); return; }\r\n    console.log('[EventListeners] Seek event detected - broadcasting');\r\n    onSeek(video);\r\n  };\r\n\r\n  video.addEventListener('play', handlePlay);\r\n  video.addEventListener('pause', handlePause);\r\n  video.addEventListener('seeked', handleSeeked);\r\n  console.log('[EventListeners] Event listeners attached to video element');\r\n\r\n  return { video, handlePlay, handlePause, handleSeeked };\r\n}\r\n","import { SyncLock } from './lock.js';\r\nimport { attachPlaybackListeners } from './eventListeners.js';\r\nimport { createRemoteHandlers } from './remoteHandlers.js';\r\n\r\nclass MutableRef {\r\n  constructor(value) { this.value = value; }\r\n  get() { return this.value; }\r\n  set(v) { this.value = v; }\r\n}\r\n\r\nexport class SyncManager {\r\n  constructor(stateManager, netflixController) {\r\n    this.state = stateManager;\r\n    this.netflix = netflixController;\r\n    this.lock = new SyncLock();\r\n    this.isInitializedRef = new MutableRef(false);\r\n    this.listeners = null;\r\n\r\n    this.remote = createRemoteHandlers({\r\n      state: this.state,\r\n      netflix: this.netflix,\r\n      lock: this.lock,\r\n      isInitializedRef: this.isInitializedRef,\r\n    });\r\n  }\r\n\r\n  async setup() {\r\n    try {\r\n      // Only setup sync manager on /watch pages\r\n      if (!window.location.pathname.startsWith('/watch')) {\r\n        console.log('[SyncManager] Not on /watch page, skipping setup');\r\n        return;\r\n      }\r\n      \r\n      console.log('[SyncManager] Starting setup - waiting for video element...');\r\n      const video = await this.waitForVideo();\r\n      if (!video) { \r\n        console.warn('[SyncManager] Netflix video element not found'); \r\n        return; \r\n      }\r\n      \r\n      console.log('[SyncManager] Video element found, setting up event listeners');\r\n      \r\n      // Check for pending sync from URL navigation\r\n      const pendingSyncStr = sessionStorage.getItem('toperparty_pending_sync');\r\n      if (pendingSyncStr) {\r\n        try {\r\n          const pendingSync = JSON.parse(pendingSyncStr);\r\n          if (Date.now() - pendingSync.timestamp < 10000) {\r\n            console.log('[SyncManager] Applying pending sync from URL navigation');\r\n            sessionStorage.removeItem('toperparty_pending_sync');\r\n            this.isInitializedRef.set(true);\r\n            \r\n            // Apply the pending sync state\r\n            this.lock.set(1500);\r\n            await this.netflix.seek(pendingSync.currentTime * 1000);\r\n            const isPaused = await this.netflix.isPaused();\r\n            if (pendingSync.isPlaying && isPaused) {\r\n              await this.netflix.play();\r\n            } else if (!pendingSync.isPlaying && !isPaused) {\r\n              await this.netflix.pause();\r\n            }\r\n            \r\n            const listeners = attachPlaybackListeners({\r\n              video,\r\n              state: this.state,\r\n              isInitializedRef: this.isInitializedRef,\r\n              lock: this.lock,\r\n              onPlay: (vid) => this.broadcastPlay(vid),\r\n              onPause: (vid) => this.broadcastPause(vid),\r\n              onSeek: (vid) => this.broadcastSeek(vid)\r\n            });\r\n            this.listeners = listeners;\r\n            console.log('[SyncManager] Setup complete with pending sync applied');\r\n            return;\r\n          } else {\r\n            console.log('[SyncManager] Pending sync expired, ignoring');\r\n            sessionStorage.removeItem('toperparty_pending_sync');\r\n          }\r\n        } catch (e) {\r\n          console.error('[SyncManager] Error applying pending sync:', e);\r\n          sessionStorage.removeItem('toperparty_pending_sync');\r\n        }\r\n      }\r\n      \r\n      this.isInitializedRef.set(false);\r\n      \r\n      // Request initial sync from other clients\r\n      console.log('[SyncManager] Requesting initial sync from other clients');\r\n      this.state.safeSendMessage({ type: 'REQUEST_SYNC' });\r\n      \r\n      // If no response after 2 seconds, consider ourselves initialized\r\n      setTimeout(() => {\r\n        if (!this.isInitializedRef.get()) {\r\n          console.log('[SyncManager] No sync response received after 2s, marking as initialized');\r\n          this.isInitializedRef.set(true);\r\n          console.log('[SyncManager] isInitialized is now:', this.isInitializedRef.get());\r\n        } else {\r\n          console.log('[SyncManager] Already initialized, skipping timeout initialization');\r\n        }\r\n      }, 2000);\r\n      \r\n      const listeners = attachPlaybackListeners({\r\n        video,\r\n        state: this.state,\r\n        isInitializedRef: this.isInitializedRef,\r\n        lock: this.lock,\r\n        onPlay: (vid) => this.broadcastPlay(vid),\r\n        onPause: (vid) => this.broadcastPause(vid),\r\n        onSeek: (vid) => this.broadcastSeek(vid)\r\n      });\r\n      this.listeners = listeners;\r\n      console.log('[SyncManager] Setup complete - ready to sync');\r\n    } catch (err) { \r\n      console.error('[SyncManager] Error setting up playback sync:', err); \r\n    }\r\n  }\r\n\r\n  teardown() {\r\n    console.log('[SyncManager] Tearing down sync manager');\r\n    if (this.listeners && this.listeners.video) {\r\n      const { video, handlePlay, handlePause, handleSeeked } = this.listeners;\r\n      try {\r\n        video.removeEventListener('play', handlePlay);\r\n        video.removeEventListener('pause', handlePause);\r\n        video.removeEventListener('seeked', handleSeeked);\r\n        console.log('[SyncManager] Event listeners removed');\r\n      } catch (e) { console.warn('[SyncManager] Error removing listeners:', e); }\r\n      this.listeners = null;\r\n    }\r\n    this.isInitializedRef.set(false);\r\n  }\r\n\r\n  waitForVideo() {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\r\n      const check = () => {\r\n        const video = this.netflix.getVideoElement();\r\n        if (video) { clearTimeout(timeout); resolve(video); }\r\n        else { setTimeout(check, 100); }\r\n      };\r\n      check();\r\n    });\r\n  }\r\n\r\n  isOnWatchPage() {\r\n    return window.location.pathname.startsWith('/watch');\r\n  }\r\n\r\n  broadcastPlay(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring PLAY event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting PLAY event');\r\n    this.state.safeSendMessage({ \r\n      type: 'PLAY_PAUSE', \r\n      control: 'play', \r\n      currentTime: video.currentTime \r\n    });\r\n  }\r\n\r\n  broadcastPause(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring PAUSE event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting PAUSE event');\r\n    this.state.safeSendMessage({ \r\n      type: 'PLAY_PAUSE', \r\n      control: 'pause', \r\n      currentTime: video.currentTime \r\n    });\r\n  }\r\n\r\n  broadcastSeek(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring SEEK event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting SEEK event at', video.currentTime);\r\n    this.state.safeSendMessage({ \r\n      type: 'SEEK', \r\n      currentTime: video.currentTime, \r\n      isPlaying: !video.paused \r\n    });\r\n  }\r\n\r\n  // Remote event handlers\r\n  handleRequestSync(fromUserId) { return this.remote.handleRequestSync(fromUserId); }\r\n  handleSyncResponse(currentTime, isPlaying, fromUserId, url) { return this.remote.handleSyncResponse(currentTime, isPlaying, fromUserId, url); }\r\n  handlePlaybackControl(control, currentTime, fromUserId) { return this.remote.handlePlaybackControl(control, currentTime, fromUserId); }\r\n  handleSeek(currentTime, isPlaying, fromUserId) { return this.remote.handleSeek(currentTime, isPlaying, fromUserId); }\r\n}\r\n","export function createPeerConnectionFactory({ stateManager, sendSignal, remoteStreams, remoteVideos, addRemoteVideo, attemptReconnection, clearReconnection, removeRemoteVideo, peersThatLeft, showReconnecting, hideOverlay, showPlaceholder }) {\r\n  return function createPeerConnection(peerId) {\r\n    console.log('[PeerConnection] Creating peer connection for peerId:', peerId);\r\n    \r\n    // Ensure any existing video/container AND stream is removed before creating placeholder\r\n    // This prevents duplicates when rapidly recreating connections (like force refresh)\r\n    removeRemoteVideo(peerId);\r\n    remoteStreams.delete(peerId); // Also clear the stream\r\n    \r\n    // Show placeholder immediately when peer connection is created\r\n    showPlaceholder(peerId);\r\n    \r\n    const state = stateManager.getState();\r\n    const pc = new RTCPeerConnection({\r\n      iceServers: [\r\n        { urls: ['stun:stun.l.google.com:19302'] },\r\n        { urls: ['stun:stun1.l.google.com:19302'] }\r\n      ]\r\n    });\r\n    pc.onicecandidate = (event) => {\r\n      if (event.candidate) {\r\n        console.log('[PeerConnection] ICE candidate for peer:', peerId, event.candidate);\r\n        sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\r\n      }\r\n    };\r\n    pc.ontrack = (event) => {\r\n      console.log('[PeerConnection] ontrack fired for peer:', peerId, 'track:', event.track, 'streams:', event.streams);\r\n      let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\r\n      if (!stream) {\r\n        console.log('[PeerConnection] Creating new MediaStream for peer:', peerId);\r\n        stream = new MediaStream();\r\n        remoteStreams.set(peerId, stream);\r\n      }\r\n      if (event.track) {\r\n        console.log('[PeerConnection] Adding track to stream:', event.track.kind, event.track.id);\r\n        try { \r\n          // Check if track already exists in stream to prevent duplicates\r\n          const existingTrack = stream.getTracks().find(t => t.id === event.track.id);\r\n          if (!existingTrack) {\r\n            stream.addTrack(event.track);\r\n          } else {\r\n            console.log('[PeerConnection] Track already in stream, skipping');\r\n          }\r\n        } catch (e) {\r\n          console.warn('[PeerConnection] Error adding track:', e);\r\n        }\r\n      }\r\n      \r\n      // Check if video element exists\r\n      const hasVideoInMap = remoteVideos.has(peerId);\r\n      const hasVideoInDom = !!document.getElementById('toperparty-remote-' + peerId);\r\n      const videoExists = hasVideoInMap || hasVideoInDom;\r\n      \r\n      if (videoExists) {\r\n        console.log('[PeerConnection] Video already exists for peer:', peerId, 'inMap:', hasVideoInMap, 'inDom:', hasVideoInDom);\r\n        // Update the existing video element's stream if it's different\r\n        const existingVideo = remoteVideos.get(peerId) || document.getElementById('toperparty-remote-' + peerId);\r\n        if (existingVideo && existingVideo.srcObject !== stream) {\r\n          console.log('[PeerConnection] Updating existing video element with new stream');\r\n          existingVideo.srcObject = stream;\r\n          // Ensure it's tracked in the map\r\n          if (!hasVideoInMap) {\r\n            remoteVideos.set(peerId, existingVideo);\r\n          }\r\n        }\r\n      } else {\r\n        // Wait for both audio and video tracks before creating video element\r\n        const tracks = stream.getTracks();\r\n        const hasAudio = tracks.some(t => t.kind === 'audio');\r\n        const hasVideo = tracks.some(t => t.kind === 'video');\r\n        \r\n        console.log('[PeerConnection] Stream status - audio:', hasAudio, 'video:', hasVideo, 'total tracks:', tracks.length);\r\n        \r\n        // Only create video element when we have both tracks\r\n        if (hasAudio && hasVideo) {\r\n          console.log('[PeerConnection] Both tracks present, adding remote video for peer:', peerId);\r\n          addRemoteVideo(peerId, stream);\r\n        } else {\r\n          console.log('[PeerConnection] Waiting for more tracks before creating video element');\r\n        }\r\n      }\r\n    };\r\n    pc.onconnectionstatechange = () => {\r\n      console.log('[PeerConnection] Connection state changed for peer:', peerId, '', pc.connectionState);\r\n      if (pc.connectionState === 'connected') {\r\n        clearReconnection(peerId);\r\n        hideOverlay(peerId);\r\n      } else if (pc.connectionState === 'disconnected') {\r\n        if (peersThatLeft.has(peerId)) {\r\n          removeRemoteVideo(peerId);\r\n          clearReconnection(peerId);\r\n        } else {\r\n          // Keep video visible while reconnecting - don't remove immediately\r\n          console.log('[PeerConnection] Connection disconnected, attempting reconnection while keeping video visible');\r\n          showReconnecting(peerId);\r\n          attemptReconnection(peerId);\r\n        }\r\n      } else if (pc.connectionState === 'failed') {\r\n        console.log('[PeerConnection] Connection failed for peer:', peerId);\r\n        if (peersThatLeft.has(peerId)) {\r\n          removeRemoteVideo(peerId);\r\n          clearReconnection(peerId);\r\n        } else {\r\n          // Remove video on failed state and try to reconnect\r\n          removeRemoteVideo(peerId);\r\n          attemptReconnection(peerId);\r\n        }\r\n      } else if (pc.connectionState === 'closed') {\r\n        removeRemoteVideo(peerId);\r\n        clearReconnection(peerId);\r\n      }\r\n    };\r\n    return pc;\r\n  };\r\n}\r\n\r\nexport function addOrReplaceTrack(pc, track, stream) {\r\n  const senders = pc.getSenders();\r\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\r\n  if (existingSender) {\r\n    existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\r\n  } else {\r\n    try { pc.addTrack(track, stream); } catch (e) {}\r\n  }\r\n}\r\n","import { StateManager } from '../managers/state/StateManager.js';\r\nimport { NetflixController } from './netflix/NetflixController.js';\r\nimport { SyncManager } from '../managers/sync/SyncManager.js';\r\nimport { WebRTCManager } from '../services/webrtc/WebRTCManager.js';\r\nimport { UIManager } from '../ui/UIManager.js';\r\nimport { URLSync } from '../managers/url/URLSync.js';\r\n\r\nconsole.log('[Content Script] Initializing managers...');\r\n\r\n// Don't clean up stale elements on navigation - they should persist\r\n// Only clean up if party is not active\r\nconst wasPartyActive = sessionStorage.getItem('toperparty_was_active') === 'true';\r\nif (!wasPartyActive) {\r\n  console.log('[Content Script] No active party detected, cleaning up stale elements...');\r\n  const staleContainers = document.querySelectorAll('[id^=\"toperparty-container-\"]');\r\n  const staleVideos = document.querySelectorAll('[id^=\"toperparty-remote-\"]');\r\n  const staleOverlays = document.querySelectorAll('[id^=\"toperparty-overlay-\"]');\r\n  const staleLocalVideo = document.getElementById('toperparty-local-preview');\r\n  const staleWaitingIndicator = document.getElementById('toperparty-waiting-indicator');\r\n\r\n  staleContainers.forEach(el => {\r\n    console.log('[Content Script] Removing stale container:', el.id);\r\n    el.remove();\r\n  });\r\n  staleVideos.forEach(el => {\r\n    console.log('[Content Script] Removing stale video:', el.id);\r\n    el.remove();\r\n  });\r\n  staleOverlays.forEach(el => {\r\n    console.log('[Content Script] Removing stale overlay:', el.id);\r\n    el.remove();\r\n  });\r\n  if (staleLocalVideo) {\r\n    console.log('[Content Script] Removing stale local video');\r\n    staleLocalVideo.remove();\r\n  }\r\n  if (staleWaitingIndicator) {\r\n    console.log('[Content Script] Removing stale waiting indicator');\r\n    staleWaitingIndicator.remove();\r\n  }\r\n} else {\r\n  console.log('[Content Script] Party is active, keeping existing video elements');\r\n}\r\n\r\nconst stateManager = new StateManager();\r\nconst uiManager = new UIManager();\r\nconst netflixController = new NetflixController();\r\nconst syncManager = new SyncManager(stateManager, netflixController);\r\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\r\n\r\n// Callback when we navigate to a different /watch page\r\nconst handleWatchPageChange = () => {\r\n  console.log('[Content Script] Watch page changed - reinitializing sync manager');\r\n  const state = stateManager.getState();\r\n  if (state.partyActive) {\r\n    console.log('[Content Script] Party is active, reinitializing sync manager');\r\n    syncManager.teardown();\r\n    syncManager.setup().catch(err => {\r\n      console.error('[Content Script] Failed to reinitialize sync manager:', err);\r\n    });\r\n  } else {\r\n    console.log('[Content Script] Party not active, skipping sync manager reinitialization');\r\n  }\r\n};\r\n\r\n// Also initialize sync manager when navigating TO a watch page (not just between watch pages)\r\nconst handleNavigationToWatch = () => {\r\n  console.log('[Content Script] Navigated to /watch page');\r\n  const state = stateManager.getState();\r\n  if (state.partyActive) {\r\n    console.log('[Content Script] Party is active, initializing sync manager');\r\n    syncManager.teardown();\r\n    syncManager.setup().catch(err => {\r\n      console.error('[Content Script] Failed to initialize sync manager:', err);\r\n    });\r\n  }\r\n};\r\n\r\n// Teardown sync manager when leaving a watch page\r\nconst handleLeaveWatch = () => {\r\n  console.log('[Content Script] Left /watch page');\r\n  syncManager.teardown();\r\n};\r\n\r\nconst urlSync = new URLSync(stateManager, handleWatchPageChange, handleNavigationToWatch, handleLeaveWatch);\r\nconsole.log('[Content Script] Managers initialized');\r\n\r\nlet localStream = null;\r\nlet videoElementMonitor = null;\r\n\r\n// If party was active before this page load, try to restore videos immediately\r\nif (wasPartyActive) {\r\n  console.log('[Content Script] Party was active, checking for restoration state...');\r\n  setTimeout(() => {\r\n    // Give the page a moment to initialize\r\n    const state = stateManager.getState();\r\n    if (state.partyActive && localStream) {\r\n      console.log('[Content Script] Restoring local preview video after navigation');\r\n      const existingPreview = document.getElementById('toperparty-local-preview');\r\n      if (!existingPreview) {\r\n        uiManager.attachLocalPreview(localStream);\r\n      }\r\n    }\r\n  }, 100);\r\n}\r\n\r\n// Monitor and restore video elements if they get removed during navigation\r\nfunction startVideoElementMonitoring() {\r\n  if (videoElementMonitor) return;\r\n  \r\n  videoElementMonitor = setInterval(() => {\r\n    const state = stateManager.getState();\r\n    if (!state.partyActive) return;\r\n    \r\n    // Check if local preview exists\r\n    if (localStream && !document.getElementById('toperparty-local-preview')) {\r\n      console.log('[Content Script] Local preview missing, re-attaching');\r\n      uiManager.attachLocalPreview(localStream);\r\n    }\r\n    \r\n    // Check if remote videos exist\r\n    const remoteVideos = uiManager.getRemoteVideos();\r\n    const remoteStreams = uiManager.getRemoteStreams();\r\n    remoteStreams.forEach((stream, peerId) => {\r\n      const videoId = 'toperparty-remote-' + peerId;\r\n      if (!document.getElementById(videoId)) {\r\n        console.log('[Content Script] Remote video missing for peer:', peerId, 're-adding');\r\n        const videoManager = webrtcManager.videoManager;\r\n        if (videoManager && videoManager.add) {\r\n          videoManager.add(peerId, stream);\r\n        }\r\n      }\r\n    });\r\n  }, 250); // Check every 250ms for faster restoration\r\n  \r\n  console.log('[Content Script] Started video element monitoring');\r\n}\r\n\r\nfunction stopVideoElementMonitoring() {\r\n  if (videoElementMonitor) {\r\n    clearInterval(videoElementMonitor);\r\n    videoElementMonitor = null;\r\n    console.log('[Content Script] Stopped video element monitoring');\r\n  }\r\n}\r\n\r\n(function checkRestorePartyState() {\r\n  const restorationState = urlSync.getRestorationState();\r\n  if (restorationState) {\r\n    console.log('[Content Script] Restoring party state for room:', restorationState.roomId);\r\n    urlSync.clearState();\r\n    stateManager.setRestoringFlag(true);\r\n    \r\n    setTimeout(function() {\r\n      console.log('[Content Script] Sending RESTORE_PARTY message');\r\n      chrome.runtime.sendMessage({ type: 'RESTORE_PARTY', roomId: restorationState.roomId }, (response) => {\r\n        if (response && response.success) {\r\n          console.log('[Content Script] Party restoration successful - setting state with userId:', response.userId);\r\n          // Immediately set the userId and roomId so we can handle incoming messages\r\n          stateManager.startParty(response.userId, response.roomId);\r\n          \r\n          // Re-obtain media stream for WebRTC signaling\r\n          console.log('[Content Script] Re-obtaining media stream after navigation');\r\n          navigator.mediaDevices.getUserMedia({ video: true, audio: true })\r\n            .then(stream => {\r\n              console.log('[Content Script] Media stream obtained after restoration');\r\n              localStream = stream;\r\n              webrtcManager.setLocalStream(stream);\r\n              webrtcManager.onLocalStreamAvailable(stream);\r\n              uiManager.attachLocalPreview(stream);\r\n              \r\n              // Re-setup sync manager\r\n              syncManager.teardown();\r\n              syncManager.setup().catch(err => {\r\n                console.error('[Content Script] Failed to setup sync manager after restoration:', err);\r\n              });\r\n              \r\n              // Start URL monitoring if not already started\r\n              urlSync.start();\r\n              startVideoElementMonitoring();\r\n            })\r\n            .catch(err => {\r\n              console.error('[Content Script] Failed to get media stream after restoration:', err);\r\n            });\r\n        } else {\r\n          console.error('[Content Script] Party restoration failed:', response ? response.error : 'Unknown error');\r\n        }\r\n        setTimeout(function() {\r\n          stateManager.setRestoringFlag(false);\r\n        }, 2000);\r\n      });\r\n    }, 1000);\r\n  }\r\n})();\r\n\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  console.log('[Content Script] Received message:', request.type);\r\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\r\n    console.log('[Content Script] Processing REQUEST_MEDIA_STREAM');\r\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\r\n      .then(stream => {\r\n        console.log('[Content Script] Media stream obtained, tracks:', stream.getTracks().length);\r\n        localStream = stream;\r\n        console.log('[Content Script] Setting local stream on WebRTC manager');\r\n        webrtcManager.setLocalStream(stream);\r\n        webrtcManager.onLocalStreamAvailable(stream);\r\n        console.log('[Content Script] Attaching local preview to UI');\r\n        uiManager.attachLocalPreview(stream);\r\n        console.log('[Content Script] Local preview attached, sending success response');\r\n        sendResponse({ success: true });\r\n      })\r\n      .catch(err => {\r\n        console.error('[Content Script] Failed to get media stream:', err);\r\n        sendResponse({ success: false, error: err.message });\r\n      });\r\n    return true;\r\n  }\r\n\r\n  if (request.type === 'PARTY_STARTED') {\r\n    console.log('[Content Script] Party started:', request.userId, request.roomId);\r\n    stateManager.startParty(request.userId, request.roomId);\r\n    \r\n    // Show \"Waiting for others...\" placeholder immediately\r\n    webrtcManager.showWaitingIndicator();\r\n    \r\n    // Set Netflix volume to 15%\r\n    setTimeout(() => {\r\n      netflixController.setVolume(0.15).then(() => {\r\n        console.log('[Content Script] Set Netflix volume to 15%');\r\n      }).catch(err => {\r\n        console.warn('[Content Script] Failed to set volume:', err);\r\n      });\r\n    }, 1000);\r\n    \r\n    // Teardown existing sync manager if already set up\r\n    syncManager.teardown();\r\n    \r\n    // Setup sync manager (will wait for video element)\r\n    syncManager.setup().catch(err => {\r\n      console.error('[Content Script] Failed to setup sync manager:', err);\r\n    });\r\n    \r\n    urlSync.start();\r\n    startVideoElementMonitoring();\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'PARTY_STOPPED') {\r\n    console.log('[Content Script] Stopping party');\r\n    stopVideoElementMonitoring();\r\n    stateManager.stopParty();\r\n    syncManager.teardown();\r\n    urlSync.stop();\r\n    urlSync.clearState();\r\n    webrtcManager.clearAll();\r\n    uiManager.removeLocalPreview();\r\n    if (localStream) {\r\n      localStream.getTracks().forEach(t => t.stop());\r\n      localStream = null;\r\n    }\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'SIGNAL') {\r\n    console.log('[Content Script] Handling SIGNAL:', request.message?.type);\r\n    webrtcManager.handleSignal(request.message);\r\n  }\r\n\r\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\r\n    // Only apply playback controls if we're on a /watch page\r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      console.log('[Content Script] Ignoring playback control - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[Content Script] Applying playback control:', request.control, 'at', request.currentTime, 'from', request.fromUserId);\r\n    syncManager.handlePlaybackControl(request.control, request.currentTime, request.fromUserId);\r\n  }\r\n\r\n  // Passive sync removed - using event-based sync only\r\n\r\n  if (request.type === 'APPLY_SEEK') {\r\n    // Only apply seek if we're on a /watch page\r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      console.log('[Content Script] Ignoring seek - not on /watch page');\r\n      return;\r\n    }\r\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\r\n  }\r\n\r\n  if (request.type === 'APPLY_URL_CHANGE') {\r\n    console.log('[Content Script] Received URL change request:', request.url, 'from', request.fromUserId);\r\n    \r\n    if (stateManager.restoringPartyState) {\r\n      console.log('[Content Script] Ignoring URL change - currently restoring party state');\r\n      return;\r\n    }\r\n    \r\n    // Apply URL changes to all Netflix pages (browse, title, watch, etc.)\r\n    const incomingUrl = new URL(request.url);\r\n    const currentUrl = window.location.href;\r\n    \r\n    // Don't navigate if we're already on this URL\r\n    if (currentUrl === request.url) {\r\n      console.log('[Content Script] Already on this URL, skipping navigation');\r\n      return;\r\n    }\r\n    \r\n    console.log('[Content Script] Navigating to:', request.url, 'using SPA navigation');\r\n    // Save state before navigating (for restoration if on /watch page)\r\n    const currentPath = window.location.pathname;\r\n    if (currentPath.startsWith('/watch')) {\r\n      urlSync.saveState();\r\n    }\r\n    \r\n    // Use history.pushState to navigate without full page reload (Netflix SPA style)\r\n    try {\r\n      window.history.pushState({}, '', request.url);\r\n      \r\n      // Trigger popstate event to let Netflix's router handle the navigation\r\n      window.dispatchEvent(new PopStateEvent('popstate', { state: {} }));\r\n      \r\n      console.log('[Content Script] SPA navigation triggered');\r\n    } catch (e) {\r\n      console.error('[Content Script] Failed to navigate via pushState, falling back to full reload:', e);\r\n      window.location.href = request.url;\r\n    }\r\n  }\r\n\r\n  if (request.type === 'HANDLE_REQUEST_SYNC') {\r\n    // Only handle sync requests if we're on a /watch page\r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      console.log('[Content Script] Ignoring sync request - not on /watch page');\r\n      return;\r\n    }\r\n    syncManager.handleRequestSync(request.fromUserId);\r\n  }\r\n\r\n  if (request.type === 'APPLY_SYNC_RESPONSE') {\r\n    // Only apply sync response if we're on a /watch page\r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      console.log('[Content Script] Ignoring sync response - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[Content Script] Applying sync response from', request.fromUserId, 'URL:', request.url);\r\n    syncManager.handleSyncResponse(request.currentTime, request.isPlaying, request.fromUserId, request.url);\r\n  }\r\n\r\n  if (request.type === 'REQUEST_INITIAL_SYNC_AND_PLAY') {\r\n    console.log('[Content Script] Requesting initial sync and will auto-play when synced');\r\n    // Request sync from other clients\r\n    stateManager.safeSendMessage({ type: 'REQUEST_SYNC' });\r\n  }\r\n});\r\n\r\nwindow.addEventListener('beforeunload', () => {\r\n  if (stateManager.isActive()) {\r\n    urlSync.saveState();\r\n  }\r\n});\r\n","export class StateManager {\r\n  constructor() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    this.restoringPartyState = false;\r\n  }\r\n  startParty(userId, roomId) {\r\n    this.partyActive = true;\r\n    this.userId = userId;\r\n    this.roomId = roomId;\r\n    // Set flag so videos persist across navigation\r\n    sessionStorage.setItem('toperparty_was_active', 'true');\r\n  }\r\n  stopParty() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    // Clear flag so videos are cleaned up\r\n    sessionStorage.removeItem('toperparty_was_active');\r\n  }\r\n  isActive() { return this.partyActive; }\r\n  getUserId() { return this.userId; }\r\n  getRoomId() { return this.roomId; }\r\n  getState() {\r\n    return { partyActive: this.partyActive, userId: this.userId, roomId: this.roomId, restoringPartyState: this.restoringPartyState };\r\n  }\r\n  isInParty() { return !!(this.partyActive && this.userId && this.roomId); }\r\n  setRestoringFlag(value) { this.restoringPartyState = value; }\r\n  isExtensionContextValid() {\r\n    try { return chrome.runtime && chrome.runtime.id; } catch { return false; }\r\n  }\r\n  safeSendMessage(message, callback) {\r\n    if (!this.isExtensionContextValid()) {\r\n      console.warn('[StateManager] Extension context invalid - page needs reload after extension update');\r\n      // Show user notification that they need to reload\r\n      if (!document.getElementById('toperparty-reload-notice')) {\r\n        const notice = document.createElement('div');\r\n        notice.id = 'toperparty-reload-notice';\r\n        notice.style.cssText = 'position:fixed;top:20px;right:20px;background:#e50914;color:white;padding:15px;border-radius:8px;z-index:99999;font-family:Arial;box-shadow:0 4px 6px rgba(0,0,0,0.3);';\r\n        notice.innerHTML = '<strong>ToperParty:</strong> Extension updated. Please reload this page.';\r\n        document.body.appendChild(notice);\r\n      }\r\n      return;\r\n    }\r\n    console.log('[StateManager] Sending message:', message.type, message);\r\n    try { \r\n      chrome.runtime.sendMessage(message, (response) => {\r\n        if (chrome.runtime.lastError) {\r\n          console.error('[StateManager] Error sending message:', message.type, chrome.runtime.lastError.message);\r\n        } else {\r\n          console.log('[StateManager] Message sent successfully:', message.type, response);\r\n        }\r\n        if (callback) callback(response);\r\n      }); \r\n    } catch (e) { \r\n      console.error('[StateManager] Exception sending message:', message.type, e.message, e); \r\n    }\r\n  }\r\n}\r\n","export class UIManager {\r\n  constructor() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos = new Map();\r\n    this.remoteStreams = new Map();\r\n    this.streamMonitorInterval = null;\r\n  }\r\n\r\n  makeDraggable(element) {\r\n    let isDragging = false;\r\n    let currentX;\r\n    let currentY;\r\n    let initialX;\r\n    let initialY;\r\n    let xOffset = 0;\r\n    let yOffset = 0;\r\n\r\n    element.addEventListener('mousedown', dragStart);\r\n    element.addEventListener('mouseup', dragEnd);\r\n    element.addEventListener('mousemove', drag);\r\n    element.style.cursor = 'move';\r\n\r\n    function dragStart(e) {\r\n      // Get current position from style\r\n      const computedStyle = window.getComputedStyle(element);\r\n      const bottom = computedStyle.bottom;\r\n      const left = computedStyle.left;\r\n      const right = computedStyle.right;\r\n      \r\n      // Convert to absolute positioning from current position\r\n      const rect = element.getBoundingClientRect();\r\n      element.style.left = rect.left + 'px';\r\n      element.style.top = rect.top + 'px';\r\n      element.style.bottom = 'auto';\r\n      element.style.right = 'auto';\r\n      \r\n      initialX = e.clientX - rect.left;\r\n      initialY = e.clientY - rect.top;\r\n      isDragging = true;\r\n      element.style.opacity = '0.8';\r\n    }\r\n\r\n    function dragEnd(e) {\r\n      initialX = currentX;\r\n      initialY = currentY;\r\n      isDragging = false;\r\n      element.style.opacity = '1';\r\n    }\r\n\r\n    function drag(e) {\r\n      if (isDragging) {\r\n        e.preventDefault();\r\n        currentX = e.clientX - initialX;\r\n        currentY = e.clientY - initialY;\r\n        \r\n        // Keep within viewport bounds\r\n        const maxX = window.innerWidth - element.offsetWidth;\r\n        const maxY = window.innerHeight - element.offsetHeight;\r\n        currentX = Math.max(0, Math.min(currentX, maxX));\r\n        currentY = Math.max(0, Math.min(currentY, maxY));\r\n        \r\n        setTranslate(currentX, currentY, element);\r\n      }\r\n    }\r\n\r\n    function setTranslate(xPos, yPos, el) {\r\n      el.style.left = xPos + 'px';\r\n      el.style.top = yPos + 'px';\r\n    }\r\n  }\r\n  getRemoteVideos() { return this.remoteVideos; }\r\n  getRemoteStreams() { return this.remoteStreams; }\r\n  setLocalPreviewVideo(video) { this.localPreviewVideo = video; }\r\n  getLocalPreviewVideo() { return this.localPreviewVideo; }\r\n  setStreamMonitorInterval(interval) { this.streamMonitorInterval = interval; }\r\n  getStreamMonitorInterval() { return this.streamMonitorInterval; }\r\n  clearStreamMonitorInterval() {\r\n    if (this.streamMonitorInterval) {\r\n      clearInterval(this.streamMonitorInterval);\r\n      this.streamMonitorInterval = null;\r\n    }\r\n  }\r\n\r\n  attachLocalPreview(stream) {\r\n    console.log('[UIManager] Attaching local preview with stream:', stream);\r\n    this.removeLocalPreview();\r\n    \r\n    const v = document.createElement('video');\r\n    v.id = 'toperparty-local-preview';\r\n    v.autoplay = true;\r\n    v.muted = true; // Always mute local preview to avoid feedback\r\n    v.playsInline = true;\r\n    v.style.position = 'fixed';\r\n    v.style.bottom = '145px';\r\n    v.style.left = '20px';\r\n    v.style.width = '240px';\r\n    v.style.height = '160px';\r\n    v.style.zIndex = '999999';\r\n    v.style.border = '2px solid #e50914';\r\n    v.style.borderRadius = '4px';\r\n    v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\r\n\r\n    try {\r\n      v.srcObject = stream;\r\n      console.log('[UIManager] Set srcObject on local preview');\r\n    } catch (e) {\r\n      console.warn('[UIManager] srcObject failed, trying createObjectURL:', e);\r\n      v.src = URL.createObjectURL(stream);\r\n    }\r\n\r\n    document.body.appendChild(v);\r\n    this.localPreviewVideo = v;\r\n    console.log('[UIManager] Local preview video appended to body');\r\n\r\n    // Make it draggable\r\n    this.makeDraggable(v);\r\n\r\n    v.play().catch(err => {\r\n      console.warn('[UIManager] Local preview play() failed:', err);\r\n    });\r\n  }\r\n\r\n  removeLocalPreview() {\r\n    if (this.localPreviewVideo) {\r\n      console.log('[UIManager] Removing local preview video');\r\n      try {\r\n        if (this.localPreviewVideo.srcObject) {\r\n          this.localPreviewVideo.srcObject = null;\r\n        }\r\n      } catch (e) {\r\n        console.warn('[UIManager] Error clearing srcObject:', e);\r\n      }\r\n      this.localPreviewVideo.remove();\r\n      this.localPreviewVideo = null;\r\n    }\r\n  }\r\n\r\n  clearAll() {\r\n    this.removeLocalPreview();\r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    this.clearStreamMonitorInterval();\r\n  }\r\n}\r\n","export class NetflixController {\r\n  constructor() { this.injectAPIBridge(); }\r\n  injectAPIBridge() {\r\n    const script = document.createElement('script');\r\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\r\n    (document.head || document.documentElement).appendChild(script);\r\n    script.onload = function() { script.remove(); };\r\n  }\r\n  _sendCommand(command, args = []) {\r\n    return new Promise(function(resolve) {\r\n      const handler = function(e) {\r\n        if (e.detail.command === command) {\r\n          document.removeEventListener('__toperparty_response', handler);\r\n          resolve(e.detail.result);\r\n        }\r\n      };\r\n      document.addEventListener('__toperparty_response', handler);\r\n      setTimeout(function() { resolve(null); }, 1000);\r\n      document.dispatchEvent(new CustomEvent('__toperparty_command', { detail: { command, args } }));\r\n    });\r\n  }\r\n  play() { return this._sendCommand('play'); }\r\n  pause() { return this._sendCommand('pause'); }\r\n  seek(timeMs) { return this._sendCommand('seek', [timeMs]); }\r\n  getCurrentTime() { return this._sendCommand('getCurrentTime'); }\r\n  isPaused() { return this._sendCommand('isPaused'); }\r\n  setVolume(level) { return this._sendCommand('setVolume', [level]); }\r\n  getVolume() { return this._sendCommand('getVolume'); }\r\n  getVideoElement() { \r\n    // Find Netflix main player video element\r\n    // On /watch pages, look for video in the watch-video container\r\n    // On other pages, don't return any video (we don't want to sync preview videos)\r\n    \r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      return null;\r\n    }\r\n    \r\n    // Find Netflix video element, excluding ToperParty videos\r\n    const videos = document.querySelectorAll('video');\r\n    for (const video of videos) {\r\n      if (!video.id || !video.id.startsWith('toperparty-')) {\r\n        return video;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n}\r\n","export function createRemoteHandlers({ state, netflix, lock, isInitializedRef }) {\r\n  async function applyRemote(actionName, durationMs, actionFn) {\r\n    lock.set(durationMs);\r\n    try { await actionFn(); } catch (err) {\r\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\r\n    }\r\n  }\r\n\r\n  return {\r\n    async handleRequestSync(fromUserId) {\r\n      if (!isInitializedRef.get()) {\r\n        console.log('[SyncManager] Not yet initialized, ignoring sync request');\r\n        return;\r\n      }\r\n      \r\n      const currentUrl = window.location.href;\r\n      const isOnWatchPage = window.location.pathname.startsWith('/watch');\r\n      \r\n      // If we're on browse page, don't send sync response\r\n      if (!isOnWatchPage) {\r\n        console.log('[SyncManager] On browse page, not sending sync response');\r\n        return;\r\n      }\r\n      \r\n      try {\r\n        const currentTime = await netflix.getCurrentTime();\r\n        const isPaused = await netflix.isPaused();\r\n        \r\n        if (currentTime == null) {\r\n          console.log('[SyncManager] Invalid playback state, ignoring sync request');\r\n          return;\r\n        }\r\n        \r\n        const currentTimeSeconds = currentTime / 1000;\r\n        console.log('[SyncManager] Sending SYNC_RESPONSE to', fromUserId, 'at', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing', 'URL:', currentUrl);\r\n        \r\n        state.safeSendMessage({\r\n          type: 'SYNC_RESPONSE',\r\n          targetUserId: fromUserId,\r\n          currentTime: currentTimeSeconds,\r\n          isPlaying: !isPaused,\r\n          url: currentUrl\r\n        });\r\n      } catch (e) { console.error('[SyncManager] Error handling sync request:', e); }\r\n    },\r\n    async handleSyncResponse(currentTime, isPlaying, fromUserId, url) {\r\n      if (isInitializedRef.get()) {\r\n        console.log('[SyncManager] Already initialized, ignoring late SYNC_RESPONSE');\r\n        return;\r\n      }\r\n      \r\n      if (currentTime == null || typeof currentTime !== 'number' || currentTime < 0) {\r\n        console.warn('[SyncManager] Invalid SYNC_RESPONSE - bad currentTime:', currentTime);\r\n        return;\r\n      }\r\n      \r\n      console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'URL:', url);\r\n      \r\n      // Check if we need to navigate to a different URL\r\n      const currentUrl = window.location.href;\r\n      const currentPath = window.location.pathname;\r\n      const isOnWatch = currentPath.startsWith('/watch');\r\n      const isOnBrowse = currentPath.startsWith('/browse');\r\n      const otherIsOnWatch = url && (new URL(url).pathname.startsWith('/watch'));\r\n      \r\n      // Only navigate if we're NOT on a /watch page and the other user IS on /watch\r\n      // This allows initial sync to pull you to the watch page, but won't pull you back if you leave\r\n      if (!isOnWatch && otherIsOnWatch && isOnBrowse) {\r\n        console.log('[SyncManager] On browse page during initial join, other user on /watch - navigating to their show');\r\n        sessionStorage.setItem('toperparty_pending_sync', JSON.stringify({\r\n          currentTime,\r\n          isPlaying,\r\n          timestamp: Date.now()\r\n        }));\r\n        window.location.href = url;\r\n        return;\r\n      }\r\n      \r\n      // If we're not on /watch at all, ignore this sync response\r\n      if (!isOnWatch) {\r\n        console.log('[SyncManager] Not on /watch page - ignoring sync response');\r\n        isInitializedRef.set(true); // Mark as initialized so we don't keep processing these\r\n        return;\r\n      }\r\n      \r\n      // Regular URL mismatch handling\r\n      if (url && url !== currentUrl) {\r\n        console.log('[SyncManager] URL mismatch - navigating from', currentUrl, 'to', url);\r\n        // Store the sync state to apply after navigation\r\n        sessionStorage.setItem('toperparty_pending_sync', JSON.stringify({\r\n          currentTime,\r\n          isPlaying,\r\n          timestamp: Date.now()\r\n        }));\r\n        // Navigate to the correct URL\r\n        window.location.href = url;\r\n        return;\r\n      }\r\n      \r\n      isInitializedRef.set(true);\r\n      \r\n      await applyRemote('initial-sync', 1500, async () => {\r\n        await netflix.seek(currentTime * 1000);\r\n        const localPaused = await netflix.isPaused();\r\n        \r\n        // Always sync to the remote state\r\n        if (isPlaying && localPaused) {\r\n          console.log('[SyncManager] Remote is playing, starting playback');\r\n          await netflix.play();\r\n        } else if (!isPlaying && !localPaused) {\r\n          console.log('[SyncManager] Remote is paused, pausing playback');\r\n          await netflix.pause();\r\n        }\r\n      });\r\n    },\r\n    async handlePlaybackControl(control, currentTime, fromUserId) {\r\n      console.log('[SyncManager] Remote', control.toUpperCase(), 'at', currentTime, 'from', fromUserId);\r\n      \r\n      await applyRemote(control, 1000, async () => {\r\n        // Seek to the exact position first\r\n        if (currentTime != null) {\r\n          const currentTimeMs = currentTime * 1000;\r\n          await netflix.seek(currentTimeMs);\r\n          console.log('[SyncManager] Seeked to', currentTime.toFixed(2) + 's before', control);\r\n        }\r\n        \r\n        // Then apply play/pause\r\n        if (control === 'play') {\r\n          await netflix.play();\r\n        } else {\r\n          await netflix.pause();\r\n        }\r\n      });\r\n    },\r\n    async handleSeek(currentTime, isPlaying, fromUserId) {\r\n      console.log('[SyncManager] Remote SEEK to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'from', fromUserId);\r\n      \r\n      await applyRemote('seek', 1200, async () => {\r\n        await netflix.seek(currentTime * 1000);\r\n        const isPaused = await netflix.isPaused();\r\n        \r\n        if (isPlaying && isPaused) {\r\n          await netflix.play();\r\n        } else if (!isPlaying && !isPaused) {\r\n          await netflix.pause();\r\n        }\r\n      });\r\n    }\r\n  };\r\n}\r\n","import { createSignalingHandlers } from './signaling.js';\r\nimport { createPeerConnectionFactory, addOrReplaceTrack } from './peerConnection.js';\r\nimport { createReconnectionManager } from './reconnect.js';\r\nimport { createRemoteVideoManager } from './ui.js';\r\n\r\nexport class WebRTCManager {\r\n  constructor(stateManager, uiManager) {\r\n    this.stateManager = stateManager;\r\n    this.uiManager = uiManager;\r\n    this.peerConnections = new Map();\r\n    this.remoteStreams = this.uiManager.getRemoteStreams();\r\n    this.remoteVideos = this.uiManager.getRemoteVideos();\r\n    this.peersThatLeft = new Set();\r\n    this.localStream = null;\r\n\r\n    const videoManager = createRemoteVideoManager(this.remoteVideos);\r\n    \r\n    // Create a placeholder object for circular dependency resolution\r\n    const reconnectionManager = {};\r\n    \r\n    const createPeer = createPeerConnectionFactory({\r\n      stateManager: this.stateManager,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      remoteStreams: this.remoteStreams,\r\n      remoteVideos: this.remoteVideos,\r\n      addRemoteVideo: videoManager.add,\r\n      attemptReconnection: (peerId) => reconnectionManager.attempt(peerId),\r\n      clearReconnection: (peerId) => reconnectionManager.clear(peerId),\r\n      removeRemoteVideo: (peerId) => {\r\n        videoManager.remove(peerId);\r\n        this.remoteStreams.delete(peerId);\r\n      },\r\n      peersThatLeft: this.peersThatLeft,\r\n      showReconnecting: videoManager.showReconnecting,\r\n      hideOverlay: videoManager.hideOverlay,\r\n      showPlaceholder: videoManager.showPlaceholder\r\n    });\r\n\r\n    // Now create the actual reconnection manager with createPeer available\r\n    Object.assign(reconnectionManager, createReconnectionManager({\r\n      stateManager: this.stateManager,\r\n      peerConnections: this.peerConnections,\r\n      peersThatLeft: this.peersThatLeft,\r\n      localStream: () => this.localStream,\r\n      createPeer: createPeer,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      addOrReplaceTrack\r\n    }));\r\n\r\n    this.reconnectionManager = reconnectionManager;\r\n    this.createPeer = createPeer;\r\n    this.videoManager = videoManager;\r\n\r\n    this.signalingHandlers = createSignalingHandlers({\r\n      getState: () => this.stateManager.getState(),\r\n      peerConnections: this.peerConnections,\r\n      peersThatLeft: this.peersThatLeft,\r\n      getLocalStream: () => this.localStream,\r\n      createPeer,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      addOrReplaceTrack,\r\n      clearReconnection: reconnectionManager.clear,\r\n      removeRemoteVideo: (peerId) => {\r\n        videoManager.remove(peerId);\r\n        this.remoteStreams.delete(peerId);\r\n      }\r\n    });\r\n  }\r\n\r\n  setLocalStream(stream) { this.localStream = stream; }\r\n  getLocalStream() { return this.localStream; }\r\n  \r\n  onLocalStreamAvailable(stream) {\r\n    this.localStream = stream;\r\n    this.peerConnections.forEach((pc) => {\r\n      try {\r\n        stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\r\n      } catch (e) {}\r\n    });\r\n  }\r\n\r\n  async handleSignal(message) {\r\n    console.log('[WebRTCManager] handleSignal called with:', message);\r\n    if (!message || !message.type) {\r\n      console.warn('[WebRTCManager] Invalid message:', message);\r\n      return;\r\n    }\r\n    const type = message.type;\r\n    const from = message.userId || message.from;\r\n    const to = message.to;\r\n    const state = this.stateManager.getState();\r\n    console.log('[WebRTCManager] Processing signal type:', type, 'from:', from, 'to:', to, 'myId:', state.userId);\r\n    \r\n    // Only check 'to' field for targeted messages (not broadcasts like JOIN)\r\n    // JOIN, LEAVE, and SYNC messages are broadcasts that don't have 'to' fields\r\n    const isTargetedMessage = type === 'OFFER' || type === 'ANSWER' || type === 'ICE_CANDIDATE' || type === 'SYNC_RESPONSE';\r\n    if (isTargetedMessage && to && to !== state.userId) {\r\n      console.log('[WebRTCManager] Ignoring targeted message not meant for me');\r\n      return;\r\n    }\r\n\r\n    if (type === 'JOIN' && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleJoin');\r\n      await this.signalingHandlers.handleJoin(from);\r\n    } else if (type === 'OFFER' && message.offer && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleOffer');\r\n      await this.signalingHandlers.handleOffer(from, message.offer);\r\n    } else if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleAnswer');\r\n      await this.signalingHandlers.handleAnswer(from, message.answer);\r\n    } else if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleIceCandidate');\r\n      await this.signalingHandlers.handleIceCandidate(from, message.candidate);\r\n    } else if (type === 'LEAVE' && from) {\r\n      console.log('[WebRTCManager] Dispatching to handleLeave');\r\n      this.signalingHandlers.handleLeave(from);\r\n    } else {\r\n      console.log('[WebRTCManager] Signal not handled - type:', type, 'from:', from, 'fromSelf:', from === state.userId, 'reasons:', {\r\n        JOIN: type === 'JOIN' ? `from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\r\n        OFFER: type === 'OFFER' ? `hasOffer=${!!message.offer}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\r\n        ANSWER: type === 'ANSWER' ? `hasAnswer=${!!message.answer}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\r\n        ICE: type === 'ICE_CANDIDATE' ? `hasCandidate=${!!message.candidate}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\r\n        LEAVE: type === 'LEAVE' ? `from=${!!from}` : 'N/A'\r\n      });\r\n    }\r\n  }\r\n\r\n  attemptReconnection(peerId) {\r\n    return this.reconnectionManager.attempt(peerId);\r\n  }\r\n\r\n  _sendSignal(message) {\r\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\r\n  }\r\n\r\n  showWaitingIndicator() {\r\n    console.log('[WebRTCManager] Showing waiting indicator');\r\n    this.videoManager.showWaitingIndicator();\r\n  }\r\n  \r\n  hideWaitingIndicator() {\r\n    console.log('[WebRTCManager] Hiding waiting indicator');\r\n    this.videoManager.hideWaitingIndicator();\r\n  }\r\n  \r\n  clearAll() {\r\n    console.log('[WebRTCManager] Clearing all connections and videos');\r\n    \r\n    // Hide waiting indicator\r\n    this.hideWaitingIndicator();\r\n    \r\n    this.peerConnections.forEach((pc) => {\r\n      try { pc.close(); } catch (e) {}\r\n    });\r\n    this.peerConnections.clear();\r\n    this.peersThatLeft.clear();\r\n    \r\n    // Clean up video elements and their containers\r\n    this.remoteVideos.forEach((v, peerId) => {\r\n      try { \r\n        if (v.srcObject) {\r\n          v.srcObject.getTracks().forEach(track => track.stop());\r\n          v.srcObject = null;\r\n        }\r\n      } catch (e) {}\r\n      \r\n      // Remove the container (which includes the video)\r\n      const container = document.getElementById('toperparty-container-' + peerId);\r\n      if (container) {\r\n        console.log('[WebRTCManager] Removing container for peer:', peerId);\r\n        container.remove();\r\n      } else if (v.parentElement) {\r\n        // Fallback: remove parent if it exists\r\n        v.parentElement.remove();\r\n      } else {\r\n        // Last resort: just remove the video\r\n        v.remove();\r\n      }\r\n    });\r\n    \r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    \r\n    // Extra cleanup: remove any orphaned toperparty elements\r\n    document.querySelectorAll('[id^=\"toperparty-container-\"]').forEach(el => {\r\n      console.log('[WebRTCManager] Removing orphaned container:', el.id);\r\n      el.remove();\r\n    });\r\n    document.querySelectorAll('[id^=\"toperparty-remote-\"]').forEach(el => {\r\n      console.log('[WebRTCManager] Removing orphaned video:', el.id);\r\n      el.remove();\r\n    });\r\n    document.querySelectorAll('[id^=\"toperparty-overlay-\"]').forEach(el => {\r\n      console.log('[WebRTCManager] Removing orphaned overlay:', el.id);\r\n      el.remove();\r\n    });\r\n    \r\n    if (this.localStream) {\r\n      this.localStream.getTracks().forEach(track => track.stop());\r\n      this.localStream = null;\r\n    }\r\n  }\r\n}\r\n","export function createRemoteVideoManager(remoteVideos) {\r\n  function createLoadingSpinner() {\r\n    // Create a more visually appealing spinner using CSS\r\n    const spinner = document.createElement('div');\r\n    spinner.className = 'toperparty-spinner';\r\n    spinner.style.cssText = `\r\n      width: 40px;\r\n      height: 40px;\r\n      border: 4px solid rgba(255, 255, 255, 0.3);\r\n      border-top: 4px solid #00aaff;\r\n      border-radius: 50%;\r\n      animation: toperparty-spin 1s linear infinite;\r\n      margin-bottom: 12px;\r\n    `;\r\n    return spinner;\r\n  }\r\n  \r\n  function makeDraggable(element) {\r\n    let isDragging = false;\r\n    let currentX;\r\n    let currentY;\r\n    let initialX;\r\n    let initialY;\r\n\r\n    element.addEventListener('mousedown', dragStart);\r\n    element.addEventListener('mouseup', dragEnd);\r\n    element.addEventListener('mousemove', drag);\r\n    element.style.cursor = 'move';\r\n\r\n    function dragStart(e) {\r\n      const computedStyle = window.getComputedStyle(element);\r\n      const rect = element.getBoundingClientRect();\r\n      \r\n      element.style.left = rect.left + 'px';\r\n      element.style.top = rect.top + 'px';\r\n      element.style.bottom = 'auto';\r\n      element.style.right = 'auto';\r\n      \r\n      initialX = e.clientX - rect.left;\r\n      initialY = e.clientY - rect.top;\r\n      isDragging = true;\r\n      element.style.opacity = '0.8';\r\n    }\r\n\r\n    function dragEnd(e) {\r\n      initialX = currentX;\r\n      initialY = currentY;\r\n      isDragging = false;\r\n      element.style.opacity = '1';\r\n    }\r\n\r\n    function drag(e) {\r\n      if (isDragging) {\r\n        e.preventDefault();\r\n        currentX = e.clientX - initialX;\r\n        currentY = e.clientY - initialY;\r\n        \r\n        const maxX = window.innerWidth - element.offsetWidth;\r\n        const maxY = window.innerHeight - element.offsetHeight;\r\n        currentX = Math.max(0, Math.min(currentX, maxX));\r\n        currentY = Math.max(0, Math.min(currentY, maxY));\r\n        \r\n        element.style.left = currentX + 'px';\r\n        element.style.top = currentY + 'px';\r\n      }\r\n    }\r\n  }\r\n\r\n  function add(peerId, stream) {\r\n    console.log('[RemoteVideoManager] Adding remote video for peer:', peerId, 'stream:', stream, 'tracks:', stream.getTracks());\r\n    console.log('[RemoteVideoManager] Current remoteVideos map size:', remoteVideos.size, 'peers:', Array.from(remoteVideos.keys()));\r\n    \r\n    // Check if video already exists in DOM (double-check for race conditions)\r\n    const existingInDom = document.getElementById('toperparty-remote-' + peerId);\r\n    if (existingInDom) {\r\n      console.log('[RemoteVideoManager] Video already exists in DOM for peer:', peerId, 'skipping duplicate creation');\r\n      // Update stream on existing element if different\r\n      if (existingInDom.srcObject !== stream) {\r\n        console.log('[RemoteVideoManager] Updating stream on existing video element');\r\n        existingInDom.srcObject = stream;\r\n        // Remove loading overlay if it exists\r\n        const overlay = document.getElementById('toperparty-overlay-' + peerId);\r\n        if (overlay) overlay.remove();\r\n      }\r\n      // Make sure it's tracked\r\n      if (!remoteVideos.has(peerId)) {\r\n        remoteVideos.set(peerId, existingInDom);\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Check if a placeholder container already exists\r\n    let container = document.getElementById('toperparty-container-' + peerId);\r\n    \r\n    if (!container) {\r\n      // No placeholder exists, create container from scratch\r\n      // Remove any stale references\r\n      remove(peerId);\r\n      \r\n      container = document.createElement('div');\r\n      container.id = 'toperparty-container-' + peerId;\r\n      container.style.position = 'fixed';\r\n      container.style.bottom = '145px';\r\n      container.style.right = (20 + (remoteVideos.size * 180)) + 'px';\r\n      container.style.width = '240px';\r\n      container.style.height = '160px';\r\n      container.style.zIndex = 999999;\r\n      container.style.border = '2px solid #00aaff';\r\n      container.style.borderRadius = '4px';\r\n      container.style.backgroundColor = '#000';\r\n    } else {\r\n      console.log('[RemoteVideoManager] Using existing placeholder container for peer:', peerId);\r\n    }\r\n    \r\n    const v = document.createElement('video');\r\n    v.id = 'toperparty-remote-' + peerId;\r\n    v.autoplay = true;\r\n    v.playsInline = true;\r\n    v.muted = true;\r\n    v.style.width = '100%';\r\n    v.style.height = '100%';\r\n    v.style.border = '2px solid #00aaff';\r\n    v.style.borderRadius = '4px';\r\n    v.style.backgroundColor = '#000';\r\n    \r\n    // Get or create overlay\r\n    let overlay = document.getElementById('toperparty-overlay-' + peerId);\r\n    if (!overlay) {\r\n      overlay = document.createElement('div');\r\n      overlay.id = 'toperparty-overlay-' + peerId;\r\n      overlay.style.position = 'absolute';\r\n      overlay.style.top = '0';\r\n      overlay.style.left = '0';\r\n      overlay.style.width = '100%';\r\n      overlay.style.height = '100%';\r\n      overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\r\n      overlay.style.display = 'flex';\r\n      overlay.style.flexDirection = 'column';\r\n      overlay.style.alignItems = 'center';\r\n      overlay.style.justifyContent = 'center';\r\n      overlay.style.color = '#fff';\r\n      overlay.style.fontSize = '14px';\r\n      overlay.style.fontFamily = 'Arial, sans-serif';\r\n      overlay.style.borderRadius = '4px';\r\n      overlay.style.pointerEvents = 'none';\r\n      \r\n      const spinner = createLoadingSpinner();\r\n      const text = document.createElement('div');\r\n      text.textContent = 'Connecting...';\r\n      text.style.fontWeight = '500';\r\n      \r\n      overlay.appendChild(spinner);\r\n      overlay.appendChild(text);\r\n    }\r\n    \r\n    // Add spinner animation styles (only once)\r\n    if (!document.getElementById('toperparty-spinner-styles')) {\r\n      const style = document.createElement('style');\r\n      style.id = 'toperparty-spinner-styles';\r\n      style.textContent = `\r\n        @keyframes toperparty-spin {\r\n          0% { transform: rotate(0deg); }\r\n          100% { transform: rotate(360deg); }\r\n        }\r\n        @keyframes toperparty-pulse {\r\n          0%, 100% { opacity: 0.3; }\r\n          50% { opacity: 1; }\r\n        }\r\n      `;\r\n      document.head.appendChild(style);\r\n    }\r\n    \r\n    container.appendChild(v);\r\n    if (!overlay.parentElement) {\r\n      container.appendChild(overlay);\r\n    }\r\n    if (!container.parentElement) {\r\n      document.body.appendChild(container);\r\n      // Make container draggable if newly created\r\n      makeDraggable(container);\r\n    }\r\n    console.log('[RemoteVideoManager] Added video to container:', container.id);\r\n    \r\n    // Verify stream has active tracks\r\n    const activeTracks = stream.getTracks().filter(t => t.readyState === 'live');\r\n    console.log('[RemoteVideoManager] Stream has', activeTracks.length, 'active tracks:', \r\n      activeTracks.map(t => `${t.kind}:${t.id.substring(0,8)}`).join(', '));\r\n    \r\n    try { \r\n      v.srcObject = stream;\r\n      console.log('[RemoteVideoManager] Set srcObject successfully');\r\n    } catch (e) { \r\n      console.warn('[RemoteVideoManager] srcObject failed:', e);\r\n    }\r\n    \r\n    remoteVideos.set(peerId, v);\r\n    \r\n    // Handle video playback with better error handling\r\n    const playVideo = () => {\r\n      v.play().then(() => {\r\n        console.log('[RemoteVideoManager] Video playing, unmuting and removing overlay');\r\n        v.muted = false;\r\n        v.volume = 1.0;\r\n        // Remove loading overlay\r\n        overlay.remove();\r\n      }).catch((e) => { \r\n        console.warn('[RemoteVideoManager] Play failed:', e.name, e.message);\r\n        // Try unmuting anyway in case autoplay blocked\r\n        v.muted = false;\r\n        // Still remove overlay even if play failed\r\n        overlay.remove();\r\n      });\r\n    };\r\n    \r\n    // If stream already has tracks, play immediately\r\n    if (activeTracks.length > 0) {\r\n      playVideo();\r\n    } else {\r\n      // Wait for tracks to become active\r\n      console.log('[RemoteVideoManager] Waiting for stream tracks to become active');\r\n      overlay.innerHTML = '<div style=\"text-align: center;\"><div style=\"margin-bottom: 8px;\"></div><div>Waiting for stream...</div></div>';\r\n      const checkTracks = setInterval(() => {\r\n        const nowActive = stream.getTracks().filter(t => t.readyState === 'live');\r\n        if (nowActive.length > 0) {\r\n          clearInterval(checkTracks);\r\n          console.log('[RemoteVideoManager] Tracks now active, playing video');\r\n          playVideo();\r\n        }\r\n      }, 100);\r\n      // Give up after 5 seconds and remove overlay anyway\r\n      setTimeout(() => {\r\n        clearInterval(checkTracks);\r\n        if (overlay.parentNode) {\r\n          console.log('[RemoteVideoManager] Timeout waiting for tracks, removing overlay');\r\n          overlay.remove();\r\n        }\r\n      }, 5000);\r\n    }\r\n  }\r\n  \r\n  function remove(peerId) {\r\n    console.log('[RemoteVideoManager] Removing remote video for peer:', peerId);\r\n    \r\n    // Remove from map\r\n    const v = remoteVideos.get(peerId);\r\n    if (v) {\r\n      try { \r\n        if (v.srcObject) {\r\n          v.srcObject.getTracks().forEach(track => track.stop());\r\n          v.srcObject = null;\r\n        }\r\n      } catch (e) {\r\n        console.warn('[RemoteVideoManager] Error cleaning up stream:', e);\r\n      }\r\n      // Remove the container (which includes the video)\r\n      const container = v.parentElement;\r\n      if (container && container.id === 'toperparty-container-' + peerId) {\r\n        container.remove();\r\n      } else {\r\n        v.remove();\r\n      }\r\n      remoteVideos.delete(peerId);\r\n    }\r\n    \r\n    // Also check DOM for any orphaned elements (extra safety)\r\n    const domContainer = document.getElementById('toperparty-container-' + peerId);\r\n    if (domContainer) {\r\n      console.log('[RemoteVideoManager] Found orphaned container, removing');\r\n      domContainer.remove();\r\n    }\r\n    \r\n    const domElement = document.getElementById('toperparty-remote-' + peerId);\r\n    if (domElement && domElement !== v) {\r\n      console.log('[RemoteVideoManager] Found orphaned video element, removing');\r\n      try {\r\n        if (domElement.srcObject) {\r\n          domElement.srcObject = null;\r\n        }\r\n      } catch (e) {}\r\n      domElement.remove();\r\n    }\r\n    \r\n    // Clean up overlay if it exists\r\n    const overlay = document.getElementById('toperparty-overlay-' + peerId);\r\n    if (overlay) {\r\n      overlay.remove();\r\n    }\r\n  }\r\n  \r\n  function showReconnecting(peerId) {\r\n    console.log('[RemoteVideoManager] Showing reconnecting overlay for peer:', peerId);\r\n    \r\n    // Check if overlay already exists\r\n    let overlay = document.getElementById('toperparty-overlay-' + peerId);\r\n    if (overlay) {\r\n      // Update existing overlay content\r\n      overlay.innerHTML = '';\r\n      const spinner = createLoadingSpinner();\r\n      const text = document.createElement('div');\r\n      text.textContent = 'Reconnecting...';\r\n      text.style.fontWeight = '500';\r\n      overlay.appendChild(spinner);\r\n      overlay.appendChild(text);\r\n      overlay.style.display = 'flex';\r\n      return;\r\n    }\r\n    \r\n    // Create new overlay if it doesn't exist\r\n    const container = document.getElementById('toperparty-container-' + peerId);\r\n    if (!container) {\r\n      console.warn('[RemoteVideoManager] Cannot show reconnecting - container not found');\r\n      return;\r\n    }\r\n    \r\n    overlay = document.createElement('div');\r\n    overlay.id = 'toperparty-overlay-' + peerId;\r\n    overlay.style.position = 'absolute';\r\n    overlay.style.top = '0';\r\n    overlay.style.left = '0';\r\n    overlay.style.width = '100%';\r\n    overlay.style.height = '100%';\r\n    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\r\n    overlay.style.display = 'flex';\r\n    overlay.style.flexDirection = 'column';\r\n    overlay.style.alignItems = 'center';\r\n    overlay.style.justifyContent = 'center';\r\n    overlay.style.color = '#fff';\r\n    overlay.style.fontSize = '14px';\r\n    overlay.style.fontFamily = 'Arial, sans-serif';\r\n    overlay.style.borderRadius = '4px';\r\n    overlay.style.pointerEvents = 'none';\r\n    \r\n    const spinner = createLoadingSpinner();\r\n    const text = document.createElement('div');\r\n    text.textContent = 'Reconnecting...';\r\n    text.style.fontWeight = '500';\r\n    \r\n    overlay.appendChild(spinner);\r\n    overlay.appendChild(text);\r\n    container.appendChild(overlay);\r\n  }\r\n  \r\n  function hideOverlay(peerId) {\r\n    const overlay = document.getElementById('toperparty-overlay-' + peerId);\r\n    if (overlay) {\r\n      console.log('[RemoteVideoManager] Hiding overlay for peer:', peerId);\r\n      overlay.remove();\r\n    }\r\n  }\r\n  \r\n  function showWaitingIndicator() {\r\n    // Remove any existing waiting indicator first\r\n    hideWaitingIndicator();\r\n    \r\n    console.log('[RemoteVideoManager] Showing waiting indicator');\r\n    const container = document.createElement('div');\r\n    container.id = 'toperparty-waiting-indicator';\r\n    container.style.position = 'fixed';\r\n    container.style.bottom = '145px';\r\n    container.style.right = '20px';\r\n    container.style.width = '240px';\r\n    container.style.height = '160px';\r\n    container.style.zIndex = 999999;\r\n    container.style.border = '2px solid #00aaff';\r\n    container.style.borderRadius = '4px';\r\n    container.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';\r\n    container.style.display = 'flex';\r\n    container.style.flexDirection = 'column';\r\n    container.style.alignItems = 'center';\r\n    container.style.justifyContent = 'center';\r\n    container.style.color = '#fff';\r\n    container.style.fontSize = '14px';\r\n    container.style.fontFamily = 'Arial, sans-serif';\r\n    container.style.pointerEvents = 'none';\r\n    \r\n    const spinner = createLoadingSpinner();\r\n    const text = document.createElement('div');\r\n    text.textContent = 'Waiting for others...';\r\n    text.style.fontWeight = '500';\r\n    text.style.marginTop = '8px';\r\n    \r\n    container.appendChild(spinner);\r\n    container.appendChild(text);\r\n    document.body.appendChild(container);\r\n  }\r\n  \r\n  function hideWaitingIndicator() {\r\n    const indicator = document.getElementById('toperparty-waiting-indicator');\r\n    if (indicator) {\r\n      console.log('[RemoteVideoManager] Hiding waiting indicator');\r\n      indicator.remove();\r\n    }\r\n  }\r\n  \r\n  function showPlaceholder(peerId) {\r\n    console.log('[RemoteVideoManager] Showing placeholder for peer:', peerId);\r\n    \r\n    // Hide waiting indicator when first peer connects\r\n    hideWaitingIndicator();\r\n    \r\n    // Check if container already exists\r\n    let container = document.getElementById('toperparty-container-' + peerId);\r\n    if (container) {\r\n      console.log('[RemoteVideoManager] Placeholder already exists for peer:', peerId, '- reusing it');\r\n      return;\r\n    }\r\n    \r\n    console.log('[RemoteVideoManager] Creating NEW placeholder container for peer:', peerId);\r\n    \r\n    // Create container immediately\r\n    container = document.createElement('div');\r\n    container.id = 'toperparty-container-' + peerId;\r\n    container.style.position = 'fixed';\r\n    container.style.bottom = '145px';\r\n    container.style.right = (20 + (remoteVideos.size * 180)) + 'px';\r\n    container.style.width = '240px';\r\n    container.style.height = '160px';\r\n    container.style.zIndex = 999999;\r\n    container.style.border = '2px solid #00aaff';\r\n    container.style.borderRadius = '4px';\r\n    container.style.backgroundColor = '#000';\r\n    \r\n    // Create loading overlay\r\n    const overlay = document.createElement('div');\r\n    overlay.id = 'toperparty-overlay-' + peerId;\r\n    overlay.style.position = 'absolute';\r\n    overlay.style.top = '0';\r\n    overlay.style.left = '0';\r\n    overlay.style.width = '100%';\r\n    overlay.style.height = '100%';\r\n    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\r\n    overlay.style.display = 'flex';\r\n    overlay.style.flexDirection = 'column';\r\n    overlay.style.alignItems = 'center';\r\n    overlay.style.justifyContent = 'center';\r\n    overlay.style.color = '#fff';\r\n    overlay.style.fontSize = '14px';\r\n    overlay.style.fontFamily = 'Arial, sans-serif';\r\n    overlay.style.borderRadius = '4px';\r\n    overlay.style.pointerEvents = 'none';\r\n    \r\n    const spinner = createLoadingSpinner();\r\n    const text = document.createElement('div');\r\n    text.textContent = 'Connecting...';\r\n    text.style.fontWeight = '500';\r\n    \r\n    overlay.appendChild(spinner);\r\n    overlay.appendChild(text);\r\n    container.appendChild(overlay);\r\n    document.body.appendChild(container);\r\n    \r\n    // Make container draggable immediately\r\n    makeDraggable(container);\r\n    \r\n    console.log('[RemoteVideoManager] Created placeholder container:', container.id);\r\n  }\r\n  \r\n  return { add, remove, showReconnecting, hideOverlay, showPlaceholder, showWaitingIndicator, hideWaitingIndicator };\r\n}\r\n","export function createReconnectionManager({ stateManager, peerConnections, peersThatLeft, localStream, createPeer, sendSignal, addOrReplaceTrack }) {\r\n  const attempts = new Map();\r\n  const timeouts = new Map();\r\n  \r\n  function clear(peerId) {\r\n    attempts.delete(peerId);\r\n    const handle = timeouts.get(peerId);\r\n    if (handle) {\r\n      clearTimeout(handle);\r\n      timeouts.delete(peerId);\r\n    }\r\n  }\r\n  \r\n  async function attempt(peerId) {\r\n    if (!stateManager.isInParty()) return;\r\n    if (peersThatLeft.has(peerId)) {\r\n      clear(peerId);\r\n      return;\r\n    }\r\n    const count = attempts.get(peerId) || 0;\r\n    const maxAttempts = 5;\r\n    // Faster reconnection: 500ms, 1s, 2s, 4s, 8s (instead of 1s, 2s, 4s, 8s, 16s)\r\n    const backoffDelay = Math.min(500 * Math.pow(2, count), 10000);\r\n    if (count >= maxAttempts) {\r\n      console.log('[Reconnection] Max attempts reached for peer:', peerId);\r\n      clear(peerId);\r\n      return;\r\n    }\r\n    console.log('[Reconnection] Attempting reconnection for peer:', peerId, 'attempt:', count + 1, 'delay:', backoffDelay + 'ms');\r\n    attempts.set(peerId, count + 1);\r\n    const existing = timeouts.get(peerId);\r\n    if (existing) clearTimeout(existing);\r\n    const handle = setTimeout(async () => {\r\n      const oldPc = peerConnections.get(peerId);\r\n      if (oldPc) {\r\n        try { oldPc.close(); } catch (e) {}\r\n        peerConnections.delete(peerId);\r\n      }\r\n      try {\r\n        const pc = createPeer(peerId);\r\n        peerConnections.set(peerId, pc);\r\n        const stream = typeof localStream === 'function' ? localStream() : localStream;\r\n        if (stream) {\r\n          stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\r\n        }\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n        const state = stateManager.getState();\r\n        sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('[WebRTCManager] Reconnection failed:', err);\r\n        attempt(peerId);\r\n      }\r\n    }, backoffDelay);\r\n    timeouts.set(peerId, handle);\r\n  }\r\n  \r\n  return { attempt, clear };\r\n}\r\n","export function createSignalingHandlers({ getState, peerConnections, peersThatLeft, getLocalStream, createPeer, sendSignal, addOrReplaceTrack, clearReconnection, removeRemoteVideo }) {\r\n  return {\r\n    async handleJoin(from) {\r\n      console.log('[Signaling] Handling JOIN from', from);\r\n      const state = getState();\r\n      if (from === state.userId) {\r\n        console.log('[Signaling] Ignoring JOIN from self');\r\n        return;\r\n      }\r\n      \r\n      // First, clear any reconnection attempts - peer has explicitly rejoined\r\n      clearReconnection(from);\r\n      peersThatLeft.delete(from);\r\n      \r\n      let pc = peerConnections.get(from);\r\n      if (pc) {\r\n        const connectionState = pc.connectionState;\r\n        console.log('[Signaling] Already have peer connection for', from, 'state:', connectionState);\r\n        \r\n        // If connection is still good (connected/connecting), reuse it\r\n        if (connectionState === 'connected' || connectionState === 'connecting') {\r\n          console.log('[Signaling] Reusing existing connection - ensuring tracks are present');\r\n          const stream = getLocalStream();\r\n          if (stream) {\r\n            let needsRenegotiation = false;\r\n            stream.getTracks().forEach(t => {\r\n              const senders = pc.getSenders();\r\n              const existingSender = senders.find(s => s.track && s.track.kind === t.kind);\r\n              if (!existingSender || existingSender.track.id !== t.id) {\r\n                console.log('[Signaling] Track changed, replacing:', t.kind, t.id);\r\n                addOrReplaceTrack(pc, t, stream);\r\n                needsRenegotiation = true;\r\n              }\r\n            });\r\n            \r\n            // Only renegotiate if tracks changed\r\n            if (needsRenegotiation && pc.signalingState === 'stable') {\r\n              console.log('[Signaling] Renegotiating due to track changes');\r\n              const offer = await pc.createOffer();\r\n              await pc.setLocalDescription(offer);\r\n              sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\r\n            }\r\n          }\r\n          return;\r\n        }\r\n        \r\n        // For any other state (disconnected/failed/closed), clean it up and create new connection\r\n        // This handles the case where a peer refreshes - their old connection is stuck in \r\n        // disconnected/failed state, so we need to clean it up when they rejoin\r\n        console.log('[Signaling] Cleaning up existing connection in state:', connectionState);\r\n        clearReconnection(from);\r\n        removeRemoteVideo(from);\r\n        try { pc.close(); } catch (e) {}\r\n        peerConnections.delete(from);\r\n        pc = null;\r\n      }\r\n      \r\n      if (!pc) {\r\n        try {\r\n          console.log('[Signaling] Creating new peer connection for', from);\r\n          pc = createPeer(from);\r\n          peerConnections.set(from, pc);\r\n          const stream = getLocalStream();\r\n          console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\r\n          if (stream) {\r\n            stream.getTracks().forEach(t => {\r\n              console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\r\n              addOrReplaceTrack(pc, t, stream);\r\n            });\r\n          } else {\r\n            console.warn('[Signaling] No local stream available when handling JOIN');\r\n          }\r\n          console.log('[Signaling] Creating and sending OFFER to', from);\r\n          const offer = await pc.createOffer();\r\n          await pc.setLocalDescription(offer);\r\n          sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\r\n        } catch (err) {\r\n          console.error('[Signaling] Error handling JOIN:', err);\r\n          peerConnections.delete(from);\r\n        }\r\n      }\r\n    },\r\n    async handleOffer(from, offer) {\r\n      console.log('[Signaling] Handling OFFER from', from);\r\n      const state = getState();\r\n      if (from === state.userId) {\r\n        console.log('[Signaling] Ignoring OFFER from self');\r\n        return;\r\n      }\r\n      let pc = peerConnections.get(from);\r\n      if (pc) {\r\n        console.log('[Signaling] Existing peer connection state:', pc.signalingState);\r\n        if (pc.signalingState !== 'closed' && pc.signalingState !== 'stable') {\r\n          console.log('[Signaling] Closing existing peer connection in state:', pc.signalingState);\r\n          try { pc.close(); } catch (e) {}\r\n          peerConnections.delete(from);\r\n          pc = null;\r\n        } else if (pc.signalingState === 'stable') {\r\n          // If stable, this might be a renegotiation - close and recreate\r\n          console.log('[Signaling] Closing stable peer connection for renegotiation');\r\n          try { pc.close(); } catch (e) {}\r\n          peerConnections.delete(from);\r\n          pc = null;\r\n        }\r\n      }\r\n      if (!pc) {\r\n        console.log('[Signaling] Creating new peer connection for', from);\r\n        // Clear any reconnection attempts when receiving an offer\r\n        clearReconnection(from);\r\n        peersThatLeft.delete(from);\r\n        pc = createPeer(from);\r\n        peerConnections.set(from, pc);\r\n      }\r\n      try {\r\n        console.log('[Signaling] Setting remote description, current state:', pc.signalingState);\r\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n        const stream = getLocalStream();\r\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\r\n        if (stream) {\r\n          stream.getTracks().forEach(t => {\r\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\r\n            addOrReplaceTrack(pc, t, stream);\r\n          });\r\n        } else {\r\n          console.warn('[Signaling] No local stream available when handling OFFER');\r\n        }\r\n        console.log('[Signaling] Creating and sending ANSWER to', from);\r\n        const answer = await pc.createAnswer();\r\n        await pc.setLocalDescription(answer);\r\n        sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('[Signaling] Error handling offer:', err.name, err.message);\r\n        console.error('[Signaling] Full error:', err);\r\n        peerConnections.delete(from);\r\n        try { pc.close(); } catch (e) {}\r\n      }\r\n    },\r\n    async handleAnswer(from, answer) {\r\n      console.log('[Signaling] Handling ANSWER from', from);\r\n      const pc = peerConnections.get(from);\r\n      if (!pc) {\r\n        console.warn('[Signaling] Cannot handle ANSWER - no peer connection found for', from);\r\n        return;\r\n      }\r\n      \r\n      console.log('[Signaling] Peer connection state:', {\r\n        signalingState: pc.signalingState,\r\n        connectionState: pc.connectionState,\r\n        iceConnectionState: pc.iceConnectionState\r\n      });\r\n      \r\n      if (pc.signalingState === 'have-local-offer') {\r\n        console.log('[Signaling] Setting remote description from ANSWER');\r\n        try {\r\n          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n          console.log('[Signaling] Remote description set successfully');\r\n        } catch (err) {\r\n          console.error('[Signaling] Error handling answer:', err.name, err.message);\r\n          console.error('[Signaling] Full error:', err);\r\n          // If the peer connection is in a bad state, close it and remove it\r\n          if (err.name === 'InvalidStateError' || err.name === 'OperationError') {\r\n            console.log('[Signaling] Closing peer connection due to state error');\r\n            try { pc.close(); } catch (e) {}\r\n            peerConnections.delete(from);\r\n          }\r\n        }\r\n      } else if (pc.signalingState === 'stable') {\r\n        console.log('[Signaling] Received ANSWER but already in stable state (connection:', pc.connectionState + ') - likely duplicate, ignoring');\r\n      } else if (pc.signalingState === 'have-remote-offer') {\r\n        console.warn('[Signaling] Received ANSWER but expecting to send one (have-remote-offer) - might be glare, ignoring');\r\n      } else if (pc.signalingState === 'closed') {\r\n        console.warn('[Signaling] Received ANSWER but peer connection is closed - ignoring');\r\n      } else {\r\n        console.warn('[Signaling] Cannot handle ANSWER - unexpected state:', pc.signalingState);\r\n      }\r\n    },\r\n    async handleIceCandidate(from, candidate) {\r\n      console.log('[Signaling] Handling ICE_CANDIDATE from', from);\r\n      const pc = peerConnections.get(from);\r\n      if (pc) {\r\n        try {\r\n          await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n          console.log('[Signaling] ICE candidate added successfully');\r\n        } catch (err) {\r\n          console.warn('[Signaling] Error adding ICE candidate', err);\r\n        }\r\n      } else {\r\n        console.warn('[Signaling] No peer connection found for ICE candidate from', from);\r\n      }\r\n    },\r\n    handleLeave(from) {\r\n      console.log('[Signaling] Handling LEAVE from', from);\r\n      peersThatLeft.add(from);\r\n      const pc = peerConnections.get(from);\r\n      if (pc) {\r\n        try { pc.close(); } catch (e) {}\r\n        peerConnections.delete(from);\r\n      }\r\n      clearReconnection(from);\r\n      removeRemoteVideo(from);\r\n    }\r\n  };\r\n}\r\n","export class URLSync {\r\n  constructor(stateManager, onWatchPageChange, onNavigateToWatch, onLeaveWatch) {\r\n    this.stateManager = stateManager;\r\n    this.urlMonitorInterval = null;\r\n    this.lastUrl = null;\r\n    this.onWatchPageChange = onWatchPageChange || (() => {});\r\n    this.onNavigateToWatch = onNavigateToWatch || (() => {});\r\n    this.onLeaveWatch = onLeaveWatch || (() => {});\r\n    this.handleUrlChange = this.handleUrlChange.bind(this);\r\n  }\r\n  \r\n  handleUrlChange() {\r\n    const currentUrl = window.location.href;\r\n    if (currentUrl !== this.lastUrl) {\r\n      console.log('[URLSync] URL changed from', this.lastUrl, 'to', currentUrl);\r\n      const lastPath = this.lastUrl ? new URL(this.lastUrl).pathname : '';\r\n      const currentPath = new URL(currentUrl).pathname;\r\n      \r\n      // Check if we navigated to a different /watch page or left /watch\r\n      const wasOnWatch = lastPath.startsWith('/watch');\r\n      const nowOnWatch = currentPath.startsWith('/watch');\r\n      const watchPageChanged = wasOnWatch && nowOnWatch && lastPath !== currentPath;\r\n      const navigatedToWatch = !wasOnWatch && nowOnWatch;\r\n      const leftWatch = wasOnWatch && !nowOnWatch;\r\n      \r\n      this.lastUrl = currentUrl;\r\n      \r\n      // If we changed to a different /watch page, reinitialize sync\r\n      if (watchPageChanged) {\r\n        console.log('[URLSync] Watch page changed - triggering sync reinitialization');\r\n        this.onWatchPageChange();\r\n      }\r\n      \r\n      // If we navigated TO a /watch page from elsewhere, initialize sync\r\n      if (navigatedToWatch) {\r\n        console.log('[URLSync] Navigated to /watch page - triggering sync initialization');\r\n        this.onNavigateToWatch();\r\n      }\r\n      \r\n      // If we left a /watch page, teardown sync\r\n      if (leftWatch) {\r\n        console.log('[URLSync] Left /watch page - triggering sync teardown');\r\n        this.onLeaveWatch();\r\n      }\r\n      \r\n      const state = this.stateManager.getState();\r\n      \r\n      // Broadcast all Netflix URL changes to the party\r\n      // This keeps everyone synchronized on browse, title pages, etc.\r\n      if (state.partyActive) {\r\n        console.log('[URLSync] Broadcasting URL change to party:', currentPath);\r\n        this.stateManager.safeSendMessage({ \r\n          type: 'URL_CHANGE', \r\n          url: currentUrl \r\n        });\r\n      }\r\n      \r\n      // If someone leaves /watch, pause the video for everyone\r\n      if (state.partyActive && leftWatch) {\r\n        console.log('[URLSync] Left /watch page - sending pause to all clients');\r\n        this.stateManager.safeSendMessage({ \r\n          type: 'PLAY_PAUSE', \r\n          control: 'pause',\r\n          timestamp: 0\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  start() { \r\n    this.lastUrl = window.location.href;\r\n    console.log('[URLSync] Starting URL monitoring, current URL:', this.lastUrl);\r\n    \r\n    // Clear any existing interval and listeners\r\n    this.stop();\r\n    \r\n    // Listen for popstate events (back/forward button, pushState)\r\n    window.addEventListener('popstate', this.handleUrlChange);\r\n    \r\n    // Listen for pushState/replaceState by monkey-patching\r\n    const originalPushState = history.pushState;\r\n    const originalReplaceState = history.replaceState;\r\n    \r\n    history.pushState = (...args) => {\r\n      originalPushState.apply(history, args);\r\n      this.handleUrlChange();\r\n    };\r\n    \r\n    history.replaceState = (...args) => {\r\n      originalReplaceState.apply(history, args);\r\n      this.handleUrlChange();\r\n    };\r\n    \r\n    // Also poll as a fallback (in case Netflix uses some other navigation method)\r\n    this.urlMonitorInterval = setInterval(() => {\r\n      this.handleUrlChange();\r\n    }, 500);\r\n  }\r\n  \r\n  stop() {\r\n    console.log('[URLSync] Stopping URL monitoring');\r\n    \r\n    if (this.urlMonitorInterval) { \r\n      clearInterval(this.urlMonitorInterval); \r\n      this.urlMonitorInterval = null; \r\n    }\r\n    \r\n    window.removeEventListener('popstate', this.handleUrlChange);\r\n    \r\n    this.lastUrl = null;\r\n  }\r\n  saveState() {\r\n    const state = this.stateManager.getState();\r\n    if (!state.partyActive) return;\r\n    const existing = this.getRestorationState() || {};\r\n    const payload = {\r\n      roomId: state.roomId,\r\n      currentTime: existing.currentTime || null,\r\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\r\n      timestamp: Date.now()\r\n    };\r\n    sessionStorage.setItem('toperparty_restore', JSON.stringify(payload));\r\n  }\r\n  clearState() { sessionStorage.removeItem('toperparty_restore'); }\r\n  getRestorationState() {\r\n    const stored = sessionStorage.getItem('toperparty_restore');\r\n    if (!stored) return null;\r\n    try {\r\n      const state = JSON.parse(stored);\r\n      if (Date.now() - state.timestamp < 30000) { return state; }\r\n    } catch (e) { console.error('[toperparty] Failed to parse restoration state:', e); }\r\n    return null;\r\n  }\r\n}\r\n"],"names":["SyncLock","constructor","this","suppressLocalUntil","set","durationMs","Date","now","isActive","attachPlaybackListeners","video","state","isInitializedRef","lock","onPlay","onPause","onSeek","handlePlay","console","log","isInitialized","get","lockActive","handlePause","handleSeeked","addEventListener","MutableRef","value","v","addOrReplaceTrack","pc","track","stream","existingSender","getSenders","find","s","kind","replaceTrack","catch","e","warn","addTrack","wasPartyActive","sessionStorage","getItem","staleContainers","document","querySelectorAll","staleVideos","staleOverlays","staleLocalVideo","getElementById","staleWaitingIndicator","forEach","el","id","remove","stateManager","partyActive","userId","roomId","restoringPartyState","startParty","setItem","stopParty","removeItem","getUserId","getRoomId","getState","isInParty","setRestoringFlag","isExtensionContextValid","chrome","runtime","safeSendMessage","message","callback","type","sendMessage","response","lastError","error","notice","createElement","style","cssText","innerHTML","body","appendChild","uiManager","localPreviewVideo","remoteVideos","Map","remoteStreams","streamMonitorInterval","makeDraggable","element","currentX","currentY","initialX","initialY","isDragging","computedStyle","window","getComputedStyle","rect","bottom","left","right","getBoundingClientRect","top","clientX","clientY","opacity","preventDefault","maxX","innerWidth","offsetWidth","maxY","innerHeight","offsetHeight","Math","max","min","xPos","yPos","cursor","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","clearInterval","attachLocalPreview","removeLocalPreview","autoplay","muted","playsInline","position","width","height","zIndex","border","borderRadius","transform","srcObject","src","URL","createObjectURL","play","err","clearAll","clear","netflixController","injectAPIBridge","script","getURL","head","documentElement","onload","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","setTimeout","dispatchEvent","CustomEvent","pause","seek","timeMs","getCurrentTime","isPaused","setVolume","level","getVolume","getVideoElement","location","pathname","startsWith","videos","syncManager","netflix","listeners","remote","async","applyRemote","actionName","actionFn","handleRequestSync","fromUserId","currentUrl","href","currentTime","currentTimeSeconds","toFixed","targetUserId","isPlaying","url","handleSyncResponse","currentPath","isOnWatch","isOnBrowse","otherIsOnWatch","JSON","stringify","timestamp","localPaused","handlePlaybackControl","control","toUpperCase","currentTimeMs","handleSeek","createRemoteHandlers","setup","waitForVideo","pendingSyncStr","pendingSync","parse","vid","broadcastPlay","broadcastPause","broadcastSeek","teardown","reject","timeout","Error","check","clearTimeout","isOnWatchPage","paused","webrtcManager","peerConnections","peersThatLeft","Set","localStream","videoManager","createLoadingSpinner","spinner","className","peerId","getTracks","stop","container","parentElement","delete","domContainer","domElement","overlay","hideWaitingIndicator","indicator","add","size","Array","from","keys","existingInDom","has","backgroundColor","display","flexDirection","alignItems","justifyContent","color","fontSize","fontFamily","pointerEvents","text","textContent","fontWeight","activeTracks","filter","t","readyState","length","map","substring","join","playVideo","then","volume","name","checkTracks","setInterval","parentNode","showReconnecting","hideOverlay","showPlaceholder","showWaitingIndicator","marginTop","createRemoteVideoManager","reconnectionManager","createPeer","sendSignal","addRemoteVideo","attemptReconnection","clearReconnection","removeRemoteVideo","RTCPeerConnection","iceServers","urls","onicecandidate","event","candidate","to","ontrack","streams","MediaStream","hasVideoInMap","hasVideoInDom","existingVideo","tracks","hasAudio","some","hasVideo","onconnectionstatechange","connectionState","createPeerConnectionFactory","msg","_sendSignal","attempt","Object","assign","attempts","timeouts","handle","count","backoffDelay","pow","existing","oldPc","close","offer","createOffer","setLocalDescription","localDescription","createReconnectionManager","signalingHandlers","getLocalStream","handleJoin","needsRenegotiation","signalingState","handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleAnswer","iceConnectionState","handleIceCandidate","addIceCandidate","RTCIceCandidate","handleLeave","createSignalingHandlers","setLocalStream","onLocalStreamAvailable","handleSignal","JOIN","OFFER","ANSWER","ICE","LEAVE","urlSync","onWatchPageChange","onNavigateToWatch","onLeaveWatch","urlMonitorInterval","lastUrl","handleUrlChange","bind","lastPath","wasOnWatch","nowOnWatch","watchPageChanged","navigatedToWatch","leftWatch","start","originalPushState","history","pushState","originalReplaceState","replaceState","apply","saveState","getRestorationState","payload","clearState","stored","videoElementMonitor","startVideoElementMonitoring","videoId","restorationState","success","navigator","mediaDevices","getUserMedia","audio","onMessage","addListener","request","sender","sendResponse","PopStateEvent"],"ignoreList":[],"sourceRoot":""}