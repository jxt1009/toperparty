{"version":3,"file":"content-script.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB,SAAS;AACvD,uEAAuE,UAAU,iBAAiB;AAClG,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzDA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7EA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4CAA4C;AAC1D;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,QAAQ;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0BAA0B;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7OA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5DA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAyE;AACtG,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2EAA2E;AACtG,QAAQ;AACR;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ,WAAW,aAAa,GAAG,YAAY,OAAO,aAAa;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2EAA2E;AACtG;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wCAAwC;AAClD,UAAU;AACV;AACA,KAAK;AACL;AACA;AACA;AACA,2BAA2B,mFAAmF;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8BAA8B,eAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UClZA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;ACNA;AACA;AAC0D;AACU;AACZ;AACI;AACR;AACJ;AAChD;AACA;AACA,yBAAyB,mEAAY;AACrC,sBAAsB,6DAAS;AAC/B,8BAA8B,6EAAiB;AAC/C,wBAAwB,iEAAW;AACnC,0BAA0B,qEAAa;AACvC,oBAAoB,yDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK,SAAS;AACd;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,GAAG,QAAQ;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS,YAAY,YAAY,cAAc;AAC9D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAiD;AACxE,OAAO;AACP;AACA;AACA,uBAAuB,oCAAoC;AAC3D,OAAO;AACP;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iCAAiC;AACnG,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG,SAAS;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA","sources":["webpack://toperparty/./chrome-extension/modules/netflix-controller.js","webpack://toperparty/./chrome-extension/modules/state-manager.js","webpack://toperparty/./chrome-extension/modules/sync-manager.js","webpack://toperparty/./chrome-extension/modules/ui-manager.js","webpack://toperparty/./chrome-extension/modules/url-sync.js","webpack://toperparty/./chrome-extension/modules/webrtc-manager.js","webpack://toperparty/webpack/bootstrap","webpack://toperparty/webpack/runtime/define property getters","webpack://toperparty/webpack/runtime/hasOwnProperty shorthand","webpack://toperparty/webpack/runtime/make namespace object","webpack://toperparty/./chrome-extension/content-script.js"],"sourcesContent":["// netflix-controller.js - Netflix player API wrapper\r\n\r\nexport class NetflixController {\r\n  constructor() {\r\n    this.injectAPIBridge();\r\n  }\r\n  \r\n  // Inject Netflix API access script into page context\r\n  injectAPIBridge() {\r\n    const script = document.createElement('script');\r\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\r\n    (document.head || document.documentElement).appendChild(script);\r\n    script.onload = function() {\r\n      console.log('Netflix API bridge loaded');\r\n      script.remove();\r\n    };\r\n  }\r\n  \r\n  // Send command to Netflix API via custom events\r\n  _sendCommand(command, args = []) {\r\n    return new Promise(function(resolve) {\r\n      const handler = function(e) {\r\n        if (e.detail.command === command) {\r\n          document.removeEventListener('__toperparty_response', handler);\r\n          resolve(e.detail.result);\r\n        }\r\n      };\r\n      document.addEventListener('__toperparty_response', handler);\r\n      setTimeout(function() { resolve(null); }, 1000); // timeout fallback\r\n      document.dispatchEvent(new CustomEvent('__toperparty_command', { detail: { command, args } }));\r\n    });\r\n  }\r\n  \r\n  play() {\r\n    return this._sendCommand('play');\r\n  }\r\n  \r\n  pause() {\r\n    return this._sendCommand('pause');\r\n  }\r\n  \r\n  seek(timeMs) {\r\n    return this._sendCommand('seek', [timeMs]);\r\n  }\r\n  \r\n  getCurrentTime() {\r\n    return this._sendCommand('getCurrentTime');\r\n  }\r\n  \r\n  isPaused() {\r\n    return this._sendCommand('isPaused');\r\n  }\r\n  \r\n  // Find Netflix video element (fallback)\r\n  getVideoElement() {\r\n    return document.querySelector('video');\r\n  }\r\n}\r\n","// state-manager.js - Manages party state and action tracking\r\n\r\nexport class StateManager {\r\n  constructor() {\r\n    // Party state\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    this.restoringPartyState = false;\r\n  }\r\n  \r\n  // Party state management\r\n  startParty(userId, roomId) {\r\n    this.partyActive = true;\r\n    this.userId = userId;\r\n    this.roomId = roomId;\r\n    console.log('Party started! Room:', roomId, 'User:', userId);\r\n  }\r\n  \r\n  stopParty() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    console.log('Party stopped');\r\n  }\r\n  \r\n  isActive() {\r\n    return this.partyActive;\r\n  }\r\n  \r\n  getUserId() {\r\n    return this.userId;\r\n  }\r\n  \r\n  getRoomId() {\r\n    return this.roomId;\r\n  }\r\n  \r\n  getState() {\r\n    return {\r\n      partyActive: this.partyActive,\r\n      userId: this.userId,\r\n      roomId: this.roomId,\r\n      restoringPartyState: this.restoringPartyState\r\n    };\r\n  }\r\n\r\n   // Convenience: are we currently in a valid party session?\r\n  isInParty() {\r\n    return !!(this.partyActive && this.userId && this.roomId);\r\n  }\r\n  \r\n  setRestoringFlag(value) {\r\n    this.restoringPartyState = value;\r\n  }\r\n  \r\n  // Extension context validation\r\n  isExtensionContextValid() {\r\n    try {\r\n      return chrome.runtime && chrome.runtime.id;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // Safe message sending\r\n  safeSendMessage(message, callback) {\r\n    if (!this.isExtensionContextValid()) {\r\n      console.warn('Extension context invalidated - please reload the page');\r\n      return;\r\n    }\r\n    try {\r\n      chrome.runtime.sendMessage(message, callback);\r\n    } catch (e) {\r\n      console.warn('Failed to send message, extension may have been reloaded:', e.message);\r\n    }\r\n  }\r\n}\r\n","// sync-manager.js - Robust, debounced playback synchronization\r\n\r\nexport class SyncManager {\r\n  constructor(stateManager, netflixController) {\r\n    this.state = stateManager;\r\n    this.netflix = netflixController;\r\n\r\n    this.listeners = null;\r\n\r\n    // Suppression system: Timestamp until which local events are ignored\r\n    // Used to prevent echo when applying remote commands or during initialization\r\n    this.suppressLocalUntil = 0;\r\n\r\n    // Debounce system: Coalesce rapid events (e.g. pause+seek+play) into one broadcast\r\n    this.debounceTimer = null;\r\n    this.recentLocalEvents = new Set();\r\n    \r\n    // Context for passive sync\r\n    this.lastUserInteractionAt = 0;\r\n  }\r\n\r\n  // ---- Public lifecycle -------------------------------------------------\r\n\r\n  async setup() {\r\n    try {\r\n      const video = await this.waitForVideo();\r\n      if (!video) {\r\n        console.warn('[SyncManager] Netflix video element not found');\r\n        return;\r\n      }\r\n\r\n      // Startup Grace Period: Ignore all local events for 3 seconds\r\n      // This prevents the initial \"seek to 0\" or auto-play from broadcasting\r\n      // and allows the restore logic to do its job without interference.\r\n      this.suppressLocalUntil = Date.now() + 3000;\r\n\r\n      this.attachEventListeners(video);\r\n      console.log('[SyncManager] Setup complete. Local events suppressed for 3s.');\r\n    } catch (err) {\r\n      console.error('[SyncManager] Error setting up playback sync:', err);\r\n    }\r\n  }\r\n\r\n  teardown() {\r\n    if (this.listeners && this.listeners.video) {\r\n      const { video, handleLocalEvent, handleTimeUpdate } = this.listeners;\r\n      try {\r\n        video.removeEventListener('play', handleLocalEvent);\r\n        video.removeEventListener('pause', handleLocalEvent);\r\n        video.removeEventListener('seeked', handleLocalEvent);\r\n        video.removeEventListener('timeupdate', handleTimeUpdate);\r\n      } catch (e) {\r\n        console.warn('[SyncManager] Error removing listeners:', e);\r\n      }\r\n      this.listeners = null;\r\n    }\r\n    if (this.debounceTimer) {\r\n      clearTimeout(this.debounceTimer);\r\n      this.debounceTimer = null;\r\n    }\r\n  }\r\n\r\n  // ---- DOM wiring -------------------------------------------------------\r\n\r\n  waitForVideo() {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\r\n      const check = () => {\r\n        const video = this.netflix.getVideoElement();\r\n        if (video) {\r\n          clearTimeout(timeout);\r\n          resolve(video);\r\n        } else {\r\n          setTimeout(check, 100);\r\n        }\r\n      };\r\n      check();\r\n    });\r\n  }\r\n\r\n  attachEventListeners(video) {\r\n    // Unified handler for user interactions\r\n    const handleLocalEvent = (e) => {\r\n      if (!this.state.isActive()) return;\r\n\r\n      const now = Date.now();\r\n      if (now < this.suppressLocalUntil) {\r\n        console.log(`[SyncManager] Suppressed local ${e.type} (lock active)`);\r\n        return;\r\n      }\r\n\r\n      this.lastUserInteractionAt = now;\r\n      this.recentLocalEvents.add(e.type);\r\n\r\n      // Debounce: Wait for the dust to settle before broadcasting\r\n      if (this.debounceTimer) clearTimeout(this.debounceTimer);\r\n\r\n      this.debounceTimer = setTimeout(() => {\r\n        this.broadcastLocalState(video);\r\n      }, 200); // 200ms window to capture complex interactions like seek\r\n    };\r\n\r\n    // Passive sync sender\r\n    let lastPassiveSentAt = 0;\r\n    const handleTimeUpdate = () => {\r\n      if (!this.state.isActive()) return;\r\n      \r\n      const now = Date.now();\r\n      // Don't send if we are currently suppressing local events (remote command active)\r\n      if (now < this.suppressLocalUntil) return;\r\n      \r\n      // Don't send if user recently interacted (let the explicit events handle it)\r\n      if (now - this.lastUserInteractionAt < 5000) return;\r\n\r\n      // Rate limit: once every 10s\r\n      if (now - lastPassiveSentAt < 10000) return;\r\n\r\n      if (video.paused) return; // Only sync while playing\r\n\r\n      lastPassiveSentAt = now;\r\n      const payload = {\r\n        type: 'SYNC_TIME',\r\n        currentTime: video.currentTime,\r\n        isPlaying: !video.paused,\r\n        timestamp: now,\r\n      };\r\n      console.log('[SyncManager] Sending passive sync:', payload.currentTime.toFixed(2));\r\n      this.state.safeSendMessage(payload);\r\n    };\r\n\r\n    video.addEventListener('play', handleLocalEvent);\r\n    video.addEventListener('pause', handleLocalEvent);\r\n    video.addEventListener('seeked', handleLocalEvent);\r\n    video.addEventListener('timeupdate', handleTimeUpdate);\r\n\r\n    this.listeners = { video, handleLocalEvent, handleTimeUpdate };\r\n  }\r\n\r\n  broadcastLocalState(video) {\r\n    const events = this.recentLocalEvents;\r\n    this.recentLocalEvents = new Set();\r\n    this.debounceTimer = null;\r\n\r\n    const currentTime = video.currentTime;\r\n    const isPlaying = !video.paused;\r\n\r\n    // Priority: Seek > Play/Pause\r\n    if (events.has('seeked')) {\r\n      console.log('[SyncManager] Broadcasting SEEK:', currentTime.toFixed(2));\r\n      this.state.safeSendMessage({ \r\n        type: 'SEEK', \r\n        currentTime, \r\n        isPlaying \r\n      });\r\n    } else if (events.has('play') || events.has('pause')) {\r\n      const control = isPlaying ? 'play' : 'pause';\r\n      console.log('[SyncManager] Broadcasting PLAY_PAUSE:', control);\r\n      this.state.safeSendMessage({ \r\n        type: 'PLAY_PAUSE', \r\n        control, \r\n        timestamp: currentTime \r\n      });\r\n    }\r\n  }\r\n\r\n  // ---- Remote Command Handlers ------------------------------------------\r\n\r\n  // Helper to lock local events while applying remote changes\r\n  async _applyRemoteAction(actionName, lockDurationMs, actionFn) {\r\n    console.log(`[SyncManager] Applying remote ${actionName}...`);\r\n    \r\n    // Set lock\r\n    this.suppressLocalUntil = Date.now() + lockDurationMs;\r\n    \r\n    try {\r\n      await actionFn();\r\n    } catch (err) {\r\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\r\n    }\r\n  }\r\n\r\n  async handlePlaybackControl(control, fromUserId) {\r\n    await this._applyRemoteAction(control, 1000, async () => {\r\n      if (control === 'play') await this.netflix.play();\r\n      else await this.netflix.pause();\r\n    });\r\n  }\r\n\r\n  async handleSeek(currentTime, isPlaying, fromUserId) {\r\n    await this._applyRemoteAction('seek', 2000, async () => {\r\n      await this.netflix.seek(currentTime * 1000);\r\n      \r\n      // Ensure play state matches\r\n      const isPaused = await this.netflix.isPaused();\r\n      if (isPlaying && isPaused) await this.netflix.play();\r\n      else if (!isPlaying && !isPaused) await this.netflix.pause();\r\n    });\r\n  }\r\n\r\n  async handlePassiveSync(currentTime, isPlaying, fromUserId, timestamp) {\r\n    const now = Date.now();\r\n    \r\n    // Ignore stale messages (>5s old)\r\n    if (timestamp && (now - timestamp > 5000)) return;\r\n\r\n    // Ignore if we recently interacted locally\r\n    if (now - this.lastUserInteractionAt < 10000) {\r\n      console.log('[SyncManager] Ignoring passive sync (recent local interaction)');\r\n      return;\r\n    }\r\n\r\n    // Ignore if we are currently locked (applying another remote command)\r\n    if (now < this.suppressLocalUntil) return;\r\n\r\n    try {\r\n      const localTimeMs = await this.netflix.getCurrentTime();\r\n      const targetMs = currentTime * 1000;\r\n      const driftMs = Math.abs(localTimeMs - targetMs);\r\n\r\n      // Only correct if drift is significant (>3s)\r\n      if (driftMs <= 3000) return;\r\n\r\n      console.log(`[SyncManager] Drift detected (${(driftMs/1000).toFixed(2)}s). Correcting...`);\r\n\r\n      // Apply correction without broadcasting back\r\n      await this._applyRemoteAction('passive-correction', 1500, async () => {\r\n        await this.netflix.seek(targetMs);\r\n        \r\n        const localPaused = await this.netflix.isPaused();\r\n        if (isPlaying && localPaused) await this.netflix.play();\r\n        else if (!isPlaying && !localPaused) await this.netflix.pause();\r\n      });\r\n\r\n    } catch (err) {\r\n      console.error('[SyncManager] Error handling passive sync:', err);\r\n    }\r\n  }\r\n}\r\n","// ui-manager.js - Manages UI components (preview videos)\r\n// Note: Keeping this simple for now, full extraction in future refactor\r\n\r\nexport class UIManager {\r\n  constructor() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos = new Map();\r\n    this.remoteStreams = new Map();\r\n    this.streamMonitorInterval = null;\r\n  }\r\n  \r\n  getRemoteVideos() {\r\n    return this.remoteVideos;\r\n  }\r\n  \r\n  getRemoteStreams() {\r\n    return this.remoteStreams;\r\n  }\r\n  \r\n  setLocalPreviewVideo(video) {\r\n    this.localPreviewVideo = video;\r\n  }\r\n  \r\n  getLocalPreviewVideo() {\r\n    return this.localPreviewVideo;\r\n  }\r\n  \r\n  setStreamMonitorInterval(interval) {\r\n    this.streamMonitorInterval = interval;\r\n  }\r\n  \r\n  getStreamMonitorInterval() {\r\n    return this.streamMonitorInterval;\r\n  }\r\n  \r\n  clearStreamMonitorInterval() {\r\n    if (this.streamMonitorInterval) {\r\n      clearInterval(this.streamMonitorInterval);\r\n      this.streamMonitorInterval = null;\r\n    }\r\n  }\r\n  \r\n  clearAll() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    this.clearStreamMonitorInterval();\r\n  }\r\n}\r\n","// url-sync.js - Manages URL monitoring and party state persistence\r\n// Note: Keeping this simple for now, full extraction in future refactor\r\n\r\nexport class URLSync {\r\n  constructor(stateManager) {\r\n    this.stateManager = stateManager;\r\n    this.urlMonitorInterval = null;\r\n    this.lastUrl = null;\r\n  }\r\n  \r\n  start() {\r\n    this.lastUrl = window.location.href;\r\n    // URL monitoring logic will be moved here in full extraction\r\n  }\r\n  \r\n  stop() {\r\n    if (this.urlMonitorInterval) {\r\n      clearInterval(this.urlMonitorInterval);\r\n      this.urlMonitorInterval = null;\r\n    }\r\n  }\r\n  \r\n  saveState() {\r\n    const state = this.stateManager.getState();\r\n    if (!state.partyActive) return;\r\n\r\n    // Persist basic party info; playback state will be updated separately by content-script\r\n    const existing = this.getRestorationState() || {};\r\n    const payload = {\r\n      userId: state.userId,\r\n      roomId: state.roomId,\r\n      // keep any playback info that may have been written just before navigation\r\n      currentTime: existing.currentTime || null,\r\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\r\n      timestamp: Date.now()\r\n    };\r\n\r\n    sessionStorage.setItem('toperparty_restore', JSON.stringify(payload));\r\n  }\r\n  \r\n  clearState() {\r\n    sessionStorage.removeItem('toperparty_restore');\r\n  }\r\n  \r\n  getRestorationState() {\r\n    const stored = sessionStorage.getItem('toperparty_restore');\r\n    if (!stored) return null;\r\n    \r\n    try {\r\n      const state = JSON.parse(stored);\r\n      // Check if restoration state is recent (within 30 seconds)\r\n      if (Date.now() - state.timestamp < 30000) {\r\n        return state;\r\n      }\r\n    } catch (e) {\r\n      console.error('[toperparty] Failed to parse restoration state:', e);\r\n    }\r\n    \r\n    return null;\r\n  }\r\n}\r\n","// webrtc-manager.js - Centralised WebRTC peer connection management for the content script\r\n\r\nexport class WebRTCManager {\r\n  constructor(stateManager, uiManager) {\r\n    this.stateManager = stateManager;\r\n    this.uiManager = uiManager;\r\n\r\n    this.peerConnections = new Map();\r\n    this.reconnectionAttempts = new Map();\r\n    this.reconnectionTimeouts = new Map();\r\n    this.remoteStreams = this.uiManager.getRemoteStreams();\r\n    this.remoteVideos = this.uiManager.getRemoteVideos();\r\n\r\n    this.peersThatLeft = new Set();\r\n    this.localStream = null;\r\n  }\r\n\r\n  // --- Local media ------------------------------------------------------\r\n\r\n  setLocalStream(stream) {\r\n    this.localStream = stream;\r\n  }\r\n\r\n  getLocalStream() {\r\n    return this.localStream;\r\n  }\r\n\r\n  // Called when we obtain/refresh local media so we can attach to existing PCs\r\n  onLocalStreamAvailable(stream) {\r\n    this.localStream = stream;\r\n    this.peerConnections.forEach((pc) => {\r\n      try {\r\n        stream.getTracks().forEach(t => this._addOrReplaceTrack(pc, t, stream));\r\n      } catch (e) {\r\n        console.warn('[WebRTCManager] Error adding tracks to peer connection', e);\r\n      }\r\n    });\r\n  }\r\n\r\n  // --- Signaling entrypoint --------------------------------------------\r\n\r\n  async handleSignal(message) {\r\n    if (!message || !message.type) return;\r\n\r\n    const type = message.type;\r\n    const from = message.userId || message.from;\r\n    const to = message.to;\r\n    const state = this.stateManager.getState();\r\n\r\n    // Ignore messages not for us (if addressed)\r\n    if (to && to !== state.userId) return;\r\n\r\n    if (type === 'JOIN' && from && from !== state.userId) {\r\n      // Another user joined the room â€” initiate P2P if we have local media\r\n      this.peersThatLeft.delete(from);\r\n      if (!this.peerConnections.has(from)) {\r\n        try {\r\n          const pc = this._createPeerConnection(from);\r\n          this.peerConnections.set(from, pc);\r\n          if (this.localStream) {\r\n            this.localStream.getTracks().forEach(t => this._addOrReplaceTrack(pc, t, this.localStream));\r\n          }\r\n          const offer = await pc.createOffer();\r\n          await pc.setLocalDescription(offer);\r\n          this._sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\r\n        } catch (err) {\r\n          console.error('[WebRTCManager] Error handling JOIN and creating offer:', err);\r\n          this.peerConnections.delete(from);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (type === 'OFFER' && message.offer && from && from !== state.userId) {\r\n      let pc = this.peerConnections.get(from);\r\n\r\n      if (pc) {\r\n        const pcState = pc.signalingState;\r\n        if (pcState !== 'closed') {\r\n          console.log('[WebRTCManager] Received new offer while in state:', pcState, '- recreating connection for', from);\r\n          try { pc.close(); } catch (e) {}\r\n          this.peerConnections.delete(from);\r\n          pc = null;\r\n        }\r\n      }\r\n\r\n      if (!pc) {\r\n        pc = this._createPeerConnection(from);\r\n        this.peerConnections.set(from, pc);\r\n      }\r\n\r\n      try {\r\n        await pc.setRemoteDescription(new RTCSessionDescription(message.offer));\r\n        if (this.localStream) {\r\n          this.localStream.getTracks().forEach(t => this._addOrReplaceTrack(pc, t, this.localStream));\r\n        }\r\n        const answer = await pc.createAnswer();\r\n        await pc.setLocalDescription(answer);\r\n        this._sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('[WebRTCManager] Error handling offer:', err);\r\n        this.peerConnections.delete(from);\r\n        try { pc.close(); } catch (e) {}\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\r\n      const pc = this.peerConnections.get(from);\r\n      if (pc) {\r\n        try {\r\n          if (pc.signalingState === 'have-local-offer') {\r\n            await pc.setRemoteDescription(new RTCSessionDescription(message.answer));\r\n          } else {\r\n            console.warn('[WebRTCManager] Received answer in unexpected state:', pc.signalingState);\r\n          }\r\n        } catch (err) {\r\n          console.error('[WebRTCManager] Error handling answer:', err);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\r\n      const pc = this.peerConnections.get(from);\r\n      if (pc) {\r\n        try {\r\n          await pc.addIceCandidate(new RTCIceCandidate(message.candidate));\r\n        } catch (err) {\r\n          console.warn('[WebRTCManager] Error adding received ICE candidate', err);\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (type === 'LEAVE' && from) {\r\n      this.peersThatLeft.add(from);\r\n      const pc = this.peerConnections.get(from);\r\n      if (pc) {\r\n        try { pc.close(); } catch (e) {}\r\n        this.peerConnections.delete(from);\r\n      }\r\n      this._clearReconnectionState(from);\r\n      this._removeRemoteVideo(from);\r\n      return;\r\n    }\r\n  }\r\n\r\n  // --- Reconnection logic ----------------------------------------------\r\n\r\n  async attemptReconnection(peerId) {\r\n    const state = this.stateManager.getState();\r\n    if (!this.stateManager.isInParty()) {\r\n      console.log('[WebRTCManager] Cannot reconnect - party not active');\r\n      return;\r\n    }\r\n\r\n    if (this.peersThatLeft.has(peerId)) {\r\n      console.log('[WebRTCManager] Not attempting reconnection to peer that has explicitly left:', peerId);\r\n      this._clearReconnectionState(peerId);\r\n      return;\r\n    }\r\n\r\n    const attempts = this.reconnectionAttempts.get(peerId) || 0;\r\n    const maxAttempts = 5;\r\n    const backoffDelay = Math.min(1000 * Math.pow(2, attempts), 30000);\r\n\r\n    if (attempts >= maxAttempts) {\r\n      console.log('[WebRTCManager] Max reconnection attempts reached for', peerId);\r\n      this.reconnectionAttempts.delete(peerId);\r\n      this.reconnectionTimeouts.delete(peerId);\r\n      return;\r\n    }\r\n\r\n    console.log(`[WebRTCManager] Attempting reconnection to ${peerId} (attempt ${attempts + 1}/${maxAttempts}) in ${backoffDelay}ms`);\r\n    this.reconnectionAttempts.set(peerId, attempts + 1);\r\n\r\n    const existingTimeout = this.reconnectionTimeouts.get(peerId);\r\n    if (existingTimeout) {\r\n      clearTimeout(existingTimeout);\r\n    }\r\n\r\n    const timeoutHandle = setTimeout(async () => {\r\n      console.log('[WebRTCManager] Reconnecting to', peerId);\r\n\r\n      const oldPc = this.peerConnections.get(peerId);\r\n      if (oldPc) {\r\n        try { oldPc.close(); } catch (e) { console.warn('[WebRTCManager] Error closing old peer connection:', e); }\r\n        this.peerConnections.delete(peerId);\r\n      }\r\n\r\n      try {\r\n        const pc = this._createPeerConnection(peerId);\r\n        this.peerConnections.set(peerId, pc);\r\n\r\n        if (this.localStream) {\r\n          this.localStream.getTracks().forEach(t => this._addOrReplaceTrack(pc, t, this.localStream));\r\n        }\r\n\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n        this._sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\r\n\r\n        console.log('[WebRTCManager] Reconnection offer sent to', peerId);\r\n      } catch (err) {\r\n        console.error('[WebRTCManager] Failed to create reconnection offer:', err);\r\n        this.attemptReconnection(peerId);\r\n      }\r\n    }, backoffDelay);\r\n\r\n    this.reconnectionTimeouts.set(peerId, timeoutHandle);\r\n  }\r\n\r\n  _clearReconnectionState(peerId) {\r\n    this.reconnectionAttempts.delete(peerId);\r\n    const timeoutHandle = this.reconnectionTimeouts.get(peerId);\r\n    if (timeoutHandle) {\r\n      clearTimeout(timeoutHandle);\r\n      this.reconnectionTimeouts.delete(peerId);\r\n    }\r\n  }\r\n\r\n  // --- Peer connection helpers -----------------------------------------\r\n\r\n  _createPeerConnection(peerId) {\r\n    const state = this.stateManager.getState();\r\n    const pc = new RTCPeerConnection({\r\n      iceServers: [\r\n        { urls: ['stun:stun.l.google.com:19302'] },\r\n        { urls: ['stun:stun1.l.google.com:19302'] }\r\n      ]\r\n    });\r\n\r\n    pc.onicecandidate = (event) => {\r\n      if (event.candidate) {\r\n        this._sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\r\n      }\r\n    };\r\n\r\n    pc.ontrack = (event) => {\r\n      console.log('[WebRTCManager] Received remote track from', peerId, 'track=', event.track && event.track.kind);\r\n      let stream = (event.streams && event.streams[0]) || this.remoteStreams.get(peerId);\r\n      if (!stream) {\r\n        stream = new MediaStream();\r\n        this.remoteStreams.set(peerId, stream);\r\n      }\r\n      if (event.track) {\r\n        try {\r\n          stream.addTrack(event.track);\r\n          event.track.onended = () => {\r\n            console.warn('[WebRTCManager] Remote track ended from', peerId, 'kind=', event.track.kind);\r\n          };\r\n          console.log('[WebRTCManager] Added remote track to stream, kind=', event.track.kind, 'readyState=', event.track.readyState);\r\n        } catch (e) {\r\n          console.warn('[WebRTCManager] Failed to add remote track to stream', e);\r\n        }\r\n      }\r\n      if (!this.remoteVideos.has(peerId)) {\r\n        this._addRemoteVideo(peerId, stream);\r\n      }\r\n    };\r\n\r\n    pc.onconnectionstatechange = () => {\r\n      console.log('[WebRTCManager] PC state', pc.connectionState, 'for', peerId);\r\n\r\n      if (pc.connectionState === 'connected') {\r\n        console.log('[WebRTCManager] Connection established successfully with', peerId);\r\n        this._clearReconnectionState(peerId);\r\n      } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {\r\n        if (this.peersThatLeft.has(peerId)) {\r\n          console.warn('[WebRTCManager] Connection', pc.connectionState, 'with peer that has left', peerId, '- not reconnecting');\r\n          this.peerConnections.delete(peerId);\r\n          this._removeRemoteVideo(peerId);\r\n          this._clearReconnectionState(peerId);\r\n        } else {\r\n          console.warn('[WebRTCManager] Connection', pc.connectionState, 'with', peerId, '- attempting reconnection');\r\n          this.peerConnections.delete(peerId);\r\n          this._removeRemoteVideo(peerId);\r\n          this.attemptReconnection(peerId);\r\n        }\r\n      } else if (pc.connectionState === 'closed') {\r\n        console.log('[WebRTCManager] Connection closed with', peerId);\r\n        this.peerConnections.delete(peerId);\r\n        this._removeRemoteVideo(peerId);\r\n        this._clearReconnectionState(peerId);\r\n      }\r\n    };\r\n\r\n    return pc;\r\n  }\r\n\r\n  _addOrReplaceTrack(pc, track, stream) {\r\n    const senders = pc.getSenders();\r\n    const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\r\n    if (existingSender) {\r\n      existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\r\n    } else {\r\n      try {\r\n        pc.addTrack(track, stream);\r\n      } catch (e) {\r\n        console.warn('[WebRTCManager] Error adding track', e);\r\n      }\r\n    }\r\n  }\r\n\r\n  // --- UI helpers -------------------------------------------------------\r\n\r\n  _addRemoteVideo(peerId, stream) {\r\n    this._removeRemoteVideo(peerId);\r\n    const v = document.createElement('video');\r\n    v.id = 'toperparty-remote-' + peerId;\r\n    v.autoplay = true;\r\n    v.playsInline = true;\r\n    v.muted = true;\r\n    v.style.position = 'fixed';\r\n    v.style.bottom = '20px';\r\n    v.style.right = (20 + (this.remoteVideos.size * 180)) + 'px';\r\n    v.style.width = '240px';\r\n    v.style.height = '160px';\r\n    v.style.zIndex = 10001;\r\n    v.style.border = '2px solid #00aaff';\r\n    v.style.borderRadius = '4px';\r\n\r\n    const audioTracks = stream.getAudioTracks();\r\n    console.log('[WebRTCManager] Remote stream audio tracks:', audioTracks.length);\r\n    audioTracks.forEach((track) => {\r\n      console.log('[WebRTCManager] Audio track:', track.id, 'enabled=', track.enabled, 'readyState=', track.readyState);\r\n    });\r\n\r\n    try {\r\n      v.srcObject = stream;\r\n    } catch (e) {\r\n      v.src = URL.createObjectURL(stream);\r\n    }\r\n    document.body.appendChild(v);\r\n    this.remoteVideos.set(peerId, v);\r\n\r\n    try {\r\n      v.play().then(() => {\r\n        console.log('[WebRTCManager] Remote video playing, unmuting audio for', peerId);\r\n        v.muted = false;\r\n        v.volume = 1.0;\r\n      }).catch((err) => {\r\n        console.warn('[WebRTCManager] Remote video play() failed:', err);\r\n        v.muted = false;\r\n      });\r\n    } catch (e) {\r\n      console.error('[WebRTCManager] Exception calling play():', e);\r\n    }\r\n  }\r\n\r\n  _removeRemoteVideo(peerId) {\r\n    const v = this.remoteVideos.get(peerId);\r\n    if (v) {\r\n      try {\r\n        if (v.srcObject) {\r\n          v.srcObject = null;\r\n        }\r\n      } catch (e) {}\r\n      v.remove();\r\n      this.remoteVideos.delete(peerId);\r\n    }\r\n    this.remoteStreams.delete(peerId);\r\n  }\r\n\r\n  // --- Messaging to background -----------------------------------------\r\n\r\n  _sendSignal(message) {\r\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\r\n  }\r\n\r\n  // --- Teardown ---------------------------------------------------------\r\n\r\n  clearAll() {\r\n    this.peerConnections.forEach((pc) => {\r\n      try { pc.close(); } catch (e) {}\r\n    });\r\n    this.peerConnections.clear();\r\n\r\n    this.reconnectionTimeouts.forEach((timeoutHandle) => {\r\n      clearTimeout(timeoutHandle);\r\n    });\r\n    this.reconnectionTimeouts.clear();\r\n    this.reconnectionAttempts.clear();\r\n    this.peersThatLeft.clear();\r\n\r\n    this.remoteVideos.forEach((v, id) => {\r\n      try {\r\n        if (v.srcObject) {\r\n          v.srcObject = null;\r\n        }\r\n      } catch (e) {}\r\n      v.remove();\r\n    });\r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n\r\n    if (this.localStream) {\r\n      this.localStream.getTracks().forEach(track => track.stop());\r\n      this.localStream = null;\r\n    }\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// content-script.js - Modular version with ES6 imports\r\n\r\nimport { StateManager } from './modules/state-manager.js';\r\nimport { NetflixController } from './modules/netflix-controller.js';\r\nimport { SyncManager } from './modules/sync-manager.js';\r\nimport { WebRTCManager } from './modules/webrtc-manager.js';\r\nimport { UIManager } from './modules/ui-manager.js';\r\nimport { URLSync } from './modules/url-sync.js';\r\n\r\n// Initialize managers\r\nconst stateManager = new StateManager();\r\nconst uiManager = new UIManager();\r\nconst netflixController = new NetflixController();\r\nconst syncManager = new SyncManager(stateManager, netflixController);\r\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\r\nconst urlSync = new URLSync(stateManager);\r\n\r\n// Local media stream (still tracked here, but WebRTCManager knows about it too)\r\nlet localStream = null;\r\n\r\n// Check if we need to restore party state after navigation\r\n(function checkRestorePartyState() {\r\n  const restorationState = urlSync.getRestorationState();\r\n  if (restorationState) {\r\n    console.log('Detected party state after navigation, will restore:', restorationState);\r\n    \r\n    // Clear the stored state\r\n    urlSync.clearState();\r\n    \r\n    // Set flag to prevent URL broadcast during restoration\r\n    stateManager.setRestoringFlag(true);\r\n    \r\n    // Notify background that we need to rejoin\r\n    setTimeout(function() {\r\n      console.log('Triggering party reset and restoration...');\r\n      chrome.runtime.sendMessage({\r\n        type: 'RESTORE_PARTY',\r\n        roomId: restorationState.roomId,\r\n        userId: restorationState.userId\r\n      });\r\n      \r\n      // Clear restoration flag after party is restored\r\n      setTimeout(function() {\r\n        stateManager.setRestoringFlag(false);\r\n        console.log('Party restoration complete, URL monitoring active');\r\n      }, 2000);\r\n    }, 1000); // Wait 1s for page to stabilize\r\n  }\r\n})();\r\n\r\n// Inject Netflix API access script into page context\r\nnetflixController.injectAPIBridge();\r\n\r\n// Find Netflix video player (fallback for monitoring)\r\nfunction getVideoElement() {\r\n  return document.querySelector('video');\r\n}\r\n\r\n// URL monitoring - check for navigation changes\r\nlet lastKnownUrl = window.location.href;\r\n\r\nfunction startUrlMonitoring() {\r\n  // Save party state and inform server/peers that THIS tab is leaving on hard navigations\r\n  window.addEventListener('beforeunload', function savePartyStateBeforeUnload() {\r\n    const currentState = stateManager.getState();\r\n    if (stateManager.isInParty()) {\r\n      // Persist enough info so the refreshed tab can rejoin cleanly\r\n      urlSync.saveState();\r\n\r\n      // Send a LEAVE over the signaling channel for this user only, without\r\n      // stopping the entire party for other tabs.\r\n      try {\r\n        stateManager.safeSendMessage({\r\n          type: 'SIGNAL_SEND',\r\n          message: {\r\n            type: 'LEAVE',\r\n            userId: currentState.userId,\r\n            roomId: currentState.roomId,\r\n            timestamp: Date.now()\r\n          }\r\n        });\r\n      } catch (e) {\r\n        console.warn('Error sending LEAVE on beforeunload:', e);\r\n      }\r\n\r\n      // Local, immediate cleanup to avoid dangling timers/PCs during unload\r\n      try {\r\n        webrtcManager.clearAll();\r\n      } catch (e) {\r\n        console.warn('Error clearing WebRTC state on beforeunload:', e);\r\n      }\r\n    }\r\n  });\r\n  \r\n  // Also monitor for soft navigations (client-side routing)\r\n  setInterval(function checkUrlChange() {\r\n    const currentUrl = window.location.href;\r\n    const state = stateManager.getState();\r\n    \r\n    // Check if URL changed and party is active (but not during restoration)\r\n    if (currentUrl !== lastKnownUrl && state.partyActive && !state.restoringPartyState) {\r\n      console.log('URL changed from', lastKnownUrl, 'to', currentUrl);\r\n      lastKnownUrl = currentUrl;\r\n      \r\n      // Broadcast URL change to other clients\r\n      stateManager.safeSendMessage({\r\n        type: 'URL_CHANGE',\r\n        url: currentUrl\r\n      });\r\n    } else if (!state.restoringPartyState) {\r\n      // Silently update lastKnownUrl if we're not in restoration mode\r\n      lastKnownUrl = currentUrl;\r\n    }\r\n  }, 500); // Check every 500ms\r\n}\r\n\r\nfunction stopUrlMonitoring() {\r\n  lastKnownUrl = window.location.href;\r\n  urlSync.stop();\r\n}\r\n\r\n// Listen for messages from background script\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  // Signaling messages forwarded from background\r\n  if (request.type === 'SIGNAL' && request.message) {\r\n    webrtcManager.handleSignal(request.message).catch(err => console.error('Signal handling error:', err));\r\n    return; // no sendResponse needed\r\n  }\r\n  \r\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\r\n    // Get media stream for webcam/mic\r\n    navigator.mediaDevices.getUserMedia({\r\n      video: { width: { ideal: 640 }, height: { ideal: 480 } },\r\n      audio: true\r\n    })\r\n      .then((stream) => {\r\n        localStream = stream;\r\n        webrtcManager.setLocalStream(stream);\r\n        console.log('Media stream obtained in content script');\r\n        \r\n        // Monitor stream tracks for unexpected ending\r\n        stream.getTracks().forEach(function(track) {\r\n          console.log('Local stream track obtained:', track.kind, 'id=', track.id, 'readyState=', track.readyState);\r\n          track.onended = function() {\r\n            console.error('LOCAL STREAM TRACK ENDED UNEXPECTEDLY:', track.kind, 'id=', track.id);\r\n          };\r\n          track.onmute = function() {\r\n            console.warn('Local stream track muted:', track.kind);\r\n          };\r\n          track.onunmute = function() {\r\n            console.log('Local stream track unmuted:', track.kind);\r\n          };\r\n        });\r\n        \r\n        // Create or update local preview\r\n        attachLocalPreview(stream);\r\n        \r\n        // Start monitoring local stream health\r\n        startLocalStreamMonitor(stream);\r\n      \r\n        // Let WebRTC manager attach tracks to existing peer connections\r\n        webrtcManager.onLocalStreamAvailable(stream);\r\n        sendResponse({ success: true, message: 'Media stream obtained' });\r\n      })\r\n      .catch((err) => {\r\n        console.error('Failed to get media stream:', err);\r\n        sendResponse({ success: false, error: err.message });\r\n      });\r\n    \r\n    return true; // Keep channel open for async response\r\n  }\r\n\r\n  if (request.type === 'PARTY_STARTED') {\r\n    stateManager.startParty(request.userId, request.roomId);\r\n    console.log('Party started! Room:', request.roomId, 'User:', request.userId);\r\n    \r\n    // Start monitoring URL changes\r\n    startUrlMonitoring();\r\n    \r\n    // Setup playback sync, then attempt to restore prior playback state (if any)\r\n    Promise.resolve(syncManager.setup())\r\n      .then(() => {\r\n        tryRestorePlaybackState();\r\n      })\r\n      .catch((err) => {\r\n        console.error('[ContentScript] Error setting up sync manager:', err);\r\n      });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'PARTY_STOPPED') {\r\n    stateManager.stopParty();\r\n    \r\n    // Stop URL monitoring\r\n    stopUrlMonitoring();\r\n    \r\n    // Teardown sync\r\n    syncManager.teardown();\r\n    \r\n    // Stop stream monitor\r\n    stopLocalStreamMonitor();\r\n    \r\n    // Stop media stream\r\n    if (localStream) {\r\n      localStream.getTracks().forEach(track => track.stop());\r\n      localStream = null;\r\n      webrtcManager.setLocalStream(null);\r\n    }\r\n    \r\n    // Remove local preview UI\r\n    removeLocalPreview();\r\n    \r\n    // Remove injected controls\r\n    removeInjectedControls();\r\n    \r\n    // Let WebRTC manager fully clean up connections, reconnection state, and remote UI\r\n    webrtcManager.clearAll();\r\n    \r\n    console.log('Party stopped');\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\r\n    syncManager.handlePlaybackControl(request.control, request.fromUserId);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_SYNC_PLAYBACK') {\r\n    syncManager.handlePassiveSync(request.currentTime, request.isPlaying, request.fromUserId, request.timestamp);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_SEEK') {\r\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'APPLY_URL_CHANGE') {\r\n    console.log('Applying URL change from remote user:', request.url, 'from user:', request.fromUserId);\r\n    \r\n    // Save party state before navigation so we can restore after reload\r\n    const state = stateManager.getState();\r\n    if (state.partyActive && state.userId && state.roomId) {\r\n      // Capture approximate playback state so refreshed tab rejoins near same position\r\n      netflixController.getCurrentTime()\r\n        .then((ms) => {\r\n          const currentTime = ms != null ? ms / 1000 : null;\r\n          return netflixController.isPaused().then((paused) => ({ currentTime, isPlaying: !paused }));\r\n        })\r\n        .then((playback) => {\r\n          const existing = urlSync.getRestorationState() || {};\r\n          const payload = {\r\n            userId: state.userId,\r\n            roomId: state.roomId,\r\n            currentTime: playback.currentTime != null ? playback.currentTime : existing.currentTime || null,\r\n            isPlaying: typeof playback.isPlaying === 'boolean' ? playback.isPlaying : (typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null),\r\n            timestamp: Date.now()\r\n          };\r\n          sessionStorage.setItem('toperparty_restore', JSON.stringify(payload));\r\n          console.log('Saved party + playback state before navigation', payload);\r\n        })\r\n        .catch((e) => {\r\n          console.warn('Failed to capture playback state before navigation, falling back to basic party state:', e);\r\n          urlSync.saveState();\r\n        });\r\n    }\r\n    \r\n    // Always use hard navigation to ensure Netflix properly loads the new video\r\n    // This will cause a page reload, but state will be restored automatically\r\n    window.location.href = request.url;\r\n    \r\n    sendResponse({ success: true });\r\n  }\r\n});\r\n\r\n// --- UI Functions (kept in main file for now) ---\r\n\r\nfunction removeInjectedControls() {\r\n  const controls = document.getElementById('netflix-party-controls');\r\n  if (controls) {\r\n    controls.remove();\r\n  }\r\n}\r\n\r\nfunction attachLocalPreview(stream) {\r\n  let localPreviewVideo = uiManager.getLocalPreviewVideo();\r\n  \r\n  // Remove existing preview if any\r\n  if (localPreviewVideo) {\r\n    try {\r\n      if (localPreviewVideo.srcObject) {\r\n        localPreviewVideo.srcObject = null;\r\n      }\r\n    } catch (e) {}\r\n    localPreviewVideo.remove();\r\n    localPreviewVideo = null;\r\n  }\r\n\r\n  // Create new video element for local preview\r\n  const v = document.createElement('video');\r\n  v.id = 'toperparty-local-preview';\r\n  v.autoplay = true;\r\n  v.muted = true; // Always mute local preview to avoid feedback\r\n  v.playsInline = true;\r\n  v.style.position = 'fixed';\r\n  v.style.bottom = '20px';\r\n  v.style.left = '20px';\r\n  v.style.width = '240px';\r\n  v.style.height = '160px';\r\n  v.style.zIndex = 10001;\r\n  v.style.border = '2px solid #e50914';\r\n  v.style.borderRadius = '4px';\r\n  v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\r\n\r\n  try {\r\n    v.srcObject = stream;\r\n  } catch (e) {\r\n    v.src = URL.createObjectURL(stream);\r\n  }\r\n\r\n  document.body.appendChild(v);\r\n  uiManager.setLocalPreviewVideo(v);\r\n\r\n  v.play().catch(function(err) {\r\n    console.warn('Local preview play() failed (this is usually fine):', err);\r\n  });\r\n}\r\n\r\nfunction removeLocalPreview() {\r\n  const localPreviewVideo = uiManager.getLocalPreviewVideo();\r\n  if (localPreviewVideo) {\r\n    try {\r\n      // Stop the tracks managed by this video's srcObject (only if we own them)\r\n      if (localPreviewVideo.srcObject) {\r\n        localPreviewVideo.srcObject.getTracks().forEach(function(track) {\r\n          track.stop();\r\n        });\r\n        localPreviewVideo.srcObject = null;\r\n      }\r\n    } catch (e) {\r\n      console.warn('Error stopping local preview tracks:', e);\r\n    }\r\n    localPreviewVideo.remove();\r\n    uiManager.setLocalPreviewVideo(null);\r\n  }\r\n}\r\n\r\nfunction startLocalStreamMonitor(stream) {\r\n  uiManager.clearStreamMonitorInterval();\r\n  \r\n  const interval = setInterval(function monitorLocalStream() {\r\n    if (!stream) {\r\n      console.warn('Local stream is null, stopping monitor');\r\n      uiManager.clearStreamMonitorInterval();\r\n      return;\r\n    }\r\n\r\n    const tracks = stream.getTracks();\r\n    if (tracks.length === 0) {\r\n      console.warn('Local stream has no tracks');\r\n      uiManager.clearStreamMonitorInterval();\r\n      return;\r\n    }\r\n\r\n    let allActive = true;\r\n    tracks.forEach(function(track) {\r\n      if (track.readyState !== 'live') {\r\n        console.error('Local stream track not live:', track.kind, 'readyState=', track.readyState);\r\n        allActive = false;\r\n      }\r\n    });\r\n\r\n    if (!allActive) {\r\n      console.warn('Some local stream tracks are not active - may need to restart stream');\r\n    }\r\n  }, 5000); // Check every 5 seconds\r\n  \r\n  uiManager.setStreamMonitorInterval(interval);\r\n}\r\n\r\nfunction stopLocalStreamMonitor() {\r\n  uiManager.clearStreamMonitorInterval();\r\n}\r\n\r\n// After RESTORE_PARTY and PARTY_STARTED, attempt to restore playback state\r\n// captured before navigation so the refreshed tab doesn't start from 0.\r\nfunction tryRestorePlaybackState() {\r\n  const restorationState = urlSync.getRestorationState();\r\n  if (!restorationState || restorationState.currentTime == null) return;\r\n\r\n  const targetSeconds = restorationState.currentTime;\r\n  const shouldPlay = typeof restorationState.isPlaying === 'boolean' ? restorationState.isPlaying : null;\r\n\r\n  // Clear the restoration state so we don't re-apply on subsequent operations\r\n  urlSync.clearState();\r\n\r\n  // Apply a local, non-broadcast correction using NetflixController\r\n  netflixController.getCurrentTime()\r\n    .then((ms) => {\r\n      const currentSeconds = ms != null ? ms / 1000 : 0;\r\n      const drift = Math.abs(currentSeconds - targetSeconds);\r\n\r\n      // Only correct if we're meaningfully off\r\n      if (drift > 2) {\r\n        console.log('[ContentScript] Restoring playback position after navigation from', currentSeconds, 'to', targetSeconds);\r\n        return netflixController.seek(targetSeconds * 1000);\r\n      }\r\n    })\r\n    .then(() => {\r\n      if (shouldPlay === null) return;\r\n      return netflixController.isPaused().then((paused) => {\r\n        if (shouldPlay && paused) {\r\n          console.log('[ContentScript] Resuming playback after navigation');\r\n          return netflixController.play();\r\n        }\r\n        if (!shouldPlay && !paused) {\r\n          console.log('[ContentScript] Pausing playback after navigation');\r\n          return netflixController.pause();\r\n        }\r\n      });\r\n    })\r\n    .catch((e) => {\r\n      console.warn('[ContentScript] Failed to restore playback state after navigation:', e);\r\n    });\r\n}\r\n\r\nfunction addOrReplaceTrack(pc, track, stream) {\r\n  const senders = pc.getSenders();\r\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\r\n  if (existingSender) {\r\n    existingSender.replaceTrack(track).catch(e => console.warn('Error replacing track', e));\r\n  } else {\r\n    try {\r\n      pc.addTrack(track, stream);\r\n    } catch (e) {\r\n      console.warn('Error adding track', e);\r\n    }\r\n  }\r\n}\r\n\r\n// WebRTC signaling and connection details now live in WebRTCManager\r\n"],"names":[],"ignoreList":[],"sourceRoot":""}