{"version":3,"file":"background.js","mappings":"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","sources":["webpack://toperparty/./chrome-extension/background.js"],"sourcesContent":["// background.js - Manages WebSocket connection and media streams\r\n\r\nlet ws = null;\r\nlet localStream = null;\r\nlet isConnected = false;\r\nlet roomId = null;\r\nlet userId = generateUserId();\r\n\r\n// WebRTC Configuration\r\nconst rtcConfig = {\r\n  iceServers: [\r\n    { urls: ['stun:stun.l.google.com:19302'] },\r\n    { urls: ['stun:stun1.l.google.com:19302'] }\r\n  ]\r\n};\r\n\r\nfunction generateUserId() {\r\n  return 'user_' + Math.random().toString(36).substr(2, 9);\r\n}\r\n\r\n// Initialize connection\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  console.log('Background received message:', request.type);\r\n  \r\n  if (request.type === 'START_PARTY') {\r\n    startParty(request.roomId).then(() => {\r\n      sendResponse({ success: true });\r\n    }).catch(err => {\r\n      sendResponse({ success: false, error: err.message });\r\n    });\r\n    return true; // Keep channel open for async response\r\n  }\r\n\r\n  if (request.type === 'STOP_PARTY') {\r\n    stopParty();\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'RESTORE_PARTY') {\r\n    console.log('Restoring party after navigation:', request.roomId);\r\n    // Use the saved userId instead of generating a new one\r\n    if (request.userId) {\r\n      userId = request.userId;\r\n    }\r\n    startParty(request.roomId).then(() => {\r\n      sendResponse({ success: true });\r\n    }).catch(err => {\r\n      console.error('Failed to restore party:', err);\r\n      sendResponse({ success: false, error: err.message });\r\n    });\r\n    return true; // Keep channel open for async response\r\n  }\r\n\r\n  if (request.type === 'GET_STATUS') {\r\n    console.log('Sending status:', { isConnected, roomId, userId, hasLocalStream: !!localStream });\r\n    sendResponse({\r\n      isConnected,\r\n      roomId,\r\n      userId,\r\n      hasLocalStream: !!localStream\r\n    });\r\n    return true;\r\n  }\r\n\r\n  if (request.type === 'PLAY_PAUSE') {\r\n    broadcastMessage({\r\n      type: 'PLAYBACK_CONTROL',\r\n      control: request.control,\r\n      timestamp: request.timestamp,\r\n      userId\r\n    });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'SYNC_TIME') {\r\n    broadcastMessage({\r\n      type: 'SYNC_PLAYBACK',\r\n      currentTime: request.currentTime,\r\n      isPlaying: request.isPlaying,\r\n      userId\r\n    });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'SEEK') {\r\n    console.log('Broadcasting SEEK command:', request.currentTime);\r\n    broadcastMessage({\r\n      type: 'SEEK',\r\n      currentTime: request.currentTime,\r\n      isPlaying: request.isPlaying,\r\n      userId\r\n    });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'URL_CHANGE') {\r\n    console.log('Broadcasting URL change:', request.url);\r\n    broadcastMessage({\r\n      type: 'URL_CHANGE',\r\n      url: request.url,\r\n      userId\r\n    });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  // Relay signaling messages from content scripts (offers/answers/ice)\r\n  if (request.type === 'SIGNAL_SEND') {\r\n    const msg = Object.assign({}, request.message || {});\r\n    // ensure identifying info is present\r\n    msg.userId = msg.userId || userId;\r\n    msg.roomId = msg.roomId || roomId;\r\n    if (ws && ws.readyState === WebSocket.OPEN) {\r\n      try {\r\n        ws.send(JSON.stringify(msg));\r\n        sendResponse({ success: true });\r\n      } catch (err) {\r\n        sendResponse({ success: false, error: err.message });\r\n      }\r\n    } else {\r\n      sendResponse({ success: false, error: 'Not connected to signaling server' });\r\n    }\r\n    return true;\r\n  }\r\n});\r\n\r\n// Start party mode\r\nasync function startParty(inputRoomId) {\r\n  roomId = inputRoomId || 'default_room_' + Date.now();\r\n\r\n  // Request media stream from content script\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      // First, try to get media access through the content script\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        if (tabs.length === 0) {\r\n          // If no Netflix tab, we can still try to get media in the background\r\n          getMediaStreamInBackground()\r\n            .then(() => connectToSignalingServer(resolve, reject))\r\n            .catch(reject);\r\n        } else {\r\n          // Ask the Netflix content script to get media\r\n          chrome.tabs.sendMessage(tabs[0].id, {\r\n            type: 'REQUEST_MEDIA_STREAM'\r\n          }, (response) => {\r\n            if (chrome.runtime.lastError) {\r\n              console.warn('Content script not ready, trying background:', chrome.runtime.lastError);\r\n              getMediaStreamInBackground()\r\n                .then(() => connectToSignalingServer(resolve, reject))\r\n                .catch(reject);\r\n              return;\r\n            }\r\n            \r\n            if (response && response.success) {\r\n              console.log('Got media stream from content script');\r\n              connectToSignalingServer(resolve, reject);\r\n            } else {\r\n              // Fallback to background attempt\r\n              console.warn('Content script failed to get media, trying background');\r\n              getMediaStreamInBackground()\r\n                .then(() => connectToSignalingServer(resolve, reject))\r\n                .catch(reject);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    } catch (err) {\r\n      reject(err);\r\n    }\r\n  });\r\n}\r\n\r\n// Try to get media stream in background (for testing without Netflix tab)\r\nasync function getMediaStreamInBackground() {\r\n  try {\r\n    // This will fail in service worker, but we set a flag so we can continue\r\n    // In production, the content script will handle this\r\n    console.log('Note: Media stream will be obtained from Netflix page');\r\n    return;\r\n  } catch (err) {\r\n    console.error('Could not get media in background:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n// Connect to signaling server\r\nfunction connectToSignalingServer(resolve, reject) {\r\n  try {\r\n    ws = new WebSocket('ws://watch.toper.dev/ws');\r\n\r\n    ws.onopen = () => {\r\n      console.log('Connected to signaling server');\r\n      isConnected = true;\r\n\r\n      // Send join message\r\n      ws.send(JSON.stringify({\r\n        type: 'JOIN',\r\n        userId,\r\n        roomId,\r\n        timestamp: Date.now()\r\n      }));\r\n\r\n      // Notify all tabs\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, {\r\n            type: 'PARTY_STARTED',\r\n            userId,\r\n            roomId\r\n          }).catch(() => {}); // Ignore errors if content script not ready\r\n        });\r\n      });\r\n\r\n      resolve();\r\n    };\r\n\r\n    ws.onmessage = (event) => {\r\n      handleSignalingMessage(event.data);\r\n    };\r\n\r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n      reject(new Error('Failed to connect to signaling server'));\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      console.log('Disconnected from signaling server');\r\n      isConnected = false;\r\n      cleanup();\r\n    };\r\n  } catch (err) {\r\n    reject(err);\r\n  }\r\n}\r\n\r\n// Stop party mode\r\nfunction stopParty() {\r\n  if (ws) {\r\n    ws.send(JSON.stringify({\r\n      type: 'LEAVE',\r\n      userId,\r\n      roomId,\r\n      timestamp: Date.now()\r\n    }));\r\n    ws.close();\r\n    ws = null;\r\n  }\r\n\r\n  cleanup();\r\n  isConnected = false;\r\n\r\n  // Notify all tabs\r\n  chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n    tabs.forEach(tab => {\r\n      chrome.tabs.sendMessage(tab.id, {\r\n        type: 'PARTY_STOPPED'\r\n      }).catch(() => {});\r\n    });\r\n  });\r\n}\r\n\r\n// Cleanup resources\r\nfunction cleanup() {\r\n  if (localStream) {\r\n    localStream.getTracks().forEach(track => track.stop());\r\n    localStream = null;\r\n  }\r\n}\r\n\r\n// Handle signaling messages\r\nasync function handleSignalingMessage(data) {\r\n  try {\r\n    const message = JSON.parse(data);\r\n\r\n    // Forward signaling payloads to all Netflix tabs so content scripts can handle WebRTC\r\n    chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n      tabs.forEach(tab => {\r\n        chrome.tabs.sendMessage(tab.id, { type: 'SIGNAL', message }).catch(() => {});\r\n      });\r\n    });\r\n\r\n    // Additionally handle playback control / sync specially (apply immediately)\r\n    if (message.type === 'PLAYBACK_CONTROL' && message.userId !== userId) {\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, { \r\n            type: 'APPLY_PLAYBACK_CONTROL', \r\n            control: message.control, \r\n            timestamp: message.timestamp,\r\n            fromUserId: message.userId \r\n          }).catch(() => {});\r\n        });\r\n      });\r\n    }\r\n\r\n    if (message.type === 'SYNC_PLAYBACK' && message.userId !== userId) {\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, { \r\n            type: 'APPLY_SYNC_PLAYBACK', \r\n            currentTime: message.currentTime, \r\n            isPlaying: message.isPlaying,\r\n            fromUserId: message.userId \r\n          }).catch(() => {});\r\n        });\r\n      });\r\n    }\r\n\r\n    if (message.type === 'SEEK' && message.userId !== userId) {\r\n      console.log('Forwarding SEEK command from remote user');\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, { \r\n            type: 'APPLY_SEEK', \r\n            currentTime: message.currentTime, \r\n            isPlaying: message.isPlaying,\r\n            fromUserId: message.userId \r\n          }).catch(() => {});\r\n        });\r\n      });\r\n    }\r\n\r\n    if (message.type === 'URL_CHANGE' && message.userId !== userId) {\r\n      console.log('Received URL change from remote user:', message.url);\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, { \r\n            type: 'APPLY_URL_CHANGE', \r\n            url: message.url,\r\n            fromUserId: message.userId \r\n          }).catch(() => {});\r\n        });\r\n      });\r\n    }\r\n  } catch (err) {\r\n    console.error('Error handling signaling message:', err);\r\n  }\r\n}\r\n\r\n// Note: WebRTC peer connection management is handled in the content script.\r\n\r\n// Broadcast message to all peers\r\nfunction broadcastMessage(message) {\r\n  if (ws && ws.readyState === WebSocket.OPEN) {\r\n    ws.send(JSON.stringify(message));\r\n  }\r\n}\r\n"],"names":["ws","localStream","isConnected","roomId","userId","Math","random","toString","substr","async","startParty","inputRoomId","Date","now","Promise","resolve","reject","chrome","tabs","query","url","length","getMediaStreamInBackground","then","connectToSignalingServer","catch","sendMessage","id","type","response","runtime","lastError","console","warn","success","log","err","error","WebSocket","onopen","send","JSON","stringify","timestamp","forEach","tab","onmessage","event","data","message","parse","control","fromUserId","currentTime","isPlaying","handleSignalingMessage","onerror","Error","onclose","cleanup","getTracks","track","stop","broadcastMessage","readyState","OPEN","onMessage","addListener","request","sender","sendResponse","close","hasLocalStream","msg","Object","assign"],"ignoreList":[],"sourceRoot":""}