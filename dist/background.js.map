{"version":3,"file":"background.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,wCAAwC;AAC9C,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,KAAK;AACL,qBAAqB,oCAAoC;AACzD,KAAK;AACL,iBAAiB;AACjB;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,KAAK;AACL;AACA,qBAAqB,oCAAoC;AACzD,KAAK;AACL,iBAAiB;AACjB;AACA;AACA;AACA,qCAAqC,4DAA4D;AACjG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,QAAQ;AACR,uBAAuB,oCAAoC;AAC3D;AACA,MAAM;AACN,qBAAqB,4DAA4D;AACjF;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB,GAAG;AAC9B,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA,OAAO,gBAAgB;AACvB,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA,0CAA0C,yBAAyB,gBAAgB;AACnF,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,0BAA0B,kCAAkC;AAC5D;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,SAAS;AACT,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://toperparty/./chrome-extension/background.js"],"sourcesContent":["// background.js - Manages WebSocket connection and media streams\r\n\r\nlet ws = null;\r\nlet localStream = null;\r\nlet isConnected = false;\r\nlet roomId = null;\r\nlet userId = generateUserId();\r\n\r\n// WebRTC Configuration\r\nconst rtcConfig = {\r\n  iceServers: [\r\n    { urls: ['stun:stun.l.google.com:19302'] },\r\n    { urls: ['stun:stun1.l.google.com:19302'] }\r\n  ]\r\n};\r\n\r\nfunction generateUserId() {\r\n  return 'user_' + Math.random().toString(36).substr(2, 9);\r\n}\r\n\r\n// Initialize connection\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  console.log('Background received message:', request.type);\r\n  \r\n  if (request.type === 'START_PARTY') {\r\n    startParty(request.roomId).then(() => {\r\n      sendResponse({ success: true });\r\n    }).catch(err => {\r\n      sendResponse({ success: false, error: err.message });\r\n    });\r\n    return true; // Keep channel open for async response\r\n  }\r\n\r\n  if (request.type === 'STOP_PARTY') {\r\n    stopParty();\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'RESTORE_PARTY') {\r\n    console.log('Restoring party after navigation:', request.roomId);\r\n    // Use the saved userId instead of generating a new one\r\n    if (request.userId) {\r\n      userId = request.userId;\r\n    }\r\n    startParty(request.roomId).then(() => {\r\n      sendResponse({ success: true });\r\n    }).catch(err => {\r\n      console.error('Failed to restore party:', err);\r\n      sendResponse({ success: false, error: err.message });\r\n    });\r\n    return true; // Keep channel open for async response\r\n  }\r\n\r\n  if (request.type === 'GET_STATUS') {\r\n    console.log('Sending status:', { isConnected, roomId, userId, hasLocalStream: !!localStream });\r\n    sendResponse({\r\n      isConnected,\r\n      roomId,\r\n      userId,\r\n      hasLocalStream: !!localStream\r\n    });\r\n    return true;\r\n  }\r\n\r\n  if (request.type === 'PLAY_PAUSE') {\r\n    broadcastMessage({\r\n      type: 'PLAYBACK_CONTROL',\r\n      control: request.control,\r\n      timestamp: request.timestamp,\r\n      userId\r\n    });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'SYNC_TIME') {\r\n    broadcastMessage({\r\n      type: 'SYNC_PLAYBACK',\r\n      currentTime: request.currentTime,\r\n      isPlaying: request.isPlaying,\r\n      userId\r\n    });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'SEEK') {\r\n    console.log('Broadcasting SEEK command:', request.currentTime);\r\n    broadcastMessage({\r\n      type: 'SEEK',\r\n      currentTime: request.currentTime,\r\n      isPlaying: request.isPlaying,\r\n      userId\r\n    });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'URL_CHANGE') {\r\n    console.log('Broadcasting URL change:', request.url);\r\n    broadcastMessage({\r\n      type: 'URL_CHANGE',\r\n      url: request.url,\r\n      userId\r\n    });\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  // Relay signaling messages from content scripts (offers/answers/ice)\r\n  if (request.type === 'SIGNAL_SEND') {\r\n    const msg = Object.assign({}, request.message || {});\r\n    // ensure identifying info is present\r\n    msg.userId = msg.userId || userId;\r\n    msg.roomId = msg.roomId || roomId;\r\n    if (ws && ws.readyState === WebSocket.OPEN) {\r\n      try {\r\n        ws.send(JSON.stringify(msg));\r\n        sendResponse({ success: true });\r\n      } catch (err) {\r\n        sendResponse({ success: false, error: err.message });\r\n      }\r\n    } else {\r\n      sendResponse({ success: false, error: 'Not connected to signaling server' });\r\n    }\r\n    return true;\r\n  }\r\n});\r\n\r\n// Start party mode\r\nasync function startParty(inputRoomId) {\r\n  roomId = inputRoomId || 'default_room_' + Date.now();\r\n\r\n  // Request media stream from content script\r\n  return new Promise((resolve, reject) => {\r\n    try {\r\n      // First, try to get media access through the content script\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        if (tabs.length === 0) {\r\n          // If no Netflix tab, we can still try to get media in the background\r\n          getMediaStreamInBackground()\r\n            .then(() => connectToSignalingServer(resolve, reject))\r\n            .catch(reject);\r\n        } else {\r\n          // Ask the Netflix content script to get media\r\n          chrome.tabs.sendMessage(tabs[0].id, {\r\n            type: 'REQUEST_MEDIA_STREAM'\r\n          }, (response) => {\r\n            if (chrome.runtime.lastError) {\r\n              console.warn('Content script not ready, trying background:', chrome.runtime.lastError);\r\n              getMediaStreamInBackground()\r\n                .then(() => connectToSignalingServer(resolve, reject))\r\n                .catch(reject);\r\n              return;\r\n            }\r\n            \r\n            if (response && response.success) {\r\n              console.log('Got media stream from content script');\r\n              connectToSignalingServer(resolve, reject);\r\n            } else {\r\n              // Fallback to background attempt\r\n              console.warn('Content script failed to get media, trying background');\r\n              getMediaStreamInBackground()\r\n                .then(() => connectToSignalingServer(resolve, reject))\r\n                .catch(reject);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    } catch (err) {\r\n      reject(err);\r\n    }\r\n  });\r\n}\r\n\r\n// Try to get media stream in background (for testing without Netflix tab)\r\nasync function getMediaStreamInBackground() {\r\n  try {\r\n    // This will fail in service worker, but we set a flag so we can continue\r\n    // In production, the content script will handle this\r\n    console.log('Note: Media stream will be obtained from Netflix page');\r\n    return;\r\n  } catch (err) {\r\n    console.error('Could not get media in background:', err);\r\n    throw err;\r\n  }\r\n}\r\n\r\n// Connect to signaling server\r\nfunction connectToSignalingServer(resolve, reject) {\r\n  try {\r\n    ws = new WebSocket('ws://watch.toper.dev/ws');\r\n\r\n    ws.onopen = () => {\r\n      console.log('Connected to signaling server');\r\n      isConnected = true;\r\n\r\n      // Send join message\r\n      ws.send(JSON.stringify({\r\n        type: 'JOIN',\r\n        userId,\r\n        roomId,\r\n        timestamp: Date.now()\r\n      }));\r\n\r\n      // Notify all tabs\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, {\r\n            type: 'PARTY_STARTED',\r\n            userId,\r\n            roomId\r\n          }).catch(() => {}); // Ignore errors if content script not ready\r\n        });\r\n      });\r\n\r\n      resolve();\r\n    };\r\n\r\n    ws.onmessage = (event) => {\r\n      handleSignalingMessage(event.data);\r\n    };\r\n\r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n      reject(new Error('Failed to connect to signaling server'));\r\n    };\r\n\r\n    ws.onclose = () => {\r\n      console.log('Disconnected from signaling server');\r\n      isConnected = false;\r\n      cleanup();\r\n    };\r\n  } catch (err) {\r\n    reject(err);\r\n  }\r\n}\r\n\r\n// Stop party mode\r\nfunction stopParty() {\r\n  if (ws) {\r\n    ws.send(JSON.stringify({\r\n      type: 'LEAVE',\r\n      userId,\r\n      roomId,\r\n      timestamp: Date.now()\r\n    }));\r\n    ws.close();\r\n    ws = null;\r\n  }\r\n\r\n  cleanup();\r\n  isConnected = false;\r\n\r\n  // Notify all tabs\r\n  chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n    tabs.forEach(tab => {\r\n      chrome.tabs.sendMessage(tab.id, {\r\n        type: 'PARTY_STOPPED'\r\n      }).catch(() => {});\r\n    });\r\n  });\r\n}\r\n\r\n// Cleanup resources\r\nfunction cleanup() {\r\n  if (localStream) {\r\n    localStream.getTracks().forEach(track => track.stop());\r\n    localStream = null;\r\n  }\r\n}\r\n\r\n// Handle signaling messages\r\nasync function handleSignalingMessage(data) {\r\n  try {\r\n    const message = JSON.parse(data);\r\n\r\n    // Forward signaling payloads to all Netflix tabs so content scripts can handle WebRTC\r\n    chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n      tabs.forEach(tab => {\r\n        chrome.tabs.sendMessage(tab.id, { type: 'SIGNAL', message }).catch(() => {});\r\n      });\r\n    });\r\n\r\n    // Additionally handle playback control / sync specially (apply immediately)\r\n    if (message.type === 'PLAYBACK_CONTROL' && message.userId !== userId) {\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, { \r\n            type: 'APPLY_PLAYBACK_CONTROL', \r\n            control: message.control, \r\n            timestamp: message.timestamp,\r\n            fromUserId: message.userId \r\n          }).catch(() => {});\r\n        });\r\n      });\r\n    }\r\n\r\n    if (message.type === 'SYNC_PLAYBACK' && message.userId !== userId) {\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, { \r\n            type: 'APPLY_SYNC_PLAYBACK', \r\n            currentTime: message.currentTime, \r\n            isPlaying: message.isPlaying,\r\n            fromUserId: message.userId \r\n          }).catch(() => {});\r\n        });\r\n      });\r\n    }\r\n\r\n    if (message.type === 'SEEK' && message.userId !== userId) {\r\n      console.log('Forwarding SEEK command from remote user');\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, { \r\n            type: 'APPLY_SEEK', \r\n            currentTime: message.currentTime, \r\n            isPlaying: message.isPlaying,\r\n            fromUserId: message.userId \r\n          }).catch(() => {});\r\n        });\r\n      });\r\n    }\r\n\r\n    if (message.type === 'URL_CHANGE' && message.userId !== userId) {\r\n      console.log('Received URL change from remote user:', message.url);\r\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\r\n        tabs.forEach(tab => {\r\n          chrome.tabs.sendMessage(tab.id, { \r\n            type: 'APPLY_URL_CHANGE', \r\n            url: message.url,\r\n            fromUserId: message.userId \r\n          }).catch(() => {});\r\n        });\r\n      });\r\n    }\r\n  } catch (err) {\r\n    console.error('Error handling signaling message:', err);\r\n  }\r\n}\r\n\r\n// Note: WebRTC peer connection management is handled in the content script.\r\n\r\n// Broadcast message to all peers\r\nfunction broadcastMessage(message) {\r\n  if (ws && ws.readyState === WebSocket.OPEN) {\r\n    ws.send(JSON.stringify(message));\r\n  }\r\n}\r\n"],"names":[],"ignoreList":[],"sourceRoot":""}